{"meta":{"title":"Zh's Blog","subtitle":null,"description":"多总结，多思考","author":"Zh","url":"http://yoursite.com"},"pages":[{"title":"","date":"2022-06-06T03:22:14.527Z","updated":"2022-06-06T03:22:14.527Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me现居杭州，计算机视觉在读研究生，前端工程师"},{"title":"","date":"2022-06-06T03:22:14.528Z","updated":"2022-06-06T03:22:14.528Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-06T03:22:14.556Z","updated":"2022-06-06T03:22:14.556Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-06T03:22:14.557Z","updated":"2022-06-06T03:22:14.557Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python之函数使用","slug":"React Native中渲染的坑","date":"2022-06-06T03:55:00.000Z","updated":"2022-06-06T05:50:00.980Z","comments":true,"path":"2022/06/06/React Native中渲染的坑/","link":"","permalink":"http://yoursite.com/2022/06/06/React%20Native%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9D%91/","excerpt":"","text":"解决方案来自StackOverflow 问题当React Native从 0.54 升级到 0.57，代码报了以下错误 Invariant Violation: Text strings must be rendered within a &lt;Text&gt; component 乍一看好像是文本没有写在&lt;Text&gt;标签里，查了一下代码发现没有这个问题。最后网上搜索后解决 以下为伪代码： 1condition &amp;&amp; &lt;MyComponent /&gt;; 需要修改为： 1condition ? &lt;MyComponent /&gt; : null; 这是因为condition为undefined时，将不会渲染任何组件，而null或空数组可以安全的显示空白区域 Tips: undefined &amp;&amp; true 与 true &amp;&amp; undefined 的结果都为 undefined","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"什么是事件委托（代理）？","slug":"什么是事件委托（代理）？","date":"2022-04-04T11:35:24.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2022/04/04/什么是事件委托（代理）？/","link":"","permalink":"http://yoursite.com/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89%EF%BC%9F/","excerpt":"","text":"前置知识事件冒泡 &amp;&amp; 事件捕获当我们触发一个元素事件时，如果事件从最内层元素传递到最外层元素，此过程为事件冒泡，如果从最外层元素传递到最内层元素，此过程为事件捕获 如以下代码所示： 若触发事件冒泡，则事件执行顺序为c、b、a 若触发事件捕获，则事件执行顺序为a、b、c 123456&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; &lt;div class=&quot;c&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Javascript中addEventListener为元素绑定事件的方法，它接收三个参数 event：绑定的事件名 function：执行的回调函数 useCapture false: 默认，代表冒泡时绑定 true: 代表捕获时绑定 e.target和e.currentTarget在以上的例子中新增js代码 123456789101112131415161718192021&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; &lt;div class=&quot;c&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; const a =document.querySelector(&#x27;.a&#x27;) const b =document.querySelector(&#x27;.b&#x27;) const c =document.querySelector(&#x27;.c&#x27;) a.addEventListener(&#x27;click&#x27;, function(e) &#123; console.log(`target: $&#123;e.target.className&#125;, currentTarget：$&#123;e.currentTarget.className&#125;`) &#125;) b.addEventListener(&#x27;click&#x27;, function(e) &#123; console.log(`target: $&#123;e.target.className&#125;, currentTarget：$&#123;e.currentTarget.className&#125;`) &#125;) c.addEventListener(&#x27;click&#x27;, function(e) &#123; console.log(`target: $&#123;e.target.className&#125;, currentTarget：$&#123;e.currentTarget.className&#125;`) &#125;)&lt;/script&gt; 点击c元素，控制台打印结果为： 123target: c, currentTarget：ctarget: c, currentTarget：btarget: c, currentTarget：a 由此我们可以得出结论e.target为我们点击的元素（可以理解为c在a、b的上层，所以我们点击的是c），e.currentTarget为绑定事件的元素（这里是冒泡，所以从c-&gt;a） 事件委托考虑一个需求： 123456&lt;ul class=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 如上所示，ul中有4个li，如果我们想在点击li后输出对应li的内容怎么办？ 没错，我们可以给每个li都绑定一个事件，但你有没有想过，这里只有4个li，实际应用场景可能不止这么多，那难道我们给每个li都绑定事件吗？ 利用我们之前所学的知识，我们可以进行如下操作： 12345678910111213&lt;ul class=&quot;ul&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; const ul = document.querySelector(&#x27;.ul&#x27;) ul.addEventListener(&#x27;click&#x27;, function(e) &#123; console.log(e.target.innerHTML) &#125;)&lt;/script&gt; 这就是事件委托啦，就是把子元素的事件，其原理就是利用事件冒泡和e.target，把处理子元素的操作，委托在父元素的事件中处理。，","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Javascript常见手写题","slug":"Javascript常见手写题","date":"2022-03-20T11:17:24.000Z","updated":"2022-06-06T03:22:14.522Z","comments":true,"path":"2022/03/20/Javascript常见手写题/","link":"","permalink":"http://yoursite.com/2022/03/20/Javascript%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98/","excerpt":"","text":"防抖（debounce）123456789function debounce(fn, timeout)&#123; let timer = null return function(...args)&#123; if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, timeout) &#125;&#125; 节流（throttle）12345678910function throttle(fn, timeout) &#123; let timer = null return function (...args) &#123; if(timer) return timer = setTimeout(() =&gt; &#123; fn.apply(this, args) timer = null &#125;, timeout) &#125;&#125; 函数柯里化（Currying）123456789101112131415161718192021222324function dynamicAdd() &#123; return [...arguments].reduce((a, b) =&gt; a + b);&#125;function curry(fn) &#123; const args = []; const add = function() &#123; args.push(...arguments); return add; &#125; add.toString = function() &#123; return fn.apply(null, args) &#125; return add;&#125;const add = curry(dynamicAdd);console.log(+add(1)) // 1console.log(+add(1)(2)) // 2console.log(+add(1)(2)(3)) // 4console.log(+add(1, 2, 3)(4, 5)) // 25 数据类型判断123456789101112131415161718function typeOf(x) &#123; if (typeof x !== &#x27;object&#x27;)&#123; return typeof x &#125; else &#123; return Object.prototype.toString.call(x).slice(8, -1).toLowerCase() &#125;&#125;console.log(typeOf(1)) // numberconsole.log(typeOf(&#x27;1&#x27;)) // stringconsole.log(typeOf(null)) // nullconsole.log(typeOf(undefined)) // undefinedconsole.log(typeOf(true)) // booleanconsole.log(typeOf(Symbol(&#x27;1&#x27;))) // symbolconsole.log(typeOf(BigInt(1))) // bigintconsole.log(typeOf(new Array([]))) // arrayconsole.log(typeOf(new Date())) // dateconsole.log(typeOf(&#123;&#125;)) // object 数组去重ES5实现：123456function unique(arr) &#123; var res = arr.filter(function(item, index) &#123; return arr.indexOf(item) === index &#125;) return res&#125; ES6实现：1const unique = arr =&gt; Array.from([...new Set(arr)]) 数组扁平化ES5实现：12345678910111213function flatten(arr) &#123; var res = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; res = res.concat(flatten(arr[i])) &#125; else &#123; res.push(arr[i]) &#125; &#125; return res&#125; ES6实现：123456function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr) &#125; return arr&#125; PromisePromise.all1234567891011121314151617181920const all = promiseList =&gt; &#123; const result = [] let count = 0 return new Promise((resolve, reject) =&gt; &#123; const addData = (index, value) =&gt; &#123; result[index] = value count++ if (count === promiseList.length) resolve(result) &#125; promiseList.forEach((promise, index) =&gt; &#123; if (promise instanceof Promise) &#123; promise.then(res =&gt; &#123; addData(index, res) &#125;, err =&gt; reject(err)) &#125; else &#123; addData(index, promise) &#125; &#125;) &#125;)&#125; Promise.race123456789101112131415const race = promiseList =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; promiseList.forEach(promise =&gt; &#123; if (promise instanceof Promise) &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125; Promise.allSettled123456789101112131415161718192021222324252627const allSettled = promiseList =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const res = [] let count = 0 const addData = (status, value, i) =&gt; &#123; res[i] = &#123; status, value &#125; count++ if (count === promiseList.length) &#123; resolve(res) &#125; &#125; promiseList.forEach((promise, i) =&gt; &#123; if (promise instanceof Promise) &#123; promise.then(res =&gt; &#123; addData(&#x27;fulfilled&#x27;, res, i) &#125;, err =&gt; &#123; addData(&#x27;rejected&#x27;, err, i) &#125;) &#125; else &#123; addData(&#x27;fulfilled&#x27;, promise, i) &#125; &#125;) &#125;)&#125; Promise.any12345678910111213141516171819const any = promiseList =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promiseList.forEach((promise) =&gt; &#123; if (promise instanceof Promise) &#123; promise.then(val =&gt; &#123; resolve(val) &#125;, err =&gt; &#123; count++ if (count === promiseList.length) &#123; reject(new AggregateError(&#x27;All promises were rejected&#x27;)) &#125; &#125;) &#125; else &#123; resolve(promise) &#125; &#125;) &#125;)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"浏览器到底是怎么渲染页面的?","slug":"浏览器到底是怎么渲染页面的？","date":"2022-03-20T02:21:23.000Z","updated":"2022-06-06T03:22:14.526Z","comments":true,"path":"2022/03/20/浏览器到底是怎么渲染页面的？/","link":"","permalink":"http://yoursite.com/2022/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F/","excerpt":"","text":"三个阶段当url输入到地址栏，到页面渲染完成，总共会有三个阶段 HTTP请求阶段 HTTP响应阶段 浏览器渲染阶段 让我们来看看每个阶段到底发生了什么 HTTP请求阶段 在浏览器地址栏输入URL后，点击回车跳转 浏览器向服务器发起HTTP请求 DNS解析 TCP三次握手建立连接 建立连接后发起请求 HTTP响应阶段 服务端准备资源 服务端将资源返回给浏览器 TCP四次挥手断开连接 浏览器渲染阶段 接受返回的资源 在内存中开辟出一块栈内存 解析代码（当遇到link、img、script等需要加载外部资源的文件后，开辟新的线程去加载资源文件） 解析DOM，形成DOM树，加载CSS，形成CSSOM树（DOM和CSSOM通常并行构建） 浏览器将DOM树和CSS树合并生成Render Tree（渲染树） 页面进行回流，完成基本的布局 页面进行重绘，进行样式的展示 GPU渲染整个页面 HTML与CSS的解析主要由GUI渲染线程负责，js由Javascript引擎线程负责，由于js可以操作dom元素和样式，所以如果GUI线程和Javascript引擎线程一起并行会造成冲突。因此GUI渲染线程与Javascript引擎线程是互斥的。 若解析dom时遇到script需要执行js，则会阻塞js的执行，直到css样式表加载完成 若解析dom时css已加载完毕，遇到script需要执行js，则会停止解析dom，先执行js。因此，我们最好把script放在body的最后面。 DOMContentLoaded 与 load 的区别? 当DOMContentLoaded事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。我们前面提到CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js会阻塞 Dom 解析,所以我们可以得到结论:当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。 DOMContentLoaded -&gt; load。 link标签为什么放在head标签里？我们平时编写代码时，一般都把加载css的&lt;link&gt;标签都放在&lt;head&gt;标签中，而不是像加载js文件的script标签那样放在body中最后，这是为什么呢？ 放在body中：DOM Tree构建完成之后便开始构建Render Tree, 并计算布局渲染网页, 等加载解析完css之后, 开始构建CSSOM Tree, 并和DOM Tree重新构建Render Tree, 重新计算布局渲染网页。 放在head中：先加载css, 之后解析css构建CSSOM Tree, 于此同时构建DOMTree, CSSOM Tree和DOM Tree都构建完毕之后开始构建Render Tree, 计算布局渲染网页。 对比两者, css放在&lt;head&gt;标签中比css放在body标签尾部少了一次构建Render Tree, 一次计算布局和一次渲染网页, 因此性能会更好; 并且css放在body标签尾部时会在网页中短暂出现”裸奔”的HTML, 这不利于用户体验。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Javascript伪数组与arguments","slug":"Javascript伪数组与arguments","date":"2022-03-19T13:59:01.000Z","updated":"2022-06-06T03:22:14.521Z","comments":true,"path":"2022/03/19/Javascript伪数组与arguments/","link":"","permalink":"http://yoursite.com/2022/03/19/Javascript%E4%BC%AA%E6%95%B0%E7%BB%84%E4%B8%8Earguments/","excerpt":"","text":"什么是伪数组？所谓伪数组，也称为类数组对象，指的是可以通过索引属性访问元素并且拥有 length 属性的对象。 以下为一个简单的伪数组的例子： 123456const arrFake = &#123; 0: &#x27;name&#x27;, 1: &#x27;age&#x27;, 2: &#x27;job&#x27;, length: 3&#125; 它所对应的数组如下所示： 1const arr = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]; 它们的相同点： 12345678console.log(arr[0]) // nameconsole.log(arrFake[0]) // namearr[0] = &#x27;new name&#x27;arrFake[0] = &#x27;new name&#x27;console.log(arr.length); // 3console.log(arrFake.length); // 3 它们的不同点在于，伪数组不能调用数组原型链上的方法，且伪数组调用Array.isArray方法输出false： 12345arrFake.push(&#x27;hobby&#x27;) // Uncaught TypeError: arrFake.push is not a functionarr.push(&#x27;hobby&#x27;); // [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;]Array.isArray(arrFake) // falseArray.isArray(arr) // true 我们可以用Array.from将伪数组转化为真正的数组 12const newArr = Array.from(arrFake) // [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]newArr.push(&#x27;hobby&#x27;) // [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;] 也可以使用1.Array.prototype.slice等返回新数组的方法2.扩展运算符[…arguments] js中的伪数组对象： document.getElementsByTagName获取的元素标签集合 函数中的arguments arguments定义如下函数： 12345function a(x, y) &#123; console.log(arguments)&#125;a(1, 2, 3, 4) 注意！箭头函数没有 arguments 在控制台显示打印结果： 显然，arguments就是一个伪数组，callee属性如上图所示，为函数本身，我们可以使用arguments.callee()的方式调用函数。 再思考一下以下代码： 123456function a(x, y) &#123; console.log(a.length) // 2 console.log(arguments.length) // 4&#125;a(1, 2, 3, 4) 其中function本身的length代表行参的长度，而arguments的length代表实参的长度。 注意！function本身的length不包括有默认值的形参和剩余参数…args arguments的应用实现函数的重载12345678910function doAdd() &#123; if (arguments.length == 1) &#123; console.log(arguments[0] + 5); &#125; else if (arguments.length == 2) &#123; console.log(arguments[0] + arguments[1]); &#125;&#125;doAdd(1) // 6doAdd(1, 2) // 3","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"V8引擎的垃圾回收机制","slug":"V8引擎的垃圾回收机制","date":"2022-03-10T13:17:51.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2022/03/10/V8引擎的垃圾回收机制/","link":"","permalink":"http://yoursite.com/2022/03/10/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、Javascript内存管理JavaScript内存的流程很简单，分为3步： 分配给使用者所需的内存 使用者拿到这些内存，并使用内存 使用者不需要这些内存了，释放并归还给系统 那么这些使用者是谁呢？举个例子：12345var num = &#x27;&#x27;var str = &#x27;Zh&#x27;var obj = &#123; name: &#x27;Zh&#x27; &#125;obj = &#123; name: &#x27;Zh&#x27; &#125;上面这些num，str，obj就是就是使用者，我们都知道，JavaScript数据类型分为基础数据类型和引用数据类型: 基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问 引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问 由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的 由于堆内存所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存二、V8引擎的垃圾回收机制为何需要垃圾回收在Chrome中，V8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制呢？ 表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景 深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降） 三、V8引擎的垃圾回收算法1.分代回收在JavaScript中，对象存活周期分为两种情况。 存活周期很短：经过一次垃圾回收后，就被释放回收掉 存活周期很长：经过多次垃圾回收后，他还存在，赖着不走 那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？ 对于这个问题，V8做了分代回收的优化方法，通俗点说就是：V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方 新生代通常只有1-8M的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收 副垃圾回收器 + Scavenge算法：主要负责新生代的垃圾回收主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法：主要负责老生代的垃圾回收 1.1 新生代在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用Scavenge算法进行垃圾回收，Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。Scavange算法将新生代堆分为两部分，分别叫from-space和to-space，工作方式也很简单，就是将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用。 具体步骤为以下4步： 标记活动对象和非活动对象 复制from-space的活动对象到to-space中并进行排序 清除from-space中的非活动对象 将from-space和to-space进行角色互换，以便下一次的Scavenge算法垃圾回收 那么，垃圾回收器是怎么知道哪些对象是活动对象，哪些是非活动对象呢？ 这就要不得不提一个东西了——可达性。什么是可达性呢？就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。 新生代中的对象什么时候变成老生代的对象？ 在新生代中，还进一步进行了细分。分为nursery子代和intermediate子代两个区域，一个对象第一次分配内存时会被分配到新生代中的nursery子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到intermediate子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升 1.2老生代新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用Scavenge算法，为啥呢，有以下原因： cavenge`算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低 cavenge算法是以空间换时间的算法，老生代是内存很大的空间，如果使用Scavenge`法，空间资源非常浪费，得不偿失啊。。 所以老生代里使用了Mark-Sweep算法(标记清理)和Mark-Compact算法(标记整理) Mark-Sweep(标记清理)Mark-Sweep两个阶段，标记和清理阶段，之前的Scavenge算法标记和清理，但是Mark-Sweep算法跟Scavenge算法的区别是，后者需要复制后再清理，前者不需要，Mark-Sweep直接标记活动对象和非活动对象之后，就直接执行清理了。 标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记 清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象 由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多零零散散的空位。 Mark-Compact(标记整理)Mark-Sweep算法执行垃圾回收之后，留下了很多零零散散的空位，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从零零散散的空位中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是Mark-Sweep算法的一个缺点这个时候Mark-Compact算法出现了，他是Mark-Sweep算法的加强版，在Mark-Sweep算法的基础上，加上了整理阶段，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存 2. 全停顿(Stop-The-World)说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为全停顿 由于新生代空间小，并且存活对象少，再配合Scavenge算法顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了卡顿现象 3. Orinoco优化orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题,它提出了增量标记、懒性清理、并发、并行的优化方法。 3.1 增量标记(Incremental marking)咱们前面不断强调了先标记，后清除，而增量标记就是在标记这个阶段进行了优化。我举个生动的例子：路上有很多垃圾，害得路人都走不了路，需要清洁工打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。 大家把上面例子里，清洁工清理垃圾的过程——标记过程，路人——JS代码，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS代码运行一段，从而提高效率 3.2 惰性清理(Lazy sweeping)上面说了，增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理整理标记和惰性清理的出现，大大改善了全停顿现象。但是问题也来了：增量标记是标记一点，JS运行一段，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成对象引用改变，标记错误现象。这就需要使用写屏障技术来记录这些引用关系的变化 3.3 并发(Concurrent)并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。 3.4 并行并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。 V8当前的垃圾回收机制2011年，V8应用了增量标记机制。直至2018年，Chrome64和Node.js V10启动并发标记（Concurrent），同时在并发的基础上添加并行（Parallel）技术，使得垃圾回收时间大幅度缩短。 副垃圾回收器V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。 主垃圾回收器V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。 当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"V8","slug":"V8","permalink":"http://yoursite.com/tags/V8/"},{"name":"垃圾回收机制","slug":"垃圾回收机制","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"}]},{"title":"Javascript如何避免内存泄漏","slug":"Javascript如何避免内存泄漏","date":"2022-03-10T12:49:51.000Z","updated":"2022-06-06T03:22:14.521Z","comments":true,"path":"2022/03/10/Javascript如何避免内存泄漏/","link":"","permalink":"http://yoursite.com/2022/03/10/Javascript%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/","excerpt":"","text":"一、如何监控内存状况这里借用一下林三心大佬的图文。 浏览器任务管理器打开方式：在浏览器顶部右键，打开任务管理器： 打开后，可以看到内存和JavaScript内存： 内存：页面里的原始内存，也就是DOM节点的总占用内存 JavaScript内存(括号里)：是该页面中所有可达对象的总占用内存 那什么是可达对象呢？简单说就是：就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，搜不到，说明该子节点对象不可达。举个例子： 1234567// 可达，可以通过window.name访问var name = &#x27;Zh&#x27;function fn () &#123; // 不可达，访问不了 var name = &#x27;Zh&#x27;&#125; 回到我们的任务管理，此时我们在页面中编写一段代码：123456&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;&lt;script&gt; document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; list = new Array(1000000) &#125;&lt;/script&gt;点击前：点击后，发现内存瞬间上升： Performance使用Chrome浏览器的无痕模式，是为了避免很多其他因素，影响咱们查看内存： 按F12打开调试窗口，选择Performance 咱们就以掘金首页为例吧！点击录制 -&gt; 刷新掘金 -&gt; 点击stop，可以看到以下指标随着时间的上下波动： JS Heap：JS堆 Documents: 文档 Nodes: DOM节点 Listeners: 监听器 GPU Memory: GPU内存 堆快照堆快照，顾名思义，就是将当前某一个页面的堆内存拍下照片存起来，同一个页面，执行某个操作前，录制堆快照是一个样，有可能执行完后，录制的堆快照又是另外一个样。 还是以掘金首页为例，可以看到当前页面内存为13.3M，咱们可以选择Statistics，查看数组，对象，字符串等所占内存。 二、内存泄漏的场景下面列举了可能会造成内存泄漏的情况： 闭包使用不当引起内存泄漏 全局变量 分离的DOM节 控制台的打印 未清除的定时器接下来我们一一来介绍这些情况。 1.闭包使用不当123456789function fn1() &#123; let arr = new Array(100000) return arr&#125;let a = []document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; a.push(fn1())&#125; 上述代码中f1被调用后，从可达性的角度来说，arr应该被回收，但实际上并不是这样的。f1将arrreturn之后，arr被push进了数组a，而数组a是一个全局变量，并不会被回收，这就导致了arr不会被回收。 全局变量全局变量一般不会被垃圾回收机制回收。当然，这并不意味着完全禁止我们定义全局变量，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示： 12345function fn1() &#123; // 此处变量arr未被声明 arr = new Array(100000)&#125;fn1() 上述代码会自动在全局创建一个变量arr，并将数组赋值给arr，由于是全局变量，所以arr的内存一直不会释放。 因此，我们平时需多加注意，不要在变量未声明前赋值，或者也可以开启严格模式，这样就会在不知情犯错时，收到报错警告，例如： 123456function fn1() &#123; &#x27;use strict&#x27;; name = new Array(100000)&#125;fn1() 3.分离的dom节点让我们用代码来解释一下什么为分离的dom节点:1234&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;let btn = document.getElementById(&#x27;btn&#x27;)document.body.removeChild(btn) 如上所示，虽然最后把button给删除了，但是因为全局变量btn对此DOM对象引用着，导致此DOM对象一直没有被回收，这个DOM对象就称为分离DOM 这个问题很好解决，删除button后，顺便把btn设置成null就行了：12345&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;let btn = document.getElementById(&#x27;btn&#x27;)document.body.removeChild(btn)btn = null 4.控制台的打印控制台的打印也会造成内存泄漏吗？？？是的呀，如果浏览器不一直保存着我们打印对象的信息，我们为何能在每次打开控制的Console时看到具体的数据呢？先来看一段测试代码： 1234567&lt;button&gt;按钮&lt;/button&gt;&lt;script&gt; document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;,function(&#123; let arr = new Array(100000) console.log(obj); &#125;)&lt;/script&gt; 当我们点击按钮时，这个arr会被控制台打印下来，浏览器一直保存着这个arr的信息，并不会被垃圾回收机制回收。 虽然console.log便于调试，但是我们在生产环境，我们尽可能不要在控制台打印数据，所以我们经常会在代码中看到类似如下的操作：1234// 如果在开发环境下，打印变量objif(isDev) &#123; console.log(obj)&#125;这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了console.log之外，console.error、console.info、console.dir等等都不要在生产环境下使用 5.未清除的定时器下面这段代码中，执行完fn1函数，按理说arr数组会被回收，但是他却回收不了。为什么呢？因为定时器里的a引用着arr，并且定时器不清除的话，a就不会被回收，a不回收就会一直引用着arr，那么arr肯定也回收不了了。 123456789function fn() &#123; let arr = new Array(1000000).fill(&#x27;Sunshine_Lin&#x27;) setInterval(() =&gt; &#123; let a = arr &#125;, 1000)&#125;document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; fn()&#125; 处理的方法也很简单，只要我们清除定时器就行了：123456789101112function fn() &#123; let arr = new Array(1000000).fill(&#x27;Sunshine_Lin&#x27;) let i = 0 let timer = setInterval(() =&gt; &#123; if (i &gt; 5) clearInterval(timer) let a = arr i++ &#125;, 1000)&#125;document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; fn()&#125; 三、总结在项目过程中，如果遇到了某些性能问题可能跟内存泄漏有关时，就可以参照以上列举的5种情况去排查。 虽然JavaScript的垃圾回收是自动的，但我们有时也是需要考虑要不要手动清除某些变量的内存占用的，例如你明确某个变量在一定条件下再也不需要，但是还会被外部变量引用导致内存无法得到释放时，你可以用null对该变量重新赋值就可以在后续垃圾回收阶段释放该变量的内存了。 参考资料赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了一文带你了解如何排查内存泄漏导致的页面卡顿现象","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"Javascript中isNaN和Numer.isNaN的区别","slug":"Javascript中isNaN和Numer.isNaN的区别","date":"2022-03-09T02:32:01.000Z","updated":"2022-06-06T03:22:14.521Z","comments":true,"path":"2022/03/09/Javascript中isNaN和Numer.isNaN的区别/","link":"","permalink":"http://yoursite.com/2022/03/09/Javascript%E4%B8%ADisNaN%E5%92%8CNumer.isNaN%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"isNaN()当我们将参数传入isNaN时，它的内部实现调用了Number()方法将参数转换为Number类型，如下所示。 1234567Number(&#x27;&#x27;) // 0Number(null) // 0Number(true) // 1Number(false) // 0Number(undefined) // NaNNumber(&#x27;aa&#x27;) // NaNNumber(NaN) // NaN 若能成功转换为Number类型，isNaN返回false，否则返回true。1234567isNaN(&#x27;&#x27;) // falseisNaN(null) // falseisNaN(true) // falseisNaN(false) // falseisNaN(undefined) // trueisNaN(&#x27;aa&#x27;) // trueisNaN(NaN) // true Javascript中0 / 0返回的是NaN，而非0数值除以0返回的是Infinity Number.isNaN()判断传入的参数是否严格等于NaN（也就是===） 1234567Number.isNaN(&#x27;&#x27;) // falseNumber.isNaN(null) // falseNumber.isNaN(true) // falseNumber.isNaN(false) // falseNumber.isNaN(undefined) // falseNumber.isNaN(&#x27;aa&#x27;) // falseNumber.isNaN(NaN) // true 使用场景：判断某个运算的结果是否为NaN1234function check(value) &#123; return Number.isNaN();&#125;check(1 / &#x27;test&#x27;) // false","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"词法作用域？动态作用域？闭包是如何产生的？","slug":"词法作用域？动态作用域？闭包是如何产生的？","date":"2022-03-08T11:50:03.000Z","updated":"2022-06-06T03:22:14.527Z","comments":true,"path":"2022/03/08/词法作用域？动态作用域？闭包是如何产生的？/","link":"","permalink":"http://yoursite.com/2022/03/08/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F/","excerpt":"","text":"词法作用域词法作用域就是定义在词法阶段的作用域，就是说跟我们写代码时将变量定义在哪个函数作用域或者块作用域中有关系，大多数情况是不变的（evel/with会修改） 图片来自《你不知道的Javascript》 包含着全局作用域，包括标识符foo 包含着foo所创建的作用域，包括标识符：a,bar和b 包含着bar所创建的作用域, 包括标识符c无论函数在哪里被调用，它的词法作用域都只有函数被声明时所处的位置决定。 动态作用域首先我们先了解一下什么是动态作用域，再看闭包与它的区别。 动态作用域就是说当查询标识符的时候不是按照词法作用域嵌套来查找，而是按照调用顺序来查找的， 也就是说 动态作用域不关注你在什么地方声明，它只关心是在何处调用的。 123456789101112function foo()&#123; console.log(a)&#125;function bar()&#123; var a = 3 foo()&#125;var a = 2 bar() // 3 不是2 事实上输出的是2，JavaScript并不具有动态作用域,它只有词法作用域,简单明了,但是this机制某种程度上很像动态作用域 闭包当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行 12345678910function foo()&#123; var a = 2 function bar()&#123; console.log(a) &#125; return bar&#125;let baz = foo()baz() // 2 上述代码中foo()执行之后返回一个内部函数bar，然后被赋值给了baz，当baz被调用时实际上就是调用了bar，输出了函数foo作用域中的变量a。 无论使用何种方式对函数类型的值传递，当函数在其他作用域被调用时都可以理解为闭包。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"Javascript的事件循环机制(event loop)","slug":"Javascript的事件循环机制(event loop)","date":"2022-03-04T13:47:33.000Z","updated":"2022-06-06T03:22:14.522Z","comments":true,"path":"2022/03/04/Javascript的事件循环机制(event loop)/","link":"","permalink":"http://yoursite.com/2022/03/04/Javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6(event%20loop)/","excerpt":"","text":"一、Javascript引擎的特点：单线程与非阻塞单线程JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。 比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 非阻塞非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。非阻塞是通过事件循环机制实现的。JS通常是非阻塞的，除了某些特殊情况，JS会停止代码执行。 二、事件循环（Event Loop）任务队列单线程意味着所有任务需要排队，如果前一个任务耗时很长，就会对后续任务造成阻塞。 如果造成阻塞的任务是因为计算量大，那么情有可原，毕竟CPU的利用率高，但如果是等待IO设备的响应，那么这种情况下CPU利用率很低，那显然是不合理的。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1） 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 以一道经典的面试题为例： 12345for(var i = 0; i &lt; 3; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0); &#125;; 这道题的结果为：3，3，3 HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。 然而，即使第二个参数真实值也为0ms，答案依然为3，3，3。如前面所述，setTimeout()将事件插入了”任务队列“，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 宏任务与微任务以下事件属于宏任务： setInterval() setTimeout() setImmediate(Node.js 环境) 以下事件属于微任务： Promise.then Object.observe MutationObserver process.nextTick(Node.js 环境) 在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。 微任务在本轮“事件循环”结束时执行，宏任务在下一轮“事件循环”开始时执行。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"论文速读：TwoStreamVAN","slug":"论文速读：TwoStreamVAN","date":"2020-12-25T03:13:07.000Z","updated":"2022-06-06T03:22:14.527Z","comments":true,"path":"2020/12/25/论文速读：TwoStreamVAN/","link":"","permalink":"http://yoursite.com/2020/12/25/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9ATwoStreamVAN/","excerpt":"","text":"1. Introduction 原文地址：TwoStreamVAN: Improving Motion Modeling in Video Generation 像素级视频预测[27，36，40]和生成方法的一个主要问题是，它们试图在单个纠缠生成器中对静态内容和动态运动进行建模，而不管它们是否在潜在空间中解开运动和内容\\ 本文认为在解码阶段分离运动和内容建模是至关重要的。一方面，它消除了内容生成过程中的运动干扰，并产生了更好的内容结构。另一方面，单独的运动建模有助于在整个序列中一致地产生与动作相关的运动。 本文提出了一个新的TwoStreamVAN，它从一个动作标签和一个分离的噪声向量生成一个视频，如上x`图所示。通过两个并行的生成器，分别处理内容和运动，并将它们融合在一起以预测下一帧，而不是高估单个生成器的能力（如MoCoGAN的做法）。 直观地说，运动通常以其局部上下文窗口内的空间信息为条件，例如，在做跳跃动作时，手臂和腿部附近的不同运动。因此，我们将运动和内容的融合定义为对每个位置唯一的像素值的学习细化。为了精确地生成多尺度运动，我们在具有几个不同分辨率的中间内容层上进行这种细化。此外，我们还引入了运动蒙版，使运动聚焦于它所在的区域。 本文将引入图像级监控（image-levelsupervision），虽然MoCoGAN尝试了图像级监控缺效果甚微，因为内容生成仍然受到单个共享生成器中运动建模的影响。本文使用的双流生成器的关键优势是能分别学习每个流，从而更准确。我们通过图像级监控完全了解其自身生成器中的图像结构，这显著提高了内容生成性能。训练有素的内容生成进一步有利于视频级监控中的动作学习。 本文贡献如下： 我们提出了一个视频生成模型TwoStreamVAN和一个更有效的学习方案，解决了生成阶段的运动和内容问题。 我们设计了一种多尺度运动融合机制，并通过对空间环境的调节进一步改进了运动建模 我们创建了一个大规模的合成视频生成数据集，供研究团体使用 我们在四个视频数据集上通过定量和定性分析评估了我们的模型（通过用户研究），并证明了强于几个强基线的结果。 2. Related Work本文结合了VAE和GAN，提出了一个变分对抗网络(VAN)来学习一个可解释的潜在空间以及生成现实的图像。鉴于VAN在图像生成方面的成功，我们在此将其用于视频生成。 MoCoGAN试图通过从单独的潜在空间中采样来解开内容和运动，但是使用单个生成器来一起解码这两个潜在代码。为了克服统一生成过程中无效的运动建模和随之而来的内容恶化，我们进一步引入了分离的内容和运动生成器来分别对空间结构和时间动态进行建模。 3. Approach我们引入了一个双流变分对抗网络(图2)，它生成一个给定输入动作标签和随机噪声向量的视频。我们定义动作条件视频生成如下。假设我们有K个不同的动作类。在每个类别k ∈ 1: K 的情况下，C_{k}为该类别训练视频的数量。使V_{k} = {V_{i,k}, \\forall i \\in 1:C_{k}}为类别k视频的集合，v_{i,k}={x_{1},x_{2},...,x_{T}}为一个T帧的短视频。任务是定义一个函数G，该函数根据来自潜在向量\\epsilon ∈ ℝ^{N}，给定类别标签k，生成可信的视频\\hat{v}，即\\hat{v} = G(k,\\epsilon) 我们将潜在空间\\epsilon分解成两个独立的代码:内容代码\\epsilon_{c}∈ ℝ^{C}和动作代码\\epsilon_{m}∈ℝ^{M}，N = C + M.我们还将视频生成函数G分解为两个独立的内容和运动函数($ G{c} $和$ G{m} $)，与以前使用单个生成器的工作形成对比，我们设计了一种新的多尺度融合机制。 3.1 Two-Stream Generation为了学习内容和运动建模的生成函数$ G{c} $和$ G{m} $，我们引入了两个独立的、在几个阶段具有交互作用的以动作为条件的VAN streams。每个steam包含一个Encoder，一个Generator和一个Discriminator，其中Encoder和Generator作为VAE的自动编码器，Generator和Discriminator组成了GAN Content VAN Stream由内容编码器$ E{c} $、内容生成器$ G{c} $和图像鉴别器$ D{I} $组成，在观察了x之后，生成了后验内容潜在分布$ q(z{c}|x,k) $，这接近于它的真实先验分布$ p(z{c}|k) $.$ G{c} $将采样自内容分布的的内容向量$ \\epsilon{c} $解码成帧。$ D{I} $鉴别帧的真假以鼓励$ G_{c} $生成更真实的图像。 类似地，Motion VAN Stream由运动编码器$ E{m} $、运动生成器$ G{m} $和视频鉴别器$ D{V} $组成，在我们的方法中，$ E{m} $不是对空间内容进行编码，而是对相邻帧之间的差异图$ \\triangle x $的时间动态进行编码。它产生的后验运动潜在分布$ q(z{m}|\\triangle x,k) $接近其真实的先验分布$ p(z{m}|k) $.convLSTM对运动历史进行累积，并生成当前运动，嵌入$ e{m} $，从所有先前时间步长的运动分布中接收$ \\epsilon{m} $序列。$ G{m} $通过$ \\epsilon{c} $和$ e{m} $在不同的尺度上产生运动。我们通过将生成的运动与T时间步长的相应内容融合来生成每个视频$ \\hat{v} $。$ D{V} $对真实/生成的视频进行了分类，并对他们的行为进行了分类，以鼓励$ G{m} $生成逼真的动作 Multi-scale Motion Generation and Fusion在像素(a, b)处，运动通常发生在相邻帧之间的局部窗口内。受帧插值空间卷积的启发，我们将运动表示为当前像素值基础局部上下文的细化，并通过空间自适应卷积将这种运动与内容融合。此外，我们提出了一种新的多尺度融合机制来克服其方法的缺点，即:1)由于在全分辨率图像上执行单个融合步骤而导致的多尺度运动的无效建模，以及2)由于用于表示最大可能运动的大卷积核而导致的对存储器的高需求。 为了生成精确的运动，$ G{m} $将解开的内容和运动嵌入($ \\epsilon{c} $和$ e{m} $)作为输入。在$ G{m} $中，不同尺度的运动将相应的隐藏层分开:大的运动来自低分辨率层，小的运动来自高分辨率层。在每一层，$ G_{m} $将当前特征映射为:1)以具有尺寸n的像素方式的2D核的形式计算运动(像素细化);2)识别运动遮罩中包含实际运动的区域；3)生成下一层的运动图。为了将运动与内容融合，仅当像素位于运动被激活的区域中时，我们才分别将生成的2D核与以相应像素为中心的面片进行卷积(即，执行空间自适应卷积)(参见上图)。 具体来说，假设我们把运动分成S个尺度。对于每个尺度的s，让$ l{s} $为相对应的分辨率隐藏层，$ w^{s} ∈ ℝ^{l{s}×l{s}×n^{2}} $为$ G{m} $产生的卷积核，$ h{c}^{s} ∈ ℝ^{l{s} × l{s} × d{s}} $为相对应的内容层，其中$ d{s} $是内容特征维度。我们在以下步骤中执行空间自适应卷积。首先，对于每个位置(a,b)，我们从展开形式$ w^{s}(a,b) $恢复一个2D卷积核$ K^{s}(a,b) $.然后，我们将$ K^{s}(a,b) $与在$ h{c}^{s} $的补丁$ P^{s}(a,b) ∈ ℝ^{n×n×d{s}} $做卷积运算来生成一个位置(a,b)中间内容表示 $ \\tilde{h}{c}^{s}(a,b) $: 我们通过向较小的层添加自适应卷积来处理较大的运动，而[29]则通过增加核大小来处理较大的运动。由于要存储和建模的参数数量在核大小中是平方的，因此在我们的多尺度融合框架中，我们通过对所有层利用小核(푛=3或5)来显著降低内存使用量和模型复杂度 为了$ G{m} $的注意力集中学习尺度s在实际发生的区域的运动上，我们预测了一个带有$ w^{s} $的运动遮罩$ M^{s} ∈ ℝ^{l{s}×l{s}} $，以识别这样的区域。每个$ M^{s} $的的值都在[0，1]中。我们在$ M^{s}(a,b) $:的指导下通过融合运动从$ h{c}^{s}(a,b) $和 $ \\tilde{h}{c}^{s}(a,b) $生成了新的内容$ \\hat{h}{c}^{s} $： Conclusion以上。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"视频生成","slug":"视频生成","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"},{"name":"GAN","slug":"GAN","permalink":"http://yoursite.com/tags/GAN/"}]},{"title":"论文速读：G3AN","slug":"论文速读：G3AN","date":"2020-12-24T03:53:37.000Z","updated":"2022-06-06T03:22:14.526Z","comments":true,"path":"2020/12/24/论文速读：G3AN/","link":"","permalink":"http://yoursite.com/2020/12/24/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AG3AN/","excerpt":"","text":"1. Introduction 原文地址：G3AN: Disentangling Appearance and Motion for Video Generation 在推断和建模人类视频的分布时，生成模型面临三个主要挑战:(a)生成不确定运动，(b)在整个生成的视频中保持人类外观，以及(c)建模时空一致性。 本文提出了一个新的被简化的生成模型G^{3}AN，以学习视频生成因子外观和运动的解纠结表示，允许对两者进行操作。解纠缠表示被定义为单个潜在单位对单个生成因素的变化敏感，而对其他因素的变化相对不变[4]。在这种情况下，我们的G3AN被赋予了一个 three-stream生成器架构，其中主流编码时空视频表示，由两个辅助流增强，表示独立的生成因子外观和运动。针对高级功能图的self-attention机制可确保令人满意的视频质量。 G^{3}AN因此能够通过遵循训练分布而不需要额外的输入来生成逼真的视频(应对挑战(a)和(c))，并且能够分离地操纵外观和运动，同时强调保持外观(挑战(b))。 本文的技术贡献包括以下内容： 一种新的生成模型G3AN，它试图从人类视频数据中学习生成外观和运动因素的解纠缠表示。这些表示允许对这两个因素进行单独操作。 一种新颖的three-stream生成器，它同时考虑了个体外观特征(空间流)、运动特征(时间流)和平滑生成的视频(主流)的学习 一种新的factorized spatio-temporal self-attention(F-SA)被认为是第一个应用于视频生成的self-attention模块，用于对全局时空表示进行建模，提高生成视频的质量。 广泛的定性和定量评估，证明了G3AN在一系列数据集上系统地、显著地优于最先进的基线。 2. Related Work虽然视频生成任务旨在生成真实的时间动态，但这些任务会随着条件作用的水平而变化。我们有基于与运动或外观相关的附加先验的视频生成，相反，视频生成仅遵循训练分布。我们注意到，从建模的角度来看，后者更具挑战性，因为缺少关于例如生成的视频的结构的附加输入。因此，迄今为止的大多数方法都包含某种条件作用。 Video generation from noise。从噪声中直接生成视频需要捕获数据集分布并对其建模。最接近本文工作的是MoCoGAN，它将每一帧的潜在表现分解为运动和内容，旨在控制这两个因素。然而，MoCoGAN和G^{3}AN之间有两个关键的区别。首先，MoCoGAN不是对每个视频只采样两个噪声矢量，而是采样一系列噪声矢量作为运动，一个固定的噪声作为内容。然而，为每一帧引入随机噪声来表示运动增加了学习难度，因为模型必须将这些噪声向量映射到生成的视频中的连续人体运动。因此，MoCoGAN逐渐忽略输入噪声，并倾向于产生类似的运动。 3.Approach在这项工作中，我们提出了G^{3}AN，一种新颖的GAN架构，旨在从两个噪声矢量z_{a} ∈ Z_{A}和z_{m}∈ Z_{M}(分别代表外观和运动)中以分离的方式生成视频。G^{3}AN由一个三流发生器G和一个双流鉴别器D组成，如下图所示。G的目标是生成能够同时调节外观和运动的视频，而D则分别在视频和帧中区分生成的样本和真实数据。 3.1 Generator我们在G^{3}模块的层次结构中设计G。具体来说，我们有N个层次，表示为G_{n=0...N-1}^{3}。第一个G^{3}模块G_{0}^{3}接受两个噪声矢量z_{a}和z_{m}作为输入。其余模块G_{n=1...N-1}^{3}，继承三个特征映射F_{S_{n-1}}、F_{V_{n-1}}和F_{T_{n-1}}，作为它们来自每个先前G_{n-1}^{3}模块的输入，如上图所示。 每个G^{3}模块由三个并行流组成:空间流G_{S_{n}}、时间流G_{T_{n}}以及视频流G_{V_{n}}。它们被设计成产生三种不同类型的特征。在上图中用蓝线表示的空间流将n = 0时的z_{a}和n &gt; 1时的F_{S_{n-1}}作为输入，并通过使用转置的2D卷积层对输入特征进行上采样来生成2D外观特征F_{S_{n}}。这些特征在空间维度上发展，并在所有时间实例中共享。用橙色线表示的时间流G_{T_{n}}接受n = 0的z_{m}和n &gt; 1的F_{T_{n-1}}作为输入，并试图通过用转置的1D卷积层对输入特征进行上采样来生成1D运动特征F_{T_{n}}。这些特征在时间维度上演化，并包含每个时间步长的全局信息。然后，用黑线表示的视频流G_{V_{n}}将n = 0的z_{a}、z_{m}和n &gt; 1的F_{V_{n-1}}的连接作为输入。它对时空一致性进行建模，并通过对输入要素进行上采样和因子化转置时空卷积来产生3D联合嵌入F_{V_{n}^{'}}。然后将F_{S_{n}}和F_{T_{n}}弹射到时空融合块，在此与F_{V_{n}^{'}}融合，产生F_{V_{n}}。最后，F_{S_{n}}、F_{T_{n}}和F_{V_{n}}作为下一个分层G_{n+1}^{3}的输入。 王等人在[40]中提出了Factorized transposed spatio-temporal convolution。它明确地将转置的3D卷积分解成两个独立且连续的运算，M个转置的1D时间卷积之后是2D独立的空间卷积，其被称为转置的(1+2)D卷积。这种分解在这两个操作之间带来了额外的非线性激活，并有助于优化。至关重要的是，分解转置的3D卷积产生了视频质量的显著提高 Spatio-temporal fusion是学习好解纠缠特征的关键，其输入是来自每个G^{3}模块卷积层的输出特征映射F_{S_{n}}、F_{T_{n}}以及F_{V_{n}^{'}}。融合包含三个步骤(见下图)。首先，分别对F_{T_{n}}和F_{S_{n}}进行空间和时间复制，以获得两个新的特征图F_{T_{n}}^{R}和F_{S_{n}}^{R}。两个新的特征图都具有与F_{V_{n}^{'}}相同的时空大小。接下来，通过位置相加将F_{T_{n}}^{R}和F_{V_{n}^{'}}合并，创建新的时空嵌入F_{V_{n}^{''}}。最后，将F_{S_{n}}^{R}与F_{V_{n}^{''}}通道相连接，获得最终的融合特征图F_{V_{n}}。该功能将F_{S_{n}}、F_{T_{n}}和F_{V_{n}}映射为以下G_{n+1}^{3}模块的输入。 Factorized spatio-temporal Self-Attention (F-SA)：在这里，我们结合了一个时空模拟模块，使G能够利用来自所有时空特征位置的线索，并对广泛分离的区域之间的关系进行建模。然而，计算3D时空特征地图中每个位置与所有其他位置之间的相关性在计算上非常昂贵，特别是如果它应用于G中的更高特征地图。因此，我们提出了一种新的因子化时空自我注意，即F-SA，如下图所示。它由一个时间上的模拟退火算法和一个空间上的模拟退火算法组成。这种因子分解减少了计算的复杂性，允许在更大的特征地图上应用因子分析 3.2 Discriminator为了提高视频和帧质量，类似于MoCoGAN，我们使用了一个双流鉴别器架构，包含一个视频流DV和一个图像流DI。在训练期间，数字视频接受完整的视频作为输入，而双标签从视频中随机抽取帧 4. Conclusion以上。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"视频生成","slug":"视频生成","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"},{"name":"GAN","slug":"GAN","permalink":"http://yoursite.com/tags/GAN/"}]},{"title":"论文速读：ImaGINator","slug":"论文速读：ImaGINator","date":"2020-12-23T13:56:29.000Z","updated":"2022-06-06T03:22:14.526Z","comments":true,"path":"2020/12/23/论文速读：ImaGINator/","link":"","permalink":"http://yoursite.com/2020/12/23/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AImaGINator/","excerpt":"","text":"1. Introduction本文提出了一个新的conditional GAN模型，即ImaGINator，在给定单个图像c_{a}、运动类c_{m}以及噪声z的条件下，生成视频序列，如下图所示。 原文地址：ImaGINator: Conditional Spatio-Temporal GAN for Video Generation ImaGINator的特性如下： 采用了一种新的时空融合机制，旨在通过增强G在低和高特征级别中使用空间信息来保持外观。通过向Decoder注入c_{a}，我们使G能够将重点放在生成单独的运动上。这是基于这样的假设，即视频可以在潜在空间以及多级时空特征空间中分解成外观和运动。虽然在每一层外观被保留，只有运动被改变。 一种新颖的转置(1+2)D卷积，将转置的三维卷积滤波器分解成独立的时间和空间分量。这带来了几个好处:(1)额外的非线性校正允许模型表示更复杂的函数，(2)它便于优化，因为转置(1+2)D卷积块比完全转置的3D卷积滤波器更容易优化，以及(3)它在视频质量和速度方面产生显著的增益 2. Related Work与之前文章中的MoCoGAN进行比较，MoCoGAN基于seq2seq架构，旨在将时空生成分为两步(将每个视频帧分解为不同潜在空间中的运动和外观)。然而，这种两步生成省略了在更高空间级别的时间一致性的建模，这通常不能保持原始外观。 与此不同，我们提出了一种单步架构，它在多级特征空间中分解运动和外观，用于图像到视频的生成。 3. NetWork Architecture我们的目标是生成给定外观信息(作为单个图像帧)和运动类别(例如，确定面部表情)的视频序列。我们在这里假设一个视频y可以分解为外观c_{a}(源自输入图像)和运动c_{m}(源自类别标签)，在此基础上我们继续生成视频。因此，我们将我们的任务表述为学习一个条件映射G: {z，c_{a}，c_{m}} → y，其中z ~ N(0，1)表示随机噪声。 3.1 Generator我们的Generator由一个图像编码器和一个视频解码器组成，见上图。Encoder提取各种层中的外观信息，从浅的精细层到深的粗糙层。它将输入图像c_{a}编码为一个潜在矢量p，然后通过连接p、c_{m}以及随机噪声z ~ N(0，1)，Decoder生成一个视频序列。 在我们的生成器B中，我们将使用从2个跳跃连接的FCN-8的想法扩展到4个跳跃连接，但不同之处在于，最初的跳跃连接用于融合预测，而我们的跳跃连接用于融合外观和运动时空特征。我们的跳过连接允许Decoder直接从Encoder访问低级特征，使Decoder能够在每个时间片重用外观特征，并专注于生成运动。 3.1.1 Spatio-temporal fusion.假设G有n个图层，且F_{i}^{H×W×C_{1}×T}是G第i层中有C_{1}个通道的的特征图，f_{i,t}^{H×W×C_{1}}，t ∈ {1, …, T}是F_{i}中第t帧的特征图，F_{n-i}^{H×W×C_{2}}是第n-i层的特征图。 如下图所示，我们设计Decoder和Encoder的每一层的输出具有相同的空间维度。我们提出了一种融合机制，在通道方向的维度上连接每个f_{i,t}和F_{n-i}串联成同一个通道尺寸，得到一个新的特征映射F_{i}^{' H×W×(C_{1}+C_{2})×T}，称为时空融合(Spatio-temporal fusion)。这里我们注意到，每个初始特征映射F_{i}呈现生成的视频中几个连续帧的时空特征。通过在不同的特征层次上直接时空融合F_{i}和 F_{n-i}，可以在生成的视频中很好地保留输入信息。 此外，我们将类别标签(构成一个one-hot向量)直接融合到解码器中，以便为每个层提供对标签的访问。为此，我们首先将热点向量投影到热点特征图上。然后，我们在解码器中将类别标签信息时空融合到不同的层中。我们最终的特征地图是大小为H × W × (C1+ C2+C_{category})× T 3.1.2 Transposed (1+2)D Convolution我们注意到，由于难以优化，在一步方法中使用的3D卷积通常会导致产生模糊的视频。然而，得益于空间和时间分解，帧可以在两步方法中单独生成。因此，为了将这种分解结合到一步方法中，我们设计了一个新的卷积层，集成了转置的(1+2)维卷积 我们建议明确地将转置的3D卷积滤波器分解为两个独立且连续的运算，M个转置的1D时间卷积滤波器之后是一个2D独立的空间分量，我们称之为转置的(1+2)D卷积，如下图所示。这种分解带来了几个好处。第一个好处与这两个操作之间的额外非线性校正有关，因此允许模型表示更复杂的函数。第二个潜在的好处是，分解有助于优化，因为具有分解的时间和空间分量的转置(1+2)D卷积块是比完全转置3D卷积滤波器更容易优化。此外，我们表明，分解转置的3D卷积滤波器在视频质量和速度方面都产生了显著的增益。 3.2 Two-stream Discriminator为了提高视频生成中的图像质量，我们设计了一个包含D_{V}和D_{I}的Two-stream Discriminator架构。虽然数字视频有五个3D卷积层，但数字视频只包含具有相同数字视频层数的2D卷积。D_{V}接受完整生成的视频作为输入，使用建议的时空融合来融合类别标签的“热点特征图”和第一层的输出，类似于G. D_{V}试图测量联合分布p(x_{real}, c_{m})和p(x_{fake}, c_{m})间的KL散度。我们分别从真实和生成的视频中随机抽取N帧作为输入。 4. Conclunsion以上。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"视频生成","slug":"视频生成","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"},{"name":"GAN","slug":"GAN","permalink":"http://yoursite.com/tags/GAN/"}]},{"title":"论文速读：MoCoGAN Decomposing Motion and Content for Video","slug":"论文速读：MoCoGAN Decomposing Motion and Content for Video","date":"2020-12-21T13:26:14.000Z","updated":"2022-06-06T03:22:14.527Z","comments":true,"path":"2020/12/21/论文速读：MoCoGAN Decomposing Motion and Content for Video/","link":"","permalink":"http://yoursite.com/2020/12/21/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AMoCoGAN%20Decomposing%20Motion%20and%20Content%20for%20Video/","excerpt":"","text":"1. Introduction视频中的视觉信号可以分为内容和运动。内容指定视频中的对象，运动描述它们的动态。在此基础上，本文提出了基于运动和内容分解的生成性对抗网络(MoCoGAN)的视频生成框架。 代码地址：https://github.com/sergeytulyakov/mocogan. 1.1 Related Work 使用循环机制来生成视频片段中帧的运动嵌入（motion）。 使用卷积神经网络生成图像（content）。 1.2 Contribution 我们提出了一种新的用于无条件视频生成的GAN框架，将噪声向量（noise）映射到视频中。 我们展示了所提出的框架提供了一种在视频生成中控制内容和运动的方法，这是现有视频生成框架所缺乏的。 为了验证算法的有效性，我们在基准数据集上进行了大量的实验验证，并与目前最先进的视频生成算法VGAN和TGAN进行了定量和主观比较 2. MoCoGAN FrameworkMoCoGAN由四个子网络组成，即循环神经网络R_{M}、图像生成器G_{I}、图像鉴别器D_{I}和视频鉴别器D_{V} 使用高斯分布初始化Z_{C}对内容子空间建模，由于在剪辑的短视频中内容基本保持不变，所以我们使用相同的Z_{C}来生成不同帧。 视频中的运动由动作子空间Z_{M}建模。用于作为G_{I}输入的向量序列Z表示 其中z_{C} ∈ Z_{C}以及z_{M}^{(k)} ∈ Z_{M}都各有k个，因为Z_{M}中并不是所有的路径都对应于路径上合理的运动，我们需要学会生成有效的路径，通过循环神经网络对路径生成过程进行建模。 R_{M}即为一个循环神经网络，在每一个时间步k，都会输入一个服从高斯分布的\\epsilon^{(k)},以及输出一个z_{M}^{(k)}。假设R_{M}(k)为时刻k的输出，则z_{M}^{(k)} = R_{M}(k)。本论文中，使用GRU作为R_{M}的实现。 G_{I}将向量序列Z映射为向量序列\\tilde{v}，其中\\tilde{v} = [\\tilde{x}^(1), …, \\tilde{x}^(k)] D_{I}和D_{V}分别用于鉴别单个图像和视频序列。D_{V}获取固定长度的视频片段，例如T帧，T为一个超参数，论文中设为16。T可以小于所生成的视频长度K。长度为K的视频可以以滑动窗口的方式被分成K-T+1个片段，并且每个片段都可以被馈送到D_{V}中。 D_{V}也用来评估所生成的动作。因为G_{I}没有运动的概念，因此对于运动的损失将会直接指向循环神经网络R_{M}。为了骗过D_{V}，生成具有较为真实动作的视频，R_{M}必须学会将输入\\epsilon^{(k)}映射为动作系列Z 3. Categorical Dynamics视频中的动态通常是绝对的(例如，离散的动作类别：行走、跑步、跳跃等)。为了对这个分类信号建模，我们用一个分类随机变量Z_{A}来增加RM的输入，其中每个实现都是一个one-hot向量。我们保持其不变，因为短视频中动作类别保持不变，因此R_{M}的输入如下图所示。 4. Conclusion以上。","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"视频生成","slug":"视频生成","permalink":"http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"},{"name":"GAN","slug":"GAN","permalink":"http://yoursite.com/tags/GAN/"}]},{"title":"LaTex公式总结","slug":"LaTex公式总结","date":"2020-12-21T13:18:10.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2020/12/21/LaTex公式总结/","link":"","permalink":"http://yoursite.com/2020/12/21/LaTex%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"本文转载自简书 Markdown中的LaTeX格式大部分情况下，我对于latex的数学公式都是内嵌于Markdown文本编辑器中的，分为两种形式 行内公式排版： 1$ c = \\sqrt&#123;a^&#123;2&#125;+b_&#123;0&#125;^&#123;2&#125;+e^&#123;x&#125;&#125; $ 块公式排版： 1$$ c = \\sqrt&#123;a^&#123;2&#125;+b_&#123;0&#125;^&#123;2&#125; +e^&#123;x&#125;&#125; $$ LaTex的数学公式基本规则 转义 以下几个字符: # $ % &amp; ~ _ ^ \\ { }有特殊意义，需要表示这些字符时，需要转义，即在每个字符前加上\\（转义字符的具体含义下面会解释） &gt; 不知为何简书不支持~的表示，需要时写作\\sim \\boxed命令给公式加一个方框。\\fbox具有类似功能 \\mathbf将字体加粗 \\boldsymbol将字体斜体且加粗 12345$E = mc^2 $$ \\boxed&#123;E=mc^2&#125; $$\\fbox&#123;E=mc^2&#125;$$\\mathbf&#123;E = mc^2&#125;$$\\boldsymbol&#123;E = mc^2&#125;$ 希腊字母与特殊字符 上下标及常用符号 用^来表示上标 用_来表示下标 根号用\\sqrt表示 注意：这些有特殊含义的表示中（不限于这三种内容），如果超过一个字符或符号，需要用{}括起来。 对角标的使用中，如果角标位置看起来不明显时，可以强制改变角标大小或层次，如下所示： 1$y_N, y_&#123;_N&#125;,$ 显示为： 第一种输出为正常输出，但输出效果不明显；第二种是将一级角标改为二级角标，字体也自动变为二级角标字体 当需要在左右两边都有上下标，可以用 \\sideset 命令 1$$ \\sideset&#123;^1_2&#125;&#123;^3_4&#125;\\bigotimes $$ \\sqrt[开方次数，默认为2]{开方公式}， 例如： 1$$ x_&#123;k&#125;^2\\quad \\sqrt&#123;x&#125;\\quad \\sqrt[3]&#123;x+y&#125; $$ 公式中插入文本\\text{}或\\mbox{}，建议使用前者，它对于latex内置的\\mbox{}的优势在于它可以根据当前位置自动调整文本样式（尤其是大小），而\\mbox采用统一的正文样式。这一点在你的文本被用作上下标的时候非常重要。 %7D) 公式中插入空格，间隔效果如下表： 若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令 1$A\\large A \\small A$ 省略号\\dots, \\cdots,\\vdots \\ddots表示，\\cdot常表示点乘，\\vots是竖直方向的，\\ddots是斜线方向的 1$$ x_1, x_2, \\dots, x_n\\quad 1,2,\\cdots,n\\quad \\vdots\\quad \\ddots $$ 关系符如下表所示 其他常用符号 分数与组合数 分数用\\frac{分子}{分母}表示，\\cfrac用于连分数表示(这样相较于\\frac不会产生字体自动缩小的问题) 1234$x = a _ 0 + \\cfrac &#123;1&#125; &#123;a _ 1 + \\cfrac &#123;1&#125; &#123;a _ 2 + \\cfrac &#123;1&#125; &#123;a _ 3 + \\cfrac &#123;1&#125; &#123;a _ 4&#125; &#125; &#125; &#125; $ 字号工具环境设置： \\dfrac命令把字号设置为独立公式中的大小； \\tfrac则把字号设置为行间公式中的大小。 1$ \\frac&#123;1&#125;&#123;2&#125; \\dfrac&#123;1&#125;&#123;2&#125; $ 1$$ \\frac&#123;1&#125;&#123;2&#125; \\tfrac&#123;1&#125;&#123;2&#125; $$ 组合数用法与分数类似，在命令前加d和t也能达到分数字号设置同样的功能 \\binom{233}{x^2} 运算符 基本加减乘除等于 +-*/= 可以直接输入 特殊运算则用以下特殊命令\\pm; \\times; \\div; \\cdot; \\cap; \\cup; \\geq; \\leq; \\neq; \\approx; \\equiv 在此之上，如果想要使用堆积符号有以下三种形式 \\stackrel{上位符号}{基位符号} 基位符号大，上位符号小 {上位公式\\atop 下位公式} 上下符号一样大 {上位公式\\choose 下位公式} 上下符号一样大；上下符号被包括在圆弧内 和、积、极限、积分等运算符用\\sum, \\prod, \\lim, \\int,这些公式在行内公式被压缩，以适应行高，可以通过\\limits和\\nolimits命令其是否压缩。 123456789101112$ \\sum_&#123;i=1&#125;^n i $$ \\prod_&#123;i=1&#125;^n i$$\\lim_&#123;x\\to0&#125;x^2 $$\\int_&#123;a&#125;^&#123;b&#125;x^2 dx $$\\sum\\nolimits_&#123;i=1&#125;^n i \\quad\\prod\\nolimits_&#123;i=1&#125;^n i\\quad\\lim\\nolimits_&#123;x\\to0&#125;x^2 \\quad\\int\\limits_&#123;a&#125;^&#123;b&#125;x^2 dx $ 积分及箭头 积分符号使用如下形式：\\int、\\iint、\\iiint、\\iiiint、\\idotsint 1234$$ \\int \\int \\quad \\int \\int \\int \\quad \\int \\int \\int \\int \\quad \\int \\dots（表示...） \\int $$$$ \\iint \\quad \\iiint \\quad \\iiiint \\quad \\idotsint $$ 箭头的种类过于繁多，这里不就一一列举了，但是箭头符号的名字很有规律，一般命名规则为方向+箭头种类： 代码 显示 \\leftarrow 或 \\gets \\rightarrow 或 \\to \\uparrow \\downarrow 四个基本方向上下左右不多说，斜着的箭头的方向部分为\\ne \\se \\nw \\sw，为东北、东南、西北、西南简写 示例：\\nearrow 还有左右、上下两个方向的箭头： \\leftrightarrow \\updownarrow 上面的箭头只有一根线，可以通过大写第一个字母变成双线： \\Leftrightarrow \\Uparrow 在前面加上long可以把箭头变长，仅适用于左右箭头，注意双线箭头大写字母的位置： \\longleftarrow \\longleftrightarrow \\Longleftrightarrow 或 \\iff 还有只有一边的箭头，名字为harpoon+up/down，表示那一边的位置，这种箭头似乎不支持上面的buff buffbuff，但拥有左右双向箭头： \\leftharpoonup \\rightleftharpoons 意图在箭头上下位置添加说明时，有以下两种方式 12345678910111213141516171.\\xleftarrow和\\xrightarrow可根据内容自动调整（上下都可以添加内容）2.\\overset&#123;&#125;&#123;\\rightarrow&#125;则是长度固定的箭头，适合单个字符，内容在上 \\overrightarrow&#123;&#125;则是长度变化的箭头，适合多个字符，箭头在上注意2中的都只适用于只在箭头上或下添加内容，改变位置将over改为under$\\xleftarrow[x+y+z]&#123;x+y+z+1&#125;$$\\xrightarrow[x+y+z+1]&#123;x+y+z&#125;$$\\overset&#123;x+y+z&#125;&#123;\\rightarrow&#125;$ $\\underrightarrow&#123;x+y+z&#125;$$\\underset&#123;x+y+z&#125;&#123;\\leftarrow&#125;$ $\\overleftarrow&#123;x+y+z&#125;$ 注音和标注 123字母上方横线\\overline&#123;&#125;, \\bar&#123;&#125;$ \\bar&#123;x&#125; $ 单个字符 $\\overline&#123;xyz&#125;$ 多个字符 12字母下方横线\\underline&#123;&#125;$\\underline&#123;xyz&#125;$ 123\\overbrace 和\\underbrace 在表达式的上、下方给出一水平的大括号$\\overbrace&#123;a\\dots a&#125;^&#123;n个&#125;$ $\\underbrace&#123;a\\dots a&#125;_&#123;n个&#125;$ 1234向量表示有两种，单个字母用\\vec&#123;x&#125;，多个字母用\\overrightarrow 和\\overleftarrow$ \\vec&#123;x&#125;$$\\overrightarrow&#123;AB&#125;$$\\overleftarrow&#123;ABC&#125;$ 123字母上方波浪线\\tilde&#123;&#125;, \\widetilde&#123;&#125;$ \\tilde&#123;x&#125;$$ \\widetilde&#123;xyz&#125;$ 1$ \\dot&#123;x&#125;$ 12$ \\hat&#123;x&#125;$ $ \\widehat&#123;xyz&#125;$ 1$ \\acute&#123;x&#125;$ 1$ \\grave&#123;x&#125; $ 1$ \\mathring&#123;x&#125;$ 1$ \\ddot&#123;x&#125;$ 1$ \\check&#123;x&#125; $ 1$ \\breve&#123;x&#125;$ 1$ \\dddot&#123;x&#125; $ 编号 插入编号： 使用\\tag指令指定公式的具体编号，并使用\\label指令埋下锚点。如y=x^2 \\tag{1.5a} 引用编号： 在markdown中不支持编号的锚点设置 \\label与\\ref 的使用 括号及嵌套 常用括号有以下几种 括号的大小调整 对括号的大小，手动模式可以用\\big, \\Big, \\bigg, \\Bigg等一系列命令(从小到大，默认是最小)放在上述括号前面调整大小。 12$\\Bigg( \\bigg( \\Big( \\big((x) \\big) \\Big) \\bigg) \\Bigg)$$\\Bigg\\&#123; \\bigg\\&#123; \\Big\\&#123; \\big\\&#123;\\&#123;x\\&#125; \\big\\&#125; \\Big\\&#125; \\bigg\\&#125; \\Bigg\\&#125;$ %20%5Cbig)%20%5CBig)%20%5Cbigg)%20%5CBigg)%5Cquad%20%5CBigg%5C%7B%20%5Cbigg%5C%7B%20%5CBig%5C%7B%20%5Cbig%5C%7B%5C%7Bx%5C%7D%20%5Cbig%5C%7D%20%5CBig%5C%7D%20%5Cbigg%5C%7D%20%5CBigg%5C%7D) 自动模式下要用 \\left 和 \\right 命令后面跟上所需分隔符，用来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 等分隔符 1$$ f(x,y,z) = 3y^2z \\left( 3+\\frac&#123;7x+5&#125;&#123;1+y^2&#125; \\right) $$ %20%3D%203y%5E2z%20%5Cleft(%203%2B%5Cfrac%7B7x%2B5%7D%7B1%2By%5E2%7D%20%5Cright)) 123456789101112131415$$f\\left( \\left[ \\frac&#123; 1+\\left\\&#123;x,y\\right\\&#125; &#125;&#123; \\left( \\frac&#123;x&#125;&#123;y&#125;+\\frac&#123;y&#125;&#123;x&#125; \\right) \\left(u+1\\right) &#125;+a \\right]^&#123;3/2&#125;\\right)\\tag&#123;1.2&#125;$$ %20%5Cleft(u%2B1%5Cright)%20%7D%2Ba%20%5Cright%5D%5E%7B3%2F2%7D%20%5Cright)%20%5Ctag%7B%E8%A1%8C%E6%A0%87%7D) 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个”影子”括号： 123456$$\\begin&#123;aligned&#125;a=&amp;\\left(1+2+3+ \\cdots \\right. \\\\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end&#123;aligned&#125;$$ %20%5Cend%7Baligned%7D) 而如果分隔符不在左右而在中间，为了能够格式对齐，要用\\middle加分隔符表示 1$P=\\left(A=2\\middle|\\frac&#123;A^2&#125;&#123;B&#125;&gt;4\\right)$ ) 颜色设置 原文照排 LATEX 提供了 \\verb 命令(一般用于在正文中插入较短的命令)来实现 1$\\verb|x^2|\\quad x^2$ 删除线 在公式内使用 \\require{cancel} 来允许 片段删除线 的显示。 声明片段删除线后，使用 \\cancel{字符}、\\bcancel{字符}、\\xcancel{字符} 和 \\cancelto{字符} 来实现各种片段删除线效果。 12345678\\require&#123;cancel&#125;\\begin&#123;array&#125;&#123;rl&#125;\\verb|y+\\cancel&#123;x&#125;| &amp; y+\\cancel&#123;x&#125;\\\\\\verb|\\cancel&#123;y+x&#125;| &amp; \\cancel&#123;y+x&#125;\\\\\\verb|y+\\bcancel&#123;x&#125;| &amp; y+\\bcancel&#123;x&#125;\\\\\\verb|y+\\xcancel&#123;x&#125;| &amp; y+\\xcancel&#123;x&#125;\\\\\\verb|y+\\cancelto&#123;0&#125;&#123;x&#125;| &amp; y+\\cancelto&#123;0&#125;&#123;x&#125;\\\\\\verb+\\frac&#123;1\\cancel9&#125;&#123;\\cancel95&#125; = \\frac15+&amp; \\frac&#123;1\\cancel9&#125;&#123;\\cancel95&#125; = \\frac15 \\\\\\end&#123;array&#125; 数学公式高级规则 公式环境与对齐 在下文的公式环境中，形如 equation中， 带号的不将公式标号排出来, 而不带*的自动给每行式子编排标号 latex的公式环境有很多种，这里只列举我常用的，更多请查阅latex官方说明 单行公式环境 equation \\begin{equation} … \\end{equation} 是最一般的公式环境，表示一个公式，默认情况下之表示一个单行的公式，但是它的功能可以通过内嵌各种其他环境进行扩展，不可以使用\\与&amp;功能。它可以内嵌的一些关于对齐的环境将在后面介绍。 123$\\begin&#123;equation&#125;f(x)=3x^&#123;2&#125;+6(x-2)-1\\end&#123;equation&#125;$ %3D3x%5E%7B2%7D%2B6(x-2)-1%20%5Cend%7Bequation%7D) align（多个公式） 这是最基本的对齐环境，其他多公式环境都不同程度地依赖它。它采用“&amp;”分割各个对齐单元，使用“\\”换行。它的每行是一个公式，都会独立编号。在排版过程中，它将&amp;分出来的列又分成组，组间特定方式排版，具体方式在flalign环境中讨论。 通常情况下在公式中可以通过\\tag设置标号，\\label设置引用名称，但好像简书的markdown不支持\\label，所以编号的意义就无所谓了。 1234$\\begin&#123;align&#125; f(x) &amp;= (x+a)(x+b) \\\\ &amp;= x^2 + (a+b)x + ab \\tag&#123;1.1&#125;\\end&#123;align&#125;$ %20%26%3D%20(x%2Ba)(x%2Bb)%20%5C%5C%20%26%3D%20x%5E2%20%2B%20(a%2Bb)x%20%2B%20ab%20%5Ctag%7B1.1%7D%20%5Cend%7Balign%7D) 1234$\\begin&#123;align&#125;A_&#123;1&#125;&amp;=B_&#123;1&#125;B_&#123;2&#125; &amp; A_&#123;3&#125; &amp; = B_&#123;1&#125;\\\\A_&#123;2&#125;&amp;=B_&#123;3&#125;&amp; A_&#123;3&#125;A_&#123;4&#125; &amp; = B_&#123;4&#125;\\end&#123;align&#125;$ 公式组环境flalign与align的功能基本相同，唯一区别是列对之间的距离为弹性宽度，以使公式组两端对齐。然而简书不支持。。。 gather环境 它是最简单的多行公式环境，自己不提供任何对齐。其中的各行公式按照全局方式分别对齐。 在设置了全局左对齐之后，因为不存在内部各个公式之间对排版的干扰，这种环境非常适合写数学推导或者证明。而默认情况下，是居中对齐。 123456\\begin&#123;gather*&#125;E(X)=\\lambda \\qquad D(X)=\\lambda \\\\E(\\bar&#123;X&#125;)=\\lambda \\\\D(\\bar&#123;X&#125;)=\\frac&#123;\\lambda&#125;&#123;n&#125; \\\\E(S^2)=\\frac&#123;n-1&#125;&#123;n&#125;\\lambda \\\\\\end&#123;gather*&#125; %3D%5Clambda%20%5Cqquad%20D(X)%3D%5Clambda%20%5C%5C%20%5Ctherefore%20E(%5Cbar%7BX%7D)%3D%5Clambda%20%5C%5C%20D(%5Cbar%7BX%7D)%3D%5Cfrac%7B%5Clambda%7D%7Bn%7D%20%5C%5C%20E(S%5E2)%3D%5Cfrac%7Bn-1%7D%7Bn%7D%5Clambda%20%5C%5C%20%5Cend%7Bgather%7D) 与上文中公式组类似的，长公式也有两种multline和split两种环境，分别对应不对齐与对齐。 multline不支持“&amp;”分列。其首行左对齐，末行右对齐，其余各行分别按照全局方式对齐。 split也用于排版多行公式，但它与多行公式环境multline的区别主要是以下三点： 用&amp;作为分列符，但至多两列；左列右对齐，右列左对齐，形成一个列对，可使多行公式关于某个符号垂直对齐。因此用它排版的多行公式更为整齐美观。如果不用分列符&amp;,所有公式行为一列，且全都与首行公式的右端对齐。 必须置于除multline环境之外的其它公式环境中。 自身并不生成公式序号，而是由外在公式环境提供，序号垂直居中。 示例如下： 1234$$\\begin&#123;multline&#125;x=a+b+c+&#123;&#125; \\\\d+e+f+g\\end&#123;multline&#125;$$ 1234$$\\begin&#123;split&#125;x=&amp;a+b+c+&#123;&#125; \\\\&amp;d+e+f+g\\end&#123;split&#125;$$ /gathered，/aligned。以上几种方程组环境，无论每个公式多小，都会占满一行。而/gathered，/aligned环境，则只占据公式的实际宽度，整体作为一个特大的符号与其他符号一同处理。 这个结构还可以添加位置参数，以决定与其他符号的竖直对齐方式(b,t)。而且这种环境不再具有自动编号功能。 123456789$\\begin&#123;equation&#125; \\left.\\begin&#123;aligned&#125; B&#x27;&amp;=-\\partial \\times E,\\\\ E&#x27;&amp;=\\partial \\times B - 4\\pi j, \\end&#123;aligned&#125; \\right\\&#125; \\qquad \\text&#123;Maxwell&#x27;s equations&#125;\\end&#123;equation&#125;$ 12345678$\\begin&#123;equation&#125;\\left.\\begin&#123;aligned&#125;x+y &amp;&gt; 5 \\\\y-y &amp;&gt; 11\\end&#123;aligned&#125;\\ \\right\\&#125;\\Rightarrow x^2 - y^2 &gt; 55\\end&#123;equation&#125;$ cases环境常用于分段函数，上面的环境虽然支持分段函数形式的表达，但比较繁琐 1234567$$L(Y,f(X))=\\begin&#123;cases&#125;1,\\quad &amp;Y\\neq f(X)\\\\0,\\quad &amp;Y=f(X)\\end&#123;cases&#125;$$ )%3D%20%5Cbegin%7Bcases%7D%201%2C%5Cquad%20%26Y%5Cneq%20f(X)%5C%5C%200%2C%5Cquad%20%26Y%3Df(X)%20%5Cend%7Bcases%7D) 阵列环境 array可以帮助我们输入一个数组或表格 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，字母c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \\ 结尾，最后以 end{array} 结束数组。下面是几个示例： 123456789$\\begin&#123;array&#125;&#123;c|l|c|r&#125;n &amp; \\text&#123;左对齐&#125; &amp; \\text&#123;居中对齐&#125; &amp; \\text&#123;右对齐&#125; \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\\\hline2 &amp; -1 &amp; 189 &amp; -8 \\\\\\hline3 &amp; -20 &amp; 2000 &amp; 1+10i\\end&#123;array&#125;$ 12345$\\left(\\begin&#123;array&#125;&#123;ccc|c&#125; a11 &amp; a12 &amp; a13 &amp; b1 \\\\a21 &amp; a22 &amp; a23 &amp; b2 \\\\ a31 &amp; a32 &amp; a33 &amp; b3 \\\\ \\end&#123;array&#125;\\right)$ ) 123456789$$\\left\\&#123; \\begin&#123;array&#125;&#123;c&#125;a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end&#123;array&#125;\\right. $$ 矩阵 第一种方式：使用matrix、pmatrix、bmatrix、Bmatrix、vmatrix或者Vmatrix，smallmatrix 一个最基本的矩阵 1234$ \\begin&#123;matrix&#125;0 &amp; 1 \\\\1 &amp; 0 \\end&#123;matrix&#125; $ 可以看到矩阵中用 &amp; 分隔列，用 \\ 分隔行，在矩阵开始和结束部分\\begin和\\end+矩阵类型 下面给出这几种矩阵类型的图示 矩阵类型 矩阵图示 matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix smallmatrix ) 在此之上，如果我们需要对矩阵起始和结束部分的括号进行变化，可以使用诸如 12345678$\\left\\&#123;\\begin&#123;matrix&#125; x_1&amp; x_2\\\\ y_1&amp; y_2\\end&#123;matrix&#125;\\right.$ (此处.作为占位符表示不需要分隔符)$\\left.\\begin&#123;matrix&#125;x_1 &amp; x_2\\\\ y_1&amp; y_2\\end&#123;matrix&#125;\\right\\&#125;$ 第二种方式就是使用array环境，在左右端加上所需括号即可 输入带省略符号的矩阵 12345678$$ \\begin&#123;pmatrix&#125; 1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\ 1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\ \\end&#123;pmatrix&#125;$$ 交换图表 使用一行 \\require{AMScd} 语句来允许交换图表的显示。 声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\ 。 123456$\\require&#123;AMScd&#125;\\begin&#123;CD&#125; A @&gt;a&gt;&gt; B\\\\ @V b V V\\# @VV c V\\\\ C @&gt;&gt;d&gt; D\\end&#123;CD&#125;$ 其中，@&gt;&gt;&gt; 代表右箭头、@&lt;&lt;&lt; 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。 在 @&gt;&gt;&gt; 的 &gt;&gt;&gt; 之间任意插入文字即代表该箭头的注释文字。 12345$\\begin&#123;CD&#125; A @&gt;&gt;&gt; B @&gt;&#123;\\text&#123;very long label&#125;&#125;&gt;&gt; C \\\\ @. @AAA @| \\\\ D @= E @&lt;&lt;&lt; F\\end&#123;CD&#125;$ 以上内容大致上应该能把绝大多数数学公式优美的书写下来了，更多内容还需要自行查阅官方说明~~","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"http://yoursite.com/tags/LaTex/"}]},{"title":"目标检测之YOLO理解与总结","slug":"目标检测之YOLO理解与总结","date":"2020-11-25T05:31:04.000Z","updated":"2022-06-06T03:22:14.526Z","comments":true,"path":"2020/11/25/目标检测之YOLO理解与总结/","link":"","permalink":"http://yoursite.com/2020/11/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B9%8BYOLO%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.背景 我们知道，目标检测通常分为两个步骤： （1）生成bounding box（边界框）（2）对物体分类。因此目标检测算法也因此分为one-stage与two-stage两个算法系列。 顾名思义，two-stage算法就是把两个步骤分别进行，比如R-CNN方法使用region proposal来生成整张图像中可能包含待检测物体的potential bounding boxes，然后用分类器来评估这些boxes，接着通过post-processing来改善bounding boxes，消除重复的检测目标，并基于整个场景中的其他物体重新对boxes进行打分。整个流程执行下来很慢，而且因为这些环节都是分开训练的，检测性能很难进行优化。 作者提出的YOLO（you only look once）就是one-stage算法系列的代表。它将目标检测任务当做回归问题（regression problem）来处理，直接通过整张图片的所有像素得到 的坐标、box中包含物体的置信度和class probabilities。顾名思义，通过YOLO，每张图像只需要看一眼就能得出图像中都有哪些物体和这些物体的位置。 2.内容介绍本篇博客记录我对YOLO的学习，我会分别对YOLOV1，YOLOV2，YOLOV3的内容进行总结，并进行比较。 3.YOLO V13.1 流程 将一幅图像分成S×S个网格（grid cell），如果某个object的中心落在这个网格中，则这个网格就负责预测这个object 每个网格要预测B个bounding box，每个bounding box除了要预测位置之外，还要附带预测一个confidence(置信度)。每个网格还要预测C个类别的分数 比如将上图分为了7×7个网格，要识别的目标狗的中心点落在第5行，第2列的网格点，那么这个网格点就负责预测狗这个object For evaluating YOLO on PASACL VOC, we use S = 7, B = 2, PASCAL VOC has 20 labelled classes so C = 20. Our final prediction is a 7 × 7 × 30 tensor 以上为摘自原论文，在PASCAL VOC数据集上，我们通过YOLO，最终获得了7 × 7 × 30的特征矩阵，由上图可知，沿着深度方向我们发现有30个数值，因为B = 2，所以有2个bounding box，每个bounding box有4+1个数值，分别为目标的坐标信息(中心点位置和宽高)与confidence，最后20个为PASCAL VOC 20个类别的分数。所以总共是30 3.2 网络结构YOLO将图像resize到448×448作为神经网络的输入 。 YOLO检测网络包括24个卷积层和2个全连接层，YOLO网络借鉴了GoogLeNet分类网络结构。不同的是，YOLO未使用inception module，而是使用1x1卷积层（此处1x1卷积层的存在是为了跨通道信息整合）+3x3卷积层简单替代。、 3.3 损失函数YOLO V1的损失函数分为三个部分 计算损失过程中，用的都是误差平方和，但是对宽高处理，是先对其开根号处理，为什么这么做呢，看到一个很棒的解释。 从上图右侧所示，当预测边界框相对于真实边界框便宜相同的高度和宽度时，小目标改变的IoU与大目标不同。画出y - x和$ \\sqrt{y} $ - $ \\sqrt{x} $图，如左侧所示，我们会发现,y与x的差值一样时,小目标在纵坐标上的差值大于大目标 3.4 YOLO V1的不足之处 YOLO V1对小目标的预测效果不理想,因为在YOLO V1的每个grid cell只预测2个bounding box,而且这两个bounding box属于同个类别 当检测目标出现了新的尺寸时,检测效果会变差 主要的错误原因,都来自于定位不准确,因为不像Faster RCNN和SSD使用了anchor box的回归参数来调整位置 4.YOLO V24.1 对比YOLO V1作者在YOLO v1的基础上，借鉴了很多trick，比如Batch Normalization、High Resolution Classifier等，提出YOLO v2，让预测变得更准确（Better），更快速（Faster），下图为性能对比。 4.2 YOLO V2中的各种尝试1. Batch Normalization（批量归一化） 批量归一化有助于解决反向传播过程中出现的梯度消失和梯度爆炸问题，降低对一些超参数的敏感性，并且起到一定的正则化效果（YOLO2不再使用dropout），从而能够获得更好的收敛速度和收敛效果，加了BN层后mAP提高了2% 2.High Resolution Classifier（使用高分辨率图像微调分类模型） 目前先进的目标检测方法中，基本上都会先在ImageNet上进行预训练，而ImageNet的输入采用的是224×224，导致分辨率不够高，给检测带来困难。YOLO v1网络把分辨率直接提升到了448×448，但是直接切换分辨率，检测模型可能难以快速适应高分辨率，这也意味之原有的网络模型必须进行某种调整以适应新的分辨率输入。 所以YOLO v2增加了在ImageNet数据集上使用448×448输入来finetune分类网络这一中间过程（10 epochs），这可以使得模型在检测数据集（eg:COCO）上finetune之前已经适应高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约4%。 3.Convolutional With Anchor Boxes（使用先验框Anchor Box替换全连接层）在之前的YOLO v1中，直接采用全连接层来预测边界框，效果不好(之前分析中的定位效果较差)。作者借鉴了Faster R-CNN中使用RPN预测偏移量offsets和置信度confidences的思想，预测bounding box与Anchor框的偏移（offset）而不是直接预测bounding box的坐标。 首先作者去除了一个池化层，来使得输出的卷积特征图有更高的分辨率。 其次作者缩减了网络，把原本网络的输入448×448 缩减成416×416。因为YOLO v2模型下采样的总步长为32，对于416×416 大小的图片，最终得到的特征图大小为13×13，维度是奇数，这样特征图恰好只有一个中心位置。作者发现对于一些大物体，它们中心点往往落入图片中心位置，此时使用特征图的一个中心点而不是四个中心点去预测这些物体的边界框相对容易些。所以在YOLOv2设计中要保证输入对应的最终的特征图有奇数个位置 使用anchor boxes之后，mAP下降了0.3，但召回率提高了7%。这是因为YOLOv1只能预测98个边界框(7×7×2)，而YOLO v2使用anchor boxes之后可以预测上千个边界框（13×13×num_anchor）,召回率的提升使得模型拥有进一步的改进空间。 4.Dimension Clusters(使用聚类算法获取anchor box) 之前anchor boxes都是手工设定的(如Faster RCNN,作者没有给出具体获取anchor boxes的方法,只是根据经验所得)，网络微调anchor boxes到实际位置的难度不小。而YOLO v2的做法是对训练集中标注的边框进行聚类分析，以自动找到更好的尺寸。 聚类算法最重要的是选择如何计算两个边框之间的“距离”，对于常用的欧式距离，大边框会产生更大的误差，但我们关心的是anchor boxes和ground truth的IOU。所以，YOLO2在聚类时巧妙地采用以下公式来计算两个边框之间的距离： d(box, centroid) = 1 - IoU(box, centroid) centroid是聚类时被选作中心的边框，box就是其它anchor boxes。IOU越大，距离越近。YOLO2给出的聚类分析结果如下图所示： 随着聚类中心数目的增加，我们可以看到平均IOU值是增加的，但是综合考虑模型复杂度和召回率，作者最终选取5个聚类中心作为先验框，其相对于图片的大小如右边图所示。 5.Direct location prediction(直接位置预测) 作者发现使用anchor boxes的时候模型不稳定，尤其是在早期迭代的时候。而大部分的不稳定现象出现在预测box的(x, y)坐标上了，而以往计算的公式如下（图中的两个减号应是加号，作者写错）： 这个公式没有任何限制，使得无论在什么位置进行预测，任何anchor boxes可以在图像中任意一点结束（这是因为偏移量tx, ty没有大小限制，可能会导致出现anchor偏离ground truth很远的情况。正确做法应该是每一个anchor只负责检测周围正负一个单位以内的目标box）。YOLO v2调整了预测公式，将预测边框的中心约束在网格内: 其中，bx, by, bw, bh是预测边框的中心和宽高。Pr(object) * IoU(b, object) = σ(to) 是预测边框的置信度，YOLO v1是直接预测置信度的值，这里对预测参数to进行σ变换后作为置信度的值。cx, cy是当前网格左上角到图像左上角的距离，要先将网格大小归一化，即令一个网格的宽=1，高=1。$ p^w $, $ p^h $ 是先验框的宽和高。 σ是sigmoid函数。tx, ty, tw, th, to是要学习的参数，分别用于预测边框的中心和宽高，以及置信度。 作者使用Dimension Clusters和Direct location prediction这两项anchor boxes改进方法，mAP获得了5%的提升。 6.Fine-Grained Features（细粒度特征） 作者发现YOLO使用13×13的特征图进行预测大物体拥有很好的效果，而相对比较小的物体则效果一般。YOLO v2引入一种称为passthrough层的方法在特征图中保留一些细节信息。 YOLO v2所利用的Fine-Grained Features是26×26大小的特征图（最后一个maxpooling层的输入）。passthrough层与ResNet网络的identity mappings类似，以前面更高分辨率的特征图为输入，然后将其连接到后面的低分辨率特征图上。前面的特征图维度是后面的特征图的2倍，passthrough层抽取前面层的每个2×2，然后将其转化为channel的维度，对于26×26×512的特征图，经passthrough层处理之后就变成了 13×13×256的新特征图（特征图大小降低4倍，而channles增加4倍），这样就可以与后面的13×13×256 特征图连接在一起形成13×13×1280大小的特征图。 7.Multi-Scale Training（多尺寸训练） 因为Yolo v2去掉了全连接层，只有卷积层与池化层，所以对于网络的输入大小，并没有限制，整个网络的降采样倍数为32，只要输入的特征图尺寸为32的倍数即可。所以Yolo v2可以使用不同尺寸的输入图片训练，来使模型适应不同分辨率的图片，让模型更鲁棒。 具体来说就是在训练过程中每间隔一定的iterations（论文中是10）之后改变模型的输入图片大小。由于YOLOv2的下采样总步长为32，输入图片大小选择一系列为32倍数的值：{320, 352, ……, 608}，输入图片最小为320×320，此时对应的特征图大小为10×10（和Convolutional With Anchor Boxes中提到要是奇数相悖，但是问题也不是很大），而输入图片最大为608×608，对应的特征图大小为19×19。在训练过程，每隔10个iterations随机选择一种输入图片大小，然后只需要修改对最后检测层的处理就可以重新训练。 在小尺寸图片检测中，YOLO v2效果很好，输入为228×228的时候，帧率达到91FPS，mAP几乎和Faster R-CNN的水准相同。在大尺寸图片检测中，YOLO v2也达到了先进水平，在VOC2007数据集上mAP为78.6%，仍然高于平均水准，下图是YOLO v2和其他网络的效果对比： 8.BackBone: Darknet-19 YOLOv2采用了一个新的网络，称为Darknet-19，包括19个卷积层和5个maxpooling层，在ImageNet数据集上，Darknet-19的top-1准确度为72.9%，top-5准确度为91.2%，但是模型参数相对小一些。使用Darknet-19之后，YOLOv2的mAP值没有显著提升，但是计算量却可以减少约33%。 4.3 网络结构 4.4 关于网络的训练细节 We use a weight decay of 0.0005 and momentum of 0.9. We use a weight decay of 0.0005 and momentum of 0.9.We use a similar data augmentation to YOLO and SSD withrandom crops, color shifting, etC. We use the same trainingstrategy on COCO and VOC. 这是论文给出的原话,至于如何匹配正负样本,如何计算误差等细节并没有多讲,我将会在YOLO V3部分具体分析。 5.YOLO V35.1 网络结构改进1. BackBone: Darknet-53 作者对YOLO v2时期的Darknet-19进行了升级,借鉴了ResNet的残差单元，在加深网络层数提高精度的同时大大降低计算量，接下来我们来具体剖析，先上backbone的结构图： 我们可以看到在Darknet-53中)，与Darknet-19最大的不同是没有池化层和全连接层,张量是通过卷积层来实现下采样的。比如stride=(2, 2)，这就等于将图像边长缩小了一半，整个特征图缩小$ 2^2 $ 倍。在YOLO v3中，最终要经历5次缩小，会将特征图缩小到原输入尺寸的$ \\frac {1} {2^5} $ ，即$ \\frac {1} {32} $。输入为416×416 ，则输出为13×13(416/32 = 13) 。需要注意的是，最后三层Avgpool、Connected和 softmax layer是用于在 Imagenet数据集上作分类训练用的。当我们用 Darknet-53 层对图片提取特征时，是不会用到这三层的。 这个backbone的效果也非常好，比起同精度的ResNet-152速度也是它的两倍，具体见下图： 2.整体网络架构 5.2 目标边界框的预测YOLO V3的边界框预测与YOLO V2一样，如下图所示 将tx，ty传入sigmoid函数能够限制范围在0-1内，避免中心点超出网格 5.3 正负样本的匹配 YOLOv3 predicts an objectness score for each boundingbox using logistic regression. This should be 1 if the bound-ing box prior overlaps a ground truth object by more thanany other bounding box prior. If the bounding box prioris not the best but does overlap a ground truth object bymore than some threshold we ignore the prediction, follow-ing [17]. We use the threshold of .5. Unlike [17] our systemonly assigns one bounding box prior for each ground truthobject. If a bounding box prior is not assigned to a groundtruth object it incurs no loss for coordinate or class predic-tions, only objectness. 从原论文可知，YOLO V3会为每个ground truth分配一个正样本，也就是一张图片有几个ground truth，就会有几个正样本。对于每个ground truth，会将与它重叠最大，也就是IoU最大的bounding box作为正样本。对于IoU大于设定的阈值,但不是最大的bounding box，将会直接丢弃。如果 某个bounding box没有被分配为正样本，那么它没有定位损失，类别损失，仅仅有objectness loss(置信度的损失)。 5.4 损失函数的计算YOLO V3损失函数计算如下图所示 5.4.1 目标置信度损失 置信度损失用的是二值交叉熵损失(BCE)，其中o$ {i} $∈[0,1]，表示预测目标边界框与真实目标边界框的IoU，c为预测值，$ \\hat{C}{i} $为c通过Sigmoid函数得到的预测置信度，N为正负样本个数。 5.4.2 目标类别损失类别损失用的也是二值交叉熵损失(BCE)，其中O$ {ij} $∈{0, 1}，表示预测目标边界框i中是否存在第j类目标，C$ {ij} $为预测值，$ \\hat{C}{ij} $为C$ {ij} $通过Sigmoid函数得到的目标概率，N$ _{pos} $为正样本个数 5.4.3 目标定位损失 其中左下角的g就是右图中的b","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"目标检测","permalink":"http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"YOLO","slug":"YOLO","permalink":"http://yoursite.com/tags/YOLO/"}]},{"title":"目标检测mAP计算以及coco评价标准","slug":"目标检测mAP计算以及coco评价标准","date":"2020-11-24T03:39:05.000Z","updated":"2022-06-06T03:22:14.526Z","comments":true,"path":"2020/11/24/目标检测mAP计算以及coco评价标准/","link":"","permalink":"http://yoursite.com/2020/11/24/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BmAP%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8Acoco%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/","excerpt":"","text":"1.前言当我们使用目标检测数据集（如COCO）进行评估时，最后会得到一个评估列表，如下图 2.目标检测中常见指标2.1精确率与召回率下面先引入目标检测中常见的一些指标 TP(True Positive)：IoU &gt; 0.5的检测框数（同一GT只计算一次） FP(False Positive)：IoU &lt;= 0.5的检测框（或者是检测到同一个GT的多余检测框数量） FN(False Negative)：没有检测到的GT的数量 Precision(精确率)： TP / (TP + FP)模型预测的所有目标中，预测正确的比例 Recall(召回率)：TP / (TP + FN)所有真实目标中，模型预测正确的目标比例 精确率与召回率缺一不可，举例说明：当一张图片中有5个检测对象时，假如算法检测到了10个个目标（其中5个正确，5个错误），那么TP=5，FP=5，FN=0，精确率=0.5，召回率=1。假如算法检测到了3个目标（都正确），那么TP=3，FP=0，FN=2，精确率=1，召回率=0.6。由此可以说明，单一的精确率与召回率，无法完全衡量结果的好坏。 2.2 APAP定义为P-R曲线下的面积P-R曲线：Precision-Recall曲线 举例如下图 本图为目标检测中某个类别（比如检测猫）置信度取不同阈值得到的精确率与召回率绘制成的P-R曲线，其面积为： S = (0.14-0)×(0.28-0.14)×1.0+(0.42-0.28)×1.0+(0.57-0.42)×1.0+(0.71-0.57)×0.71=0.6694 因此AP=0.6694 2.3 mAPmAP即为各个类别计算的AP取均值，比如目标检测的目标有猫、狗、兔子，将三个类别求得的AP相加除以三即可。 3.COCO评价指标再回过来看上面那张图 IoU代表交并比，可以观察算法在定位方面的指标 area代表检测面积的大小，可以观察算法在检测大目标与小目标方面的指标 maxDets代表检测目标数，可以观察算法在对多目标检测方面的指标","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"目标检测","slug":"目标检测","permalink":"http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"评估指标","slug":"评估指标","permalink":"http://yoursite.com/tags/%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"}]},{"title":"kaggle实战：Dog Breed Identification","slug":"kaggle实战：Dog Breed Identification","date":"2020-11-11T13:26:20.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2020/11/11/kaggle实战：Dog Breed Identification/","link":"","permalink":"http://yoursite.com/2020/11/11/kaggle%E5%AE%9E%E6%88%98%EF%BC%9ADog%20Breed%20Identification/","excerpt":"","text":"前言本文将使用pytorch框架解决kaggle竞赛中犬种识别挑战的问题，该比赛的数据集为ImageNet数据集的子集，在本次挑战中，我们将尝试分类120种不同的犬种 竞赛网址：https://www.kaggle.com/c/dog-breed-identification数据集可在该网址获取 导入相关模块1234567891011import torchimport torch.nn as nnimport torch.optim as optimimport torchvisionimport torchvision.transforms as transformsimport torchvision.models as modelsimport osimport shutilimport timeimport pandas as pdimport random 设置随机数种子123random.seed(0)torch.manual_seed(0)torch.cuda.manual_seed(0) 整理数据集1234data_dir = &#x27;./dog-breed-identification&#x27; # 数据集目录label_file, train_dir, test_dir = &#x27;labels.csv&#x27;, &#x27;train&#x27;, &#x27;test&#x27; # data_dir中的文件夹、文件new_data_dir = &#x27;./train_valid_test&#x27; # 整理之后的数据存放的目录valid_ratio = 0.1 # 验证集所占比例 123456789101112131415161718192021222324252627282930313233343536def mkdir_if_not_exist(path): # 若目录path不存在，则创建目录 if not os.path.exists(os.path.join(*path)): os.makedirs(os.path.join(*path)) def reorg_dog_data(data_dir, label_file, train_dir, test_dir, new_data_dir, valid_ratio): # 读取训练数据标签 labels = pd.read_csv(os.path.join(data_dir, label_file)) id2label = &#123;Id: label for Id, label in labels.values&#125; # (key: value): (id: label) # 随机打乱训练数据 train_files = os.listdir(os.path.join(data_dir, train_dir)) random.shuffle(train_files) # 原训练集 valid_ds_size = int(len(train_files) * valid_ratio) # 验证集大小 for i, file in enumerate(train_files): img_id = file.split(&#x27;.&#x27;)[0] # file是形式为id.jpg的字符串 img_label = id2label[img_id] if i &lt; valid_ds_size: mkdir_if_not_exist([new_data_dir, &#x27;valid&#x27;, img_label]) shutil.copy(os.path.join(data_dir, train_dir, file), os.path.join(new_data_dir, &#x27;valid&#x27;, img_label)) else: mkdir_if_not_exist([new_data_dir, &#x27;train&#x27;, img_label]) shutil.copy(os.path.join(data_dir, train_dir, file), os.path.join(new_data_dir, &#x27;train&#x27;, img_label)) mkdir_if_not_exist([new_data_dir, &#x27;train_valid&#x27;, img_label]) shutil.copy(os.path.join(data_dir, train_dir, file), os.path.join(new_data_dir, &#x27;train_valid&#x27;, img_label)) # 测试集 mkdir_if_not_exist([new_data_dir, &#x27;test&#x27;, &#x27;unknown&#x27;]) for test_file in os.listdir(os.path.join(data_dir, test_dir)): shutil.copy(os.path.join(data_dir, test_dir, test_file), os.path.join(new_data_dir, &#x27;test&#x27;, &#x27;unknown&#x27;)) 1reorg_dog_data(data_dir, label_file, train_dir, test_dir, new_data_dir, valid_ratio) 图像增广1234567891011transform_train = transforms.Compose([ # 随机对图像裁剪出面积为原图像面积0.08~1倍、且高和宽之比在3/4~4/3的图像，再放缩为高和宽均为224像素的新图像 transforms.RandomResizedCrop(224, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0)), # 以0.5的概率随机水平翻转 transforms.RandomHorizontalFlip(), # 随机更改亮度、对比度和饱和度 transforms.ColorJitter(brightness=0.4, contrast=0.4, saturation=0.4), transforms.ToTensor(), # 对各个通道做标准化，(0.485, 0.456, 0.406)和(0.229, 0.224, 0.225)是在ImageNet上计算得的各通道均值与方差 transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) # ImageNet上的均值和方差]) 123456789# 在测试集上的图像增强只做确定性的操作transform_test = transforms.Compose([ transforms.Resize(256), # 将图像中央的高和宽均为224的正方形区域裁剪出来 transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) 数据集导入1234567891011121314train_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, &#x27;train&#x27;), transform=transform_train)valid_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, &#x27;valid&#x27;), transform=transform_test)train_valid_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, &#x27;train_valid&#x27;), transform=transform_train)test_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, &#x27;test&#x27;), transform=transform_test)batch_size = 128train_iter = torch.utils.data.DataLoader(train_ds, batch_size=batch_size, shuffle=True)valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size=batch_size, shuffle=True)train_valid_iter = torch.utils.data.DataLoader(train_valid_ds, batch_size=batch_size, shuffle=True)test_iter = torch.utils.data.DataLoader(test_ds, batch_size=batch_size, shuffle=False) 定义模型由于此竞赛使用了ImageNet数据集的子集，我们可以使用迁移学习的方法，使用在ImageNet完整数据集上预训练的模型来抽取图像特征。 此处我们使用预训练的ResNet-34模型，直接复用预训练模型在输出层的输入，即抽取的特征，然后我们重新定义输出层，本次我们仅对重定义的输出层的参数进行训练，而对于用于抽取特征的部分，我们保留预训练模型的参数。 12345678910111213def get_net(device): finetune_net = models.resnet34(pretrained=False) # 预训练的resnet34网络 finetune_net.load_state_dict(torch.load(&#x27;./dog-breed-identification/resnet34-333f7ec4.pth&#x27;)) for param in finetune_net.parameters(): # 冻结参数 param.requires_grad = False # 原finetune_net.fc是一个输入单元数为512，输出单元数为1000的全连接层 # 替换掉原finetune_net.fc，新finetuen_net.fc中的模型参数会记录梯度 finetune_net.fc = nn.Sequential( nn.Linear(in_features=512, out_features=256), nn.ReLU(), nn.Linear(in_features=256, out_features=120) # 120是输出类别数 ) return finetune_net 若将pretrained设为true，会自动下载预训练好的resnet34网络，但是速度较慢，且容易断，还没断点续传功能 resnet34-333f7ec4.pth可在网络中搜素下载 定义训练函数123456789101112131415def evaluate_loss_acc(data_iter, net, device): loss = nn.CrossEntropyLoss() is_training = net.training net.eval() l_sum, acc_sum, n = 0, 0, 0 with torch.no_grad(): for X, y in data_iter: X, y = X.to(device), y.to(device) y_hat = net(X) l = loss(y_hat, y) l_sum += l.item() * y.shape[0] acc_sum += (y_hat.argmax(dim=1) == y).sum().item() n += y.shape[0] net.train(is_training) return l_sum / n, acc_sum / n 1234567891011121314151617181920212223242526272829def train(net, train_iter, valid_iter, num_epochs, lr, wd, device, lr_period, lr_decay): loss = nn.CrossEntropyLoss() optimizer = optim.SGD(net.fc.parameters(), lr=lr, momentum=0.9, weight_decay=wd) net = net.to(device) for epoch in range(num_epochs): train_l_sum, n, start = 0.0, 0, time.time() if epoch &gt; 0 and epoch % lr_period == 0: # 每lr_period个epoch，学习率衰减一次 lr = lr * lr_decay for param_group in optimizer.param_groups: param_group[&#x27;lr&#x27;] = lr for X, y in train_iter: X, y = X.to(device), y.to(device) optimizer.zero_grad() y_hat = net(X) l = loss(y_hat, y) l.backward() optimizer.step() train_l_sum += l.item() * y.shape[0] n += y.shape[0] time_s = &quot;time %.2f sec&quot; % (time.time() - start) if valid_iter is not None: valid_loss, valid_acc = evaluate_loss_acc(valid_iter, net, device) epoch_s = (&quot;epoch %d, train loss %f, valid loss %f, valid acc %f, &quot; % (epoch + 1, train_l_sum / n, valid_loss, valid_acc)) else: epoch_s = (&quot;epoch %d, train loss %f, &quot; % (epoch + 1, train_l_sum / n)) print(epoch_s + time_s + &#x27;, lr &#x27; + str(lr)) 最终超参数选择12345num_epochs, lr_period, lr_decay = 20, 10, 0.1lr, wd = 0.03, 1e-4device = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)net = get_net(device)train(net, train_iter, valid_iter, num_epochs, lr, wd, device, lr_period, lr_decay) 训练12net = get_net(device)train(net, train_valid_iter, None, num_epochs, lr, wd, device, lr_period, lr_decay) 测试使用训练好的模型队测试数据进行预测，并写入submission.csv","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/tags/pytorch/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"kaggle","slug":"kaggle","permalink":"http://yoursite.com/tags/kaggle/"},{"name":"迁移学习","slug":"迁移学习","permalink":"http://yoursite.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"}]},{"title":"彻底解决git clone太慢的头疼问题","slug":"彻底解决git clone太慢的头疼问题","date":"2020-03-15T08:14:03.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2020/03/15/彻底解决git clone太慢的头疼问题/","link":"","permalink":"http://yoursite.com/2020/03/15/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3git%20clone%E5%A4%AA%E6%85%A2%E7%9A%84%E5%A4%B4%E7%96%BC%E9%97%AE%E9%A2%98/","excerpt":"","text":"这段时间我电脑git clone的速度一直比较慢，在网上搜了许多比较坑的经验贴，都没有解决。 最近由于经常需要用到git clone，我就又静下心在网上开始找解决方案，最后终于解决了 我解决的方法如下： 首先查找域名对应的ip地址，并修改hosts文件 12nslookup github.global.ssl.fastly.Netnslookup github.com 将下列内容加入 /etc/hosts文件中: 1231.13.97.245 github.global-ssl.fastly.net13.229.188.59 github.com 我不太懂计算机网络，但是我发现网络上许多类似教程中给的ip地址和我在终端获取到的是不一样的，这也是跟着许多教程走无效的原因，所以得自行获取 刷新DNS缓存 123sudo /etc/init.d/networking restart // linuxipconfig /flushdns // windowssudo dscacheutil -flushcache // macos 经过以上步骤，我的git clone速度从可怜的几kb到了十余MB","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"快速幂算法详解","slug":"快速幂算法详解","date":"2020-03-03T13:31:05.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2020/03/03/快速幂算法详解/","link":"","permalink":"http://yoursite.com/2020/03/03/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、问题如果有三个整数a，n，k，要让我们求出a^n的后k位，你会怎么求？ 也许有人可能会想到直接将a^n次求出，然后通过取余求出后k位 但显然，这样是不现实的，因为我们知道当这个数很大时，即使是long long型的变量也存放不下。 二、前置知识当我们解决问题之前，首先来看一下，我们需要了解的一些知识。 三、解决问题解决一个问题的最好方法，往往是从实例中应用，所以我们不妨假设a = 3, n = 45此外，如果计算机基础较好的读者很容易得到45 = (101101)2 于是，我们可以得到如下推导 我们可以发现，如果最后一步中每一项去掉*后面的乘数，则每一项的值都为后一项的平方 四、代码实现123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a, n, k; while(cin &gt;&gt; a &gt;&gt; n &gt;&gt; k) &#123; int mod = pow(10, k); int ans = 1; // 先定义最终结果为1 while (n) &#123; if (n &amp; 1) &#123; // 判断n的二进制最后一位是0还是1 ans = (ans * a) % mod; // 只有当二进制最后1位为1时，这一项底数才为a，否则为1 &#125; n &gt;&gt;= 1; // 二进制右移一位 a = (a * a) % mod; // 如之前推导，前一项为后一项平方 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"基于vue理解前端框架开发web应用","slug":"基于vue理解前端框架开发web应用","date":"2020-03-02T03:47:58.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2020/03/02/基于vue理解前端框架开发web应用/","link":"","permalink":"http://yoursite.com/2020/03/02/%E5%9F%BA%E4%BA%8Evue%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91web%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、我为什么写这篇博客？我已经入门前端开发大约有了3年时间，从最开始的静态页面编写，到后来的使用ajax开发动态页面，到现在的使用Vue、React、Angular等前端框架开发Web应用，我写过许许多多项目，虽然我的水平依然很一般，但是在不久的将来我可能会告别这段路，这可能会是我写的最后一篇前端有关的文章。 这篇文章的目的在于帮助只接触过普通的html+css+js开发网页，甚至是Javascript零基础的朋友对目前流行的前端框架如何开发Web应用有所了解。 在这篇文章中，我会以一个Vue开发基于网易云Api的音乐播放器应用为例，讲解Vue开发中的一些内容，因为我三大框架都有所使用，所以本篇文章讲解的大多数东西都是三大框架相同的地方。 本篇文章不是Vue的基础教程，可能略有涉及，但会用通俗的语言讲解。 二、初步的了解因为本篇教程不是讲解Vue，所以对Vue的一些信息不作赘述。 2.1 使用vue开发和我们上课时用的html+css+js开发前端有什么不同？首先理解一个概念，这也是目前市面上流行的大多数前端框架都有的概念——“组件“ 我们可以用我们软件工程里“模块”的概念来理解组件。什么是模块？我们可以理解为实现某一种功能的代码，重点是功能。同理，回想一下平时我们开发页面时，是否是将一整个页面，放在同一个html文件里，这样会导致整个文件非常庞大。但细想一下，我们可以把页面中不同的部分，封装成一个一个组件，比如导航栏，我封装成一个Nav组件，然后Nav组件中，可以有子组件（这个应该好理解吧）Search组件，也就是搜索组件。这样下来，整个页面被我们切割成了各个组件，当我们开发时，目录结构十分清晰，代码可读性也很好。 2.2 Vue开发的优势回想一下我们上课时开发的网页，或者你平时在使用大多数网站，是不是在同一个网站里，点击某个跳转按钮，比如说我点击了搜索按钮，他是不是跳转到了一个搜索页面，这个过程中浏览器重新加载了页面。 Vue开发出来的web应用，是一种单页应用，我们先不着急理解什么是单页应用，我先来讲讲在我们使用vue应用中，页面中到底发生了什么，我们得知道有个概念，组件的生命周期，因为本篇文章不是Vue教程，所以我就简单讲一下，比如每个人都有出生和死亡，组件也是，比如说当页面刚加载时，某些组件出现，这是这些组件的“诞生阶段”，当这些组件从页面中消失（比如点击关闭键关闭某个弹出框），这就是组件的“死亡阶段“，我们可以把这些阶段，简单理解为组件的生命周期的阶段，当然，组件的生命周期阶段不止“诞生”和“死亡”，就好比你的一生会有许多重要的阶段。说了那么多废话知识，我们再来理解下什么是单页应用。举例说明，当我们在Vue应用中点击导航栏的菜单切换页面时，页面中发生的事情时，原来的组件都被销毁了，而取而代之的是新的组件被创建了出来，而不像我们之前开发过程中，跳转到了另一个html文件。这样的好处是极大的增加了用户体验，因为用户并不用等待网页加载了，整个使用过程中会感觉十分流畅。 2.3 Vue的一些原理使用vue会让人感到身心愉悦,它同时具备angular和react的优点,轻量级,api简单,文档齐全,简单强大,麻雀虽小五脏俱全。按官方的话来说Vue是一套构建用户界面的渐进式框架。 那么,怎样理解什么是渐进式框架？在这之前,我们首先要理解什么是框架。在最初的前端开发中，为了完成某个功能,我们需要通过js在HTML页面中获得dom节点，随后获得dom节点中的文本内容或者在dom节点上添加事件,进行一系列的程序操作，但是,如果任务量很大的情况下，代码会随着业务的增加而变得臃肿和混乱,在现实的开发中,负责的逻辑和巨大的开发量，是原生js无法完成的。 这个时候,开发人员将js代码分为了三个板块,数据(Model),逻辑控制(*),视图(View),数据板块只负责数据部分,视图板块负责更改样式,逻辑控制负责联系视图板块和数据板块,这样子有很大的好处,当需求发生变动时,只需要修改对应的板块就好 这种开发模式，就是所谓的MV结构，我们现在了解的MVC，MVP，MVVM都是MV的衍生物，对比这几种框架模式，我们会总结出来一个本质的特点，那就是这些开发模式都是让视图和数据间不会发生直接联系．对比用原生JS获得dom的操作，你会发现原生dom流其实是将dom作为数据，从dom中获得Model，随后又更改dom来实现更新视图，视图和模型其实混在一起，所以代码自然混乱，不易维护。 三、项目解析首先，我先来带你看下项目大致的结构目录 我们大致看一下，各部分分别是干什么的 ├── build // 构建服务和 webpack 配置 ├── config // 项目不同环境的配置 ├── index.html // 项目入口文件 ├── package.json // 项目配置文件 ├── static // 放置静态资源 ├── src // 生产目录 │ ├── api // api请求 │ ├── assets // 公共的images, fonts， js资源 │ ├── components // 各种组件 │ ├── store // vuex状态管理 │ ├── App.vue // 主页面 │ ├── router // 路由配置 │ └── main.js // Webpack 预编译入口 本文主要以介绍src目录下的的目录为主 3.1 api这里我只进行简单的文字说明，具体的代码请自行阅读项目。 可以清楚的看到，api中有两个文件，config.js与index.js config.js可以理解为将api定义为常量，这样当我们调用api的时候，就不用繁琐的将一串url输入，而是调用对应的变量名。这样做不仅简便而且代码具有相当高的可读性 Index.js里存放着一个个调用api请求的函数，本项目使用npm上的axios进行http请求。如果对此没有基础，可以简单理解为本文件中的一个个函数通过config.js里的api常量，通过http请求获取到相应的数据。 3.2 assetsassets中存放了可以通用的一些资源，比如字体，图片（如网站logo，很多地方都会用到），还有一些util函数 3.3 componentsComponent即为组件，这个概念在前文已经说的很详细了，就不再过多赘述。 可以清楚的看到，里面放着各个板块相应的组件，其中common是可以用来通用的组件，即不同页面中相同的组件，放在common中便于重用。 3.4 router如果你有java开发后端的基础，那对router应该不会陌生 router（路由），其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容。Home按钮 =&gt; home 内容， about按钮 =&gt; about 内容，也可以说是一种映射. 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分。 这是我们访问home页面是，地址栏的url 可以看到，访问时的url，与html+css+js开发网页时有所不同，当我们使用html+css+js开发网页时，地址栏是localhost:3000/home.html这种形式(如果你用过jsp开发，那后面会是.jsp)，因为我们之前说过，当页面跳转时，它的本质是加载不同的html文件，而不是像vue这样，通过路由来控制不同的组件创建与销毁 3.5 store这应该是比较难的一块，涉及到数据管理框架，vue中使用vuex来进行数据管理，如果要细讲vuex，那可能会需要极大的篇幅。 这里我只会帮助你大致的理解，我们可以把这个store理解为vuex在浏览器中创建的一个数据仓库。 这样做的好处是什么？ 设想一下，如果我们的web应用，内容比较丰富的时候，许多地方可能会用到重复的数据，那如果没有数据管理，我们会需要在每一次需要数据的时候，都进行http请求获取数据（因为许多组件是不会互通的），这样一来，会大大增加性能开销 当我们使用vuex后，只需要将获取到可能会重用的数据存入vuex建立的store中，以便下次使用，而且在开发过程中，我们能够通过chrome的插件看到它的内容，也为开发带来许多便利。 总结以上为我对前端框架的一些理解，后续可能会有补充。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Node.js项目线上服务器部署与发布","slug":"Node-js项目线上服务器部署与发布","date":"2019-01-12T12:37:13.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2019/01/12/Node-js项目线上服务器部署与发布/","link":"","permalink":"http://yoursite.com/2019/01/12/Node-js%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%91%E5%B8%83/","excerpt":"","text":"ssh 配置公钥 和密钥 可以登录服务器不需要密码看是否已经存在公钥和密钥看用户文件夹下是否存在 ctrl +d 退出用户sudo rm -f xxx 删除一个文件 12//连接ssh ubuntu@ip地址 123// 先给root一个密码sudo passwd root// 然后切换到root su root 12345678910//在root下sudo adduser lizhihao增加一个用户//然后在root下给skl sudo 权限 gpasswd -a lizhihao sudo // sudo visudo 增加下面的lizhihao ctrl +X保存 之后shift+Y enter 退出 可以在root 下进入skl 用户 su skl或者 sudo su lizhihao 12//重启服务 sudo service ssh restart 12//生成公钥和私钥 ssh-keygen -t rsa -C &quot;lizhihao@qq.com&quot; 12//配置文件 修改默认端口sudo vi /etc/ssh/sshd_config 改过端口后 连接服务器会连不上出现 : ssh: connect to host ip地址 port 22: Connection refused 这时候就要虚入输入端口号了 ssh -p 8888 ubuntu@ip地址(8888是刚刚改过的端口) 123456789//更新sudo apt-get update//安装一些sudo apt-get install vim openssl build-essential libssl-dev wget curl git//找到github上的nvm https://github.com/creationix/nvm找到安装脚本 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 装完后若发现nvm 不是一个命令 在来一个命令窗口 安装好nvm 就可以安装nodejs了 nvm install v8.2.1 指定一下node版本nvm use v8.2.2 设置一下默认nvm alias default v8.2.1 设置成淘宝用一个nrm 包npm —registry=http://registry.npm.taobao.org install -g nrm nrm use taobao 安装一些包 npm i pm2 webpack gulp grunt-cli -g 查看全局安装过的包 npm list -g -depth 0 创建 app.js 如下 创建 sudo vi app.js12345678var http=require(&#x27;http&#x27;);var server=http.createServer(function (req,res) &#123; res.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/plain&#x27;&#125;) res.end(&#x27;Hello SKL\\n&#x27;);&#125;)server.listen(8081);console.log(&#x27;Server running at http://ip地址:8081&#x27;); 之后 node app.js就可以在浏览器中访问 127.0.0.1:8081 使用nginx 80端口 停止apache 服务 sudo service apache2 stop 12345移除Apache 2sudo update-rc.d -f apache2 removesudo apt-get remove apache2 12下载 nginx sudo apt-get install nginx 配置 cd /etc/nginx/ cd conf.d sudo vi lizhihao-cn-8081.conf写入123456789101112131415161718192021upstream blog&#123; server 127.0.0.1:8081;&#125;# NGINX Server Instance,PORT 80server &#123; listen 80; server_name ip地址; # Proxy to the Node instance location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125; &#125; 4.sudo nginx -t 测试是否成功 sudo nginx -s reload 重启 nginx 之后输入ip地址 就可以看到了 把8081 的服务都导向到Nginx的80端口 让 Nginx的版本信息在浏览器的头信息中不那么明显 123cd /etc/nginxsudo vi nginx.conf去掉下面配置文件前的# 保存 去掉然后 sudo service nginx reload MongoDB ubuntu16.04https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/ 1234567891011121314命令：xxxxsudo apt-get install -y mongodb-org其中这一步速度很慢，改成阿里云的连接cd /etc/apt/sources.list.dvi mongodb-org-3.4.list (注意看安装时的版本)改成：deb [ arch=amd64,arm64 ] http://mirrors.aliyun.com/mongodb/apt/ubuntu xenial/mongodb-org/3.6 multiverse命令：// 改过镜像后要upadte一下xxxxxxxxxx 12sudo service mongod start之后 mongo就启动了 123若遇到无法写入。加sudo mongodb 默认跑在27017 端口上 123//修改sudo vi /etc/mongod.confport 改成了19997 文件上传12scp ./test.html lizhihao@ip地址0:/home/lizhihao/testscp -P 8888 ant-mobile-recruit-app.tar lizhihao@ip地址:/home/lizhihao/ 打包 tar12345678910-c ： 打包-v ： 显示过程-f ： 指定打包后的文件名-x : 解打包-z：压缩为.tar.gz格式 1234567//压缩tar -cvf japan.tar japantar -zcvf japan.tar.gz japan//解压tar -xvf japan.tartar -zxvf japan.tar 配置可以让域名访问服务器1234567891011121314151617181920212223cd /etc/nginx/conf.dsudo mv lizhihao-cn-8081.conf www-lizhihao-cn-3000.conf修改配置文件upstream blog&#123; server 127.0.0.1:3000; &#125; # NGINX Server Instance,PORT 80 server &#123; listen 80; server_name www.lizhihao.cn; # Proxy to the Node instance location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125; &#125; // 重启nginxsudo nginx -s reload 配一下防火墙123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354sudo apt-get update &amp;&amp; sudo apt-get upgradesudo iptables -F //先清掉所有的规则sudo vi /etc/iptables.up.rules------------------------------------------ *filter# 允许所有建立起来的连接-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# 允许所有出去的流量-A OUTPUT -j ACCEPT-A INPUT -p tcp --dport 443 -j ACCEPT-A INPUT -p tcp --dport 80 -j ACCEPT# ping-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# allow ssh port login-A INPUT -p tcp -m state --state NEW --dport 8888 -j ACCEPT# MongoDB connection-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT# 3000端口-A INPUT -s 127.0.0.1 -p tcp --destination-port 3000 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 3000 -m state --state ESTABLISHED -j ACCEPT# 9093端口-A INPUT -s 127.0.0.1 -p tcp --destination-port 9093 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 9093 -m state --state ESTABLISHED -j ACCEPT# 记录被拒绝的请求-A INPUT -m limit --limit 5/min -j LOG --log-prefix &quot;iptables denied:&quot; --log-level 7# drop incoming sensitive connections-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP# reject all other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT -------------------------------------------sudo iptables-restore &lt;/etc/iptables.up.rules //载入规则sudo ufw status //查看防火墙状态sudo ufw enable //激活sudo vi /etc/network/if-up.d/iptables //让他开机自动启动·-----------------------------------#!/bin/shiptables-restore /etc/iptables.up.rulea-----------------------------------------------------sudo chmod +x /etc/network/if-up.d/iptables### 出现invalid host header的问题 123// react的话在config里面的webpackDevServer.config.js里面加一个disableHostCheck: true https配置123456789101112131415161718192021222324252627282930313233343536373839// 在腾讯云上申请证书(具体详见文档：https://cloud.tencent.com/document/product/400/4143)// 把证书下载下来上传到服务器// 修改配置文件upstream blog&#123; server 127.0.0.1:3000;&#125;# NGINX Server Instance,PORT 80server &#123; listen 80; server_name www.lizhihao.cn; # rewrite ^(.*) https://$host$1 permanent; return 301 https://www.lizhihao.cn$request_uri;&#125;server &#123; listen 443; server_name www.lizhihao.cn; #填写绑定证书的域名 ssl on; ssl_certificate /home/lizhihao/https-key/1_www.lizhihao.cn_bundle.crt; ssl_certificate_key /home/lizhihao/https-key/2_www.lizhihao.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #按照这个套件配置 ssl_prefer_server_ciphers on; # if($ssl_protocol = &quot;&quot;)&#123; # rewrite ^(.*) https://$host$1 permanent; # &#125;# Proxy to the Node instancelocation / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://blog; proxy_redirect off; &#125;&#125;测试nginx 重启nginx node 后端启动123nohup npm start &amp;https://segmentfault.com/q/1010000004455598lsof -i 查看端口","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"python之函数使用","slug":"python之函数使用","date":"2018-10-11T07:25:23.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2018/10/11/python之函数使用/","link":"","permalink":"http://yoursite.com/2018/10/11/python%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、Python自定义函数的简单使用与其他许多语言相似，函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 python中函数定义的规则，基本由以下几个步骤组成： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号() 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数 函数的第一行语句可以选择性地使用文档字符串（用于存放函数说明） return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。 语法示例： 1234def fn( parameters ): &#x27;&#x27;&#x27;函数_文档字符串&#x27;&#x27;&#x27; function_suite return [expression] 实例： 123456def sum(num1,num2): &quot;两数之和&quot; return num1+num2# 调用函数print(sum(1,2)) 输出结果： 13 二、函数的传值与传地址函数的传值与传地址从字面意思来看很好理解，传值就是传入一个参数的值，传址就是传入一个参数的地址，也就是内存的地址（相当于指针）。他们的区别是如果函数里面对传入的参数重新赋值，函数外的全局变量是否相应改变，用传值传入的参数是不会改变的，用传址传入就会发生改变。 我们来看一下下面的例子： 1234567891011121314def afferentValue(num): num = 2def afferentAddress(list): list.append(2)num = 1list = [1]# 执行函数afferentValue(num)afferentAddress(list)print(num)print(list) 输出结果： 121[1, 2] 从以上的实例看出，当将变量传入函数时，并在函数内部修改后，在函数作用域外打印传入函数的变量，Number类型的变量并没有修改成功，List类型的变量修改成功，这就是，传值与传地址的区别 python的传值和传址是根据传入参数的类型来选择的，传值的参数类型：数字，字符串，元组，传址的参数类型：列表，字典 三、函数的返回值与许多语言不同的是，Python的函数返回值可以有多个，当返回值为多个时，返回的结果为1个元组 示例： 1234def returnTest(num1, num2): return num1, num2print(returnTest(1, 2)) 输出结果： 1(1, 2) 四、函数的参数1、位置参数大部分情况下我们使用的都是位置参数，例子如下： 1234def userInfo(name, age, sex): print(&#x27;姓名:%s, 年龄: %d, 性别: sex: %s&#x27; % (name, age, sex))userInfo(&#x27;李XX&#x27;, 18, &#x27;男&#x27;) 输出结果： 1姓名:李XX, 年龄: 18, 性别: sex: 男 我们为什么要使用位置参数，原因显而易见，有时我们在调用函数时，必须按照顺序输入参数，否则输出的信息与预料中会有出入。 2、关键字参数前面说了，在大多数情况下我们用的是位置参数，但是如果参数很多的时候，我们在调用时可能很难记住参数的顺序，我们引入关键字参数即使用参数名提供的参数，在于明确每个参数的作用，使得函数调用的时候，参数的含义变得更加清晰。 实例： 1234def userInfo(name, age, sex): print(&#x27;姓名:%s, 年龄: %d, 性别: sex: %s&#x27; % (name, age, sex))userInfo(name=&#x27;李XX&#x27;, sex=&#x27;男&#x27;, age=18) 输出结果： 1姓名:李XX, 年龄: 18, 性别: sex: 男 可以看出，我们使用关键字参数后，传参的顺序打乱，但是输出的结果与使用位置参数时一样，这就是关键字参数的奇妙之处 3、默认值参数有时候，我们自定义的函数中，如果调用的时候没有设置参数，需要给个默认值，这时候就需要用到默认值参数了。 示例: 1234def userInfo(name, age, sex=&#x27;男&#x27;): print(&#x27;姓名:%s, 年龄: %d, 性别: sex: %s&#x27; % (name, age, sex))userInfo(&#x27;李XX&#x27;, 18) 输出结果： 1姓名:李XX, 年龄: 18, 性别: sex: 男 从输出结果可以看出，当你设置了默认参数的时候，在调用函数的时候，不传该参数，就会使用默认值。但是有一点需要注意的是：只有在形参表末尾的那些参数可以有默认参数值，也就是说你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。这是因为赋给形参的值是根据实参传递的顺序而赋值的。例如，def func(a, b=1) 是有效的，但是 def func(a=1, b) 是 无效 的。 4、可变参数可变参数有两种，第一种是args，第二种是kwargs。 先来看第一种，用老师布置的作业举例： 1234567def multi(*numbers): result = 1 for num in numbers: result = num * result return resultprint(multi(1, 2, 3, 4)) 输出结果： 124 在上面定义的函数中，*numbers是一个可变参数，而且它的本质其实就是一个元组，使用了可变参数后，我们可以在函数调用时传入若干个参数。 12345def userInfo(name, age, sex, **hobby): print(&#x27;姓名:%s, 年龄: %d, 性别: sex: %s&#x27; % (name, age, sex)) print(&#x27;爱好：&#123;&#125;&#x27;.format(hobby)) userInfo(&#x27;李XX&#x27;, 18, &#x27;男&#x27;, hobby1 = &#x27;编程&#x27;, hobby2 = &#x27;编程&#x27;, hobby3 = &#x27;编程&#x27;) 输出结果： 12姓名:李XX, 年龄: 18, 性别: sex: 男爱好：&#123;&#x27;hobby1&#x27;: &#x27;编程&#x27;, &#x27;hobby2&#x27;: &#x27;编程&#x27;, &#x27;hobby3&#x27;: &#x27;编程&#x27;&#125; 可以看出，这种可变参数，在调用函数时传入实参需用关键字参数，因为它的本质是一个字典。 匿名函数lambda表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，被称为匿名函数.lambda所表示的匿名函数内容应该比较简单，如果函数内容复杂的话，应该重新定义一个函数。 实例： 123add = lambda x, y : x+yprint(add(1, 2)) 输出结果： 13 从实例看，我们可以把冒号左边的表达式，冒号右边的表达式理解为函数返回值。 Python提供了很多函数式编程的特性，如：map、reduce、filter、sorted等这些函数都支持函数作为参数。lambda函数就可以应用在函数式编程中。 函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。 比如将列表中的元素按照绝对值大小进行升序排列： 12345list = [3, 5, -4, -1, 0, -2, -6]list = sorted(list, key=lambda x: abs(x))print(list) 输出结果： 1[0, -1, -2, 3, -4, 5, -6] 拓展上面我们提到了map、reduce、filter、sorted这些函数，那它们到底是用来干什么的，让我们来介绍一下 1、mapmap函数接受两个参数，第一个参数是函数的名称，第二个参数一个可迭代对象。map函数就是将具体数值根据算法进行计算，，并将结果保存为一个迭代器。 实例： 12345678910def add(x): x += 1 return xlist = [1, 2, 3]newList = map(add, list)for i in newList: print(i) 输出结果： 123234 2、reduce reduce同map函数一样，也是接受两个参数，但不同的是，reduce函数将当前数值的计算结果与下一个数值的计算结果进行累积计算。reduce()函数第一次运行时会将可迭代对象的第一项作为第一个参数，第二项作为第二个参数传入函数。第二次运行则会将函数第一次运行所返回的结果作为第一个参数，可迭代对象的第三项作为第二个参数传入函数…… 实例： 12345678910from functools import reducedef accumulate(x, y): return x + ylist = [1, 2, 3, 4]result = reduce(accumulate, list)print(result) 输出结果： 110 3、filter同上两个函数一样，接受两个参数，第一个参数为函数名，第二个参数为序列。但filter根据序列中各个元素作用与函数时，函数返回结果(True/False)来决定该元素是否保留。 实例： 123456789101112def fetchEven(num): if num % 2 == 0: return True else: return Falselist = [1, 2, 3, 4, 5]newList = filter(fetchEven, list)for i in newList: print(i) 输出结果： 1224 4、sortedsorted顾名思义，就是用来排序的，sorted可以接受一个key函数(可选参数)，实现自定义排序。 实例： 12345list = [3, 5, -4, -1, 0, -2, -6]newList = sorted(list, key=abs)print(newList) 输出结果： 1[0, -1, -2, 3, -4, 5, -6] 以上几个函数的优点是，在执行过程中没有副作用。例如当我们使用map处理list时，并不会改变传入的list，而时返回了一个新的迭代器对象。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"趁年轻，赶快学一波vim","slug":"趁年轻，赶快学一波vim","date":"2018-05-05T12:15:37.000Z","updated":"2022-06-06T03:22:14.527Z","comments":true,"path":"2018/05/05/趁年轻，赶快学一波vim/","link":"","permalink":"http://yoursite.com/2018/05/05/%E8%B6%81%E5%B9%B4%E8%BD%BB%EF%BC%8C%E8%B5%B6%E5%BF%AB%E5%AD%A6%E4%B8%80%E6%B3%A2vim/","excerpt":"","text":"介绍Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。 VIM是自由软件。Vim普遍被推崇为类Vi编辑器中最好的一个，事实上真正的劲敌来自Emacs的不同变体。1999 年Emacs被选为Linuxworld文本编辑分类的优胜者，Vim屈居第二。但在2000年2月Vim赢得了Slashdot Beanie的最佳开放源代码文本编辑器大奖，又将Emacs推至二线， 总的来看， Vim和Emacs在文本编辑方面都是非常优秀的。 使用首先我们需要先安装vim 12brew install vim // mac安装vimapt-get install vim // ubuntu安装vim windows用户请前往搜索引擎搜索vim下载安装 本文通过vimtutor进行vim的学习，安装完vim后在终端输入vimtutor即可 vim模式命令模式: 用于输入指令，如：保存、运行、切换标签、切割屏幕等插入模式: 也即编辑模式，用于编辑文本可视模式: 相当于高亮选取文本后的正常模式正常模式: 用于查看文本，也可复制、粘贴、撤销、重做等 移动光标在正常模式键可用h、j、k、l来分别代替←、↓、↑、→键来移动光标,对于初学者来说,这种移动光标的方式十分不习惯,但是用这种方式移动光标在编程的过程中可以不用频繁的移动右手 注意：当某一行为空时，h、l无法进行左右的移动 如果您不敢确定您所按下的字母，请按下键回到正常(Normal)模式。然后再次从键盘输入您想要的命令。 vim的进入和退出恩,我已经玩熟了光标操作，这个玩意儿太方便啦，咦，但是我怎么退出vim呢 1、按&lt;ESC&gt;键，确定你处于正常模式。 2、然后键入:q， 然后按回车，但这样做并不会将你修改的内容保存。 3、键入:wq，可以在退出的同时保存你所修改的内容。 4、对，你没猜错，如果想只保存不退出，键入:w就行了 文本编辑之删除那么我想要在正常模式下删除某个内容怎么办呢，很简单，你只需要用我们所学的移动光标方式将光标移动到你想要删除的文本位置，按下x键即可 提示：当我对某个操作不满意，想要撤回的时候，只要键入u即可 文本编辑之插入哇，我发现文本的内容不是我想要的，我要修改他，可是在正常模式下我好像无法编辑它诶，怎么办。 按i进入插入模式，在这个模式下，你可以随意的修改文本了，但是你不能再用h、j、k、l的方式来移动光标了，当你修改完成后，可以按&lt;ESC&gt;返回正常模式 文本编辑之添加啊？这个插入模式是什么鬼，我怎么只能往光标前添加内容，如果我想在原本的内容后添加新的内容怎么办？ 你可以在正常模式下，按a键，然后输入你要添加的内容，同样的，在输入完成后按&lt;ESC&gt;返回正常模式。 删除类命令之前的删除方法好麻烦啊，难道我删除一大串内容要一个一个移动光标，然后按一次又一次的x吗。当然不是 许多改变文本的命令都由一个操作符和一个动作构成。 使用删除操作符 d 的删除命令的格式如下： ​ d motion 一个简短的动作列表： ​ w - 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符。 e - 从当前光标当前位置直到单词末尾，包括最后一个字符。 $ - 从当前光标当前位置直到当前行末。 简单来说，如果我想要删除一个单词只需要键入dw，如果我键入d$，那么这一整行的内容都被我删了 使用计数指定动作假如vim打开的文件中某一个行有这样一句的内容 This is just a line with words you can move around in. 我的光标在开头的T位置 键入一次e，我的光标位置就会出现在This这个单词的末尾s处，键入两次，就会出现在下一个单词的末尾。 键入w，就会出现在下一个单词的开头，多次键入与e的效果雷同。 键入0，能使我的光标出现在行首。 键入$，能使我的光标出现在行末。 使用计数已删除更多上面已经提到过删除操作符和动作的组合，你可以在组合中动作之前插入一个数字以删除更多 ​ d number(数字) motion 比如键入d2w，我们就可以删除光标所在位置起的两个单词 操作整行 之前用d$命令删除整行内容后，我们会发现这一行变成了一个空行，所以可能用清除整行内容来称呼它更加合适 如果我们要删除当前行，可以键入dd命令 你也可以键入2dd，来删除当前行起的两行 撤销类命令 之前有提到过，如果你操作失误，可以键入u来撤销最后一次执行的命令 如果你嫌一次一次的撤销太麻烦，你可以键入U，来使当前行恢复到初始状态 你也可以键入CTRL-R(先按着CTRL键不放，再键入R)来重做撤销的命令 置入类命令之前所说的dd命令删除了一整行内容，其实呢，他并没有它并没有消失，而是保存在了vim的寄存器中。 当使用dd命令删除了某一行内容后，光标移到某一行，键入p，刚刚删除掉的那一行内容就会粘贴到当前行的下一行了 替换类命令当我们发现某处出错时，我们可以不必先删除再插入来修改错误，这样子太麻烦，我们可以使用替换命令。 如下两行，第一行有错误，第二行是正确的，我们想要将第一行单词出错的地方修正可以怎么做呢 Whan this lime was tyoed in, someone presswd some wrojg keys! When this line was typed in, someone pressed some wrong keys! 将光标移到所要修改的字符处，键入p，然后输入所要替换的字符即可 更改类命令同样的我们也可以更改整个单词，而不是一个字符 键入cw，然后输入正确的内容，我们就可以更改整个单词了。 使用c更改更多更改类操作符的工作方式跟删除类是一致的。操作格式是：​ c [number] motion 动作参数(motion)也是一样的，比如 w 代表单词，$代表行末等等 除了上一节所说的cw，我也可以键入c$，用来修改当前字符到行末的所有内容 定位及文件状态输入 CTRL-G 显示当前编辑文件中当前光标所在行位置以及文件状态信息。输入大写 G 则直接跳转到文件中的某一指定行 提示：切记要先通读本节内容，之后才可以执行以下步骤!!! 按下 CTRL 键不放开然后按 g 键。我们称这个键组合为 CTRL-G。您会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名和文件中光标位置。请记住行号，它会在步骤3中用到。 输入大写 G 可以使得当前光标直接跳转到文件最后一行。输入 gg 可以使得当前光标直接跳转到文件第一行。 输入您曾停留的行号，然后输入大写 G。这样就可以返回到您第一次按下CTRL-G 时所在的行了。 搜索类命令输入 / 加上一个字符串可以用以在当前文件中查找该字符串。 1、 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底部，这跟 : 命令是一样的。 2、接着输入你要查找的内容，然后按回车，就会查找到您所输入的字符串 3、要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字符串，请输入大写 N 即可。 4、如想逆向查找字符串，请使用 ? 代替 / 进行。 5、要回到您之前的位置按 CTRL-O (按住 Ctrl 键不放同时按下字母 o)。重复按可以回退更多步。CTRL-I 会跳转到较新的位置。 提示：如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非’wrapscan’ 选项被复位。 配对括号的查找输入%可以查找配对的字符串 *当你的光标位置在某一个括号上，键入%，你的光标就会跳到与之配对的括号位置了，如果再次键入，光标就会调回配对的第一个括号处 在程序调试时，这个功能用来查找不配对的括号是很有用的。 替换命令假如有这么一行字符串 thee best time to see thee flowers is in thee spring. 当我键入:s/thee/the &lt;回车&gt;，那么该行的第一thee就被我替换成了the 如果想将所有的thee替换，可以键入:s/thee/the/g 要替换两行之间出现的每个匹配串，请 输入 :#,#s/old/new/g 其中 #,# 代表的是替换操作的若干行中首尾两行的行号。 输入 :%s/old/new/g 则是替换整个文件中的每个匹配串。 输入 :%s/old/new/gc 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换。 在vim内执行外部命令的方法再用vim编程的时候，如果我想输入一个外部命令怎么办，难道我还需要新建个终端窗口吗？当然不需要 1、 按下我们所熟悉的 : 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。 2、 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。 3、 我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起作用，您可以试试 :!dir 看看。 关于保存文件的更多信息要将对文件的改动保存到文件中，请输入 :w FILENAME 。 1、 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲&lt;回车&gt; 吧。 2、 选择一个未被用到的文件名，比如 TEST。 3、 接着输入 :w TEST (此处 TEST 是您所选择的文件名。) 4、 该命令会以 TEST 为文件名保存整个文件 (Vim 教程)。为了验证这一点，请再次输入 :!dir 或 :!ls 查看您的目录列表内容。 一个具有选择性的保存命令要保存文件的部分内容，请输入 v motion :w FILENAM 1、移动光标到某一行 2、键入v，将光标移到下面几行，您会发现，之前的文本被高亮了 3、然后键入:，您将看到屏幕底部会出现 :’&lt;,’&gt; 。 4、现在请输入 w TEST，其中 TEST 是一个未被使用的文件名。确认您看到了 :’&lt;,’&gt;w TEST 之后按 &lt;回车&gt; 键。 5、这时 Vim 会把选中的行写入到以 TEST 命名的文件中去。使用 :!dir 或 :!ls确认文件被正确保存。这次先别删除它！我们在下一讲中会用到它 按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或变小。接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容。 提取和合并文件要向当前文件中插入另外的文件的内容，请输入 :r FILENAME 1、将光标移到新的一行 提示：步骤2之后您将看到第五讲第三节的文字，请届时往下移动以再次看到本讲内容 2、接着通过命令 :r TEST 将前面创建的名为 TEST 的文件提取进来。您所提取进来的文件将从光标所在位置处开始置入 3、为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份上一讲的内容，一份是原始内容，另外一份是来自文件的副本。 您还可以读取外部命令的输出。例如， :r !ls 可以读取 ls 命令的输出，并把它放置在光标下面。 打开类命令输入 o 将在光标的下方打开新的一行并进入插入模式。 当光标在任意行时，键如o，可以打开新的一行并进入插入模式，您可以写入新的内容，写入完成后按&lt;ESC&gt;返回正常模式。 附加类命令输入 a 将可在光标之后插入文本 另外一个置换类命令的版本输入大写的 R 可连续替换多个字符。 假如有如下两个字符串 Adding 123 to xxx gives you xxx.Adding 123 to 456 gives you 579. 您可以将光标移到第一句的xxx处，然后键入R，进行连续的输入，知道内容与第二句相似，按ESC进入正常模式，将光标移到下个xxx处，重复上述操作，这样上下两个字符串就相等啦。 复制粘贴文本使用操作符 y 复制文本，使用 p 粘贴文本 1、首先将光标移到要复制的内容开头。 2、键入v进入可视模式。 3、移动光标，将要复制的内容高亮 4、键入y抽离文本 5、将光标移动到你希望复制的位置，键入p粘贴 设置类命令的选项1、 要查找单词 ignore 可在正常模式下输入 /ignore &lt;回车&gt;。要重复查找该词，可以重复按 n 键。 2、 然后设置 ic 选项(Ignore Case，忽略大小写)，请输入： :set ic 3、 现在可以通过键入 n 键再次查找单词 ignore。注意到 Ignore 和 IGNORE 现在也被找到了。 4、 然后设置 hlsearch 和 incsearch 这两个选项，请输入： :set hls is 5、 现在可以再次输入查找命令，看看会有什么效果：/ignore &lt;回车&gt; 6、 要禁用忽略大小写，请输入： :set noic 提示：要移除匹配项的高亮显示，请输入： :nohlsearch提示：如果您想要仅在一次查找时忽略字母大小写，您可以使用 \\c：/ignore\\c &lt;回车&gt; 获取帮助信息Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方法之一： 按下&lt;HELP&gt;键 (如果键盘上有的话) 按下 &lt;F1&gt; 键 (如果键盘上有的话) 输入 :help &lt;回车&gt; 请阅读帮助窗口中的文字以了解帮助是如何工作的。 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 输入 :q &lt;回车&gt; 可以关闭帮助窗口。 提供一个正确的参数给”:help”命令，您可以找到关于该主题的帮助。请试验以下参数(可别忘了按回车键哦)： 1234:help w:help c_CTRL-D:help insert-index:help user-manual 创建启动脚本Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，您得创建一个 vimrc 文件。 1、 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统： 12:edit ~/.vimrc // 这是 Unix 系统所使用的命令:edit $VIM/_vimrc // 这是 MS-Windows 系统所使用的命令 2、 接着读取 vimrc 示例文件的内容： 1:r $VIMRUNTIME/vimrc_example.vim 3、 保存文件，命令为： 1:write 下次您启动 Vim 时，编辑器就会有了语法高亮的功能。您可以把您喜欢的各种设置添加到这个 vimrc 文件中。要了解更多信息请输入 :help vimrc-intro 补全功能1、 输入 :help 或者按 &lt;F1&gt; 键或 &lt;Help&gt; 键可以打开帮助窗口。 2、 输入 :help cmd 可以找到关于 cmd 命令的帮助。 3、 输入 CTRL-W CTRL-W 可以使您在窗口之间跳转。 4、 输入 :q 以关闭帮助窗口 5、 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。 6、 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。按 &lt;TAB&gt; 可以使用一个补全。 小结相信学会了vim，你的编程效率能更上一层楼，梦想还是要有的，趁还年轻。","categories":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"h5触摸事件实现移动端进度条","slug":"h5触摸事件实现移动端进度条","date":"2018-05-01T08:49:23.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2018/05/01/h5触摸事件实现移动端进度条/","link":"","permalink":"http://yoursite.com/2018/05/01/h5%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BF%9B%E5%BA%A6%E6%9D%A1/","excerpt":"","text":"前言HTML中新添加了许多新的事件，但由于兼容性的问题,许多事件都没有广泛的应用，接下来为大家介绍一些好用的移动端触摸事件: touchstart、touchmove、touchend。 介绍下面我们来简单介绍一下这几个事件: touchstart： 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。 touchmove：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 touchend：当手指从屏幕上离开的时候触发。 这些触摸事件具有常见的dom属性。此外，他们还包含着三个用于跟踪触摸的属性： touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个touch对象包含的属性如下： clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：screenX：触摸目标在屏幕中的x坐标。 screenY：screenX：触摸目标在屏幕中的x坐标。 identifier：标识触摸的唯一ID。 target：screenX：触摸目标在屏幕中的x坐标。 了解了触摸事件的特征，那就开始紧张刺激的实战环节吧 实战下面我们来通过使用触摸事件来实现一个移动端可滑动的进度条 我们先进行HTML的布局 1234&lt;div class=&quot;progress-wrapper&quot;&gt; &lt;div class=&quot;progress&quot;&gt;&lt;/div&gt; &lt;div class=&quot;progress-btn&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS部分此处省略 获取dom元素，并初始化触摸起点和按钮离容器最左方的距离 1234567const progressWrapper = document.querySelector(&#x27;.progress-wrapper&#x27;)const progress = document.querySelector(&#x27;.progress&#x27;)const progressBtn = document.querySelector(&#x27;.progress-btn&#x27;)const progressWrapperWidth = progressWrapper.offsetWidthlet touchPoint = 0let btnLeft = 0 监听touchstart事件 12345progressBtn.addEventListener(&#x27;touchstart&#x27;, e =&gt; &#123; let touch = e.touches[0] touchPoint = touch.clientX // 获取触摸的初始位置 btnLeft = parseInt(getComputedStyle(progressBtn, null)[&#x27;left&#x27;], 10) // 此处忽略IE浏览器兼容性&#125;) 监听touchmove事件 1234567891011progressBtn.addEventListener(&#x27;touchmove&#x27;, e =&gt; &#123;e.preventDefault() let touch = e.touches[0] let diffX = touch.clientX - touchPoint // 通过当前位置与初始位置之差计算改变的距离 let btnLeftStyle = btnLeft + diffX // 为按钮定义新的left值 touch.target.style.left = btnLeftStyle + &#x27;px&#x27; progress.style.width = (btnLeftStyle / progressWrapperWidth) * 100 + &#x27;%&#x27; // 通过按钮的left值与进度条容器长度的比值，计算进度条的长度百分比&#125;) 通过一系列的逻辑运算，我们的进度条已经基本实现了，但是发现了一个问题，当触摸位置超出进度条容器时，会产生bug，我们再来做一些限制 12345if (btnLeftStyle &gt; progressWrapperWidth) &#123; btnLeftStyle = progressWrapperWidth &#125; else if (btnLeftStyle &lt; 0) &#123; btnLeftStyle = 0&#125; 至此，一个简单的移动端滚动条就实现了","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"React使用Better-Scroll封装Scroll组件","slug":"React使用Better-Scroll封装Scroll组件","date":"2018-04-11T12:06:20.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2018/04/11/React使用Better-Scroll封装Scroll组件/","link":"","permalink":"http://yoursite.com/2018/04/11/React%E4%BD%BF%E7%94%A8Better-Scroll%E5%B0%81%E8%A3%85Scroll%E7%BB%84%E4%BB%B6/","excerpt":"","text":"React使用Better-Scroll封装Scroll组件better-scroll是一个移动端滚动插件，基于iscroll重写的。普通的网页滚动效果是很死板的，better-scroll具有拉伸、回弹的效果并且滚动的时候具有惯性，很接近原生体验。better-scroll更多相关内容见github地址相信很多人在vue中都用过better-scroll，因为better-scroll的作者很好的把它运用在了vue中，几乎一说到better-scroll大家就会想到vue(2333~~~)。其实better-scroll是利用原生js编写的，所以在所有使用原生js的框架中几乎都能使用它，这里我将在React中的运用better-scroll首先在src目录下新建一个common目录用来存放公用的组件，新建scroll文件夹，然后在scroll文件夹下新建Scroll.js和scroll.scss文件。先来分析一下怎么设计这个Scroll组件，better-scroll的原理就是外层一个固定高度的元素，这个元素有一个子元素，当子元素的高度超过父元素时就可以发生滚动，那么子元素里面的内容从何而来？React为我们提供了一个props的children属性用来获取组件的子组件，这样就可以用Scroll组件去包裹需要滚动的内容。在Scroll组件内部的列表，会随着增加或减少原生而发生变化，这个时候元素的高度也会发生变化，better-scroll需要重新计算高度，better-scroll为我们提供了一个refresh方法用来重新计算以保证正常滚动，组件发生变化会触发React的componentDidUpdate周期函数，所以我们在这个函数里面对better-scroll进行刷新操作，同时需要一个props来告诉Scroll是否refresh刷新。某些情况下我们需要手动调用Scroll组件去刷新better-scroll，这里对外暴露一个Scroll组件的方法。better-scroll默认是禁止点击的，需要提供一个控制是否点击的props，为了监听滚动Scroll需要对外暴露一个函数，便于使用Scroll的组件监听滚动进行其他操作。当组件销毁时我们把better-scroll绑定的事件取消以及better-scroll实例给销毁掉，释放资源 安装better-scroll 1npm install better-scroll --save 对组件的props进行类型检查，这里使用prop-types库。类型检查是为了提早发现开发问题，避免一些bug产生 安装props-types 1npm install prop-types --save 编写Scroll组件 scroll.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import PropTypes from &quot;prop-types&quot;import BScroll from &quot;better-scroll&quot;import &quot;./scroll.styl&quot;class Scroll extends React.Component &#123; componentDidUpdate() &#123; //组件更新后，如果实例化了better-scroll并且需要刷新就调用refresh()函数 if (this.bScroll &amp;&amp; this.props.refresh === true) &#123; this.bScroll.refresh(); &#125; &#125; componentDidMount() &#123; this.scrollView = ReactDOM.findDOMNode(this.refs.scrollView); if (!this.bScroll) &#123; this.bScroll = new BScroll(this.scrollView, &#123; //实时派发scroll事件 probeType: 3, click: this.props.click &#125;); if (this.props.onScroll) &#123; this.bScroll.on(&quot;scroll&quot;, (scroll) =&gt; &#123; this.props.onScroll(scroll); &#125;); &#125; &#125; &#125; componentWillUnmount() &#123; this.bScroll.off(&quot;scroll&quot;); this.bScroll = null; &#125; refresh() &#123; if (this.bScroll) &#123; this.bScroll.refresh(); &#125; &#125; render() &#123; return ( &lt;div className=&quot;scroll-view&quot; ref=&quot;scrollView&quot;&gt; &#123;/*获取子组件*/&#125; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;Scroll.defaultProps = &#123; click: true, refresh: false, onScroll: null&#125;;Scroll.propTypes = &#123; //是否启用点击 click: PropTypes.bool, //是否刷新 refresh: PropTypes.bool, onScroll: PropTypes.func&#125;;export default Scroll 上诉代码中ref属性来标记div元素，使用ReactDOM.findDOMNode函数来获取dom对象，然后传入better-scroll构造函数中初始化。在Scroll组件中调用外部组件的方法只需要把外部组件的函数通过props传入即可，这里就是onScroll函数 scroll.scss 12345.scroll-view &#123; width: 100%; height: 100%; overflow: hidden;&#125; scroll.styl中就是一个匹配父容器宽高的样式 接下来在Recommend组件中加入Scroll组件，导入Scroll组件 1import Scroll from &#x27;@/common/scroll/Scroll&#x27; 在state中增加refreshScroll用来控制Scroll组件是否刷新 123this.state = &#123; refreshScroll: false&#125;; 使用Scroll组件包裹需要的内容 123&lt;Scroll refresh=&#123;this.state.refreshScroll&#125;&gt; // 我是内容啊&lt;/Scroll&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"hexo的使用与部署","slug":"hexo的使用与部署","date":"2018-03-18T09:18:20.000Z","updated":"2022-06-06T03:22:14.524Z","comments":true,"path":"2018/03/18/hexo的使用与部署/","link":"","permalink":"http://yoursite.com/2018/03/18/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%83%A8%E7%BD%B2/","excerpt":"","text":"github page在github 上的项目名称必须和自己用户名一样 自己的用户名是aaa项目名得是 aaa.github.io 安装hexo ,一些工具(git,node) 略过 关联 Hexo 与 GitHub Pages我们如何让本地git项目与远程的github建立联系呢？用 SSH keys 生成SSH keys输入你自己的邮箱地址1ssh-keygen -t rsa -C &quot;940166841@qq.com&quot;在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入，我们按回车不设置密码。 添加 SSH Key 到 GitHub打开 C:\\Users\\lizhihao \\ .ssh\\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的 new SSH key 中 测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：1ssh -T git@github.com 如果是下面的反馈： The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到： Hi Lizhihao97! You’ve successfully authenticated, but GitHub does not provide shell access. 配置Git个人信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。12git config --global user.name &quot;lizhihao97&quot;git config --global user.email &quot;940166841@qq.com&quot; 配置 Deployment在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的： 需要注意的是：冒号后面记得空一格！123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:lizhihao97/lizhihao97.github.io.git branch: master 本地文件提交到 GitHub Pages12345678910111213// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d在浏览器中输入 https://lizhihao97.github.io （用户名改成你的）看到了 Hexo 与 GitHub Pages 已经成功关联了 注意1：若上面操作失败，则需要提前安装一个扩展：1npm install hexo-deployer-git --save 写文章写一篇文章,默认是以post作为模板12hexo new first(文章名)tags里面写标签1234567tags:- 前端- 后端分类categories:- 技术 生成页面1hexo new page about //以page 作为模版,会自动生成里面的index.md 搜索功能的实现 https://github.com/alexbruno/hexo-generator-json-content 部分学习自：http://www.jianshu.com/p/39562a0d8eb6 出错部署出错Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 解决方法：条件SSHkey$ ssh-keygen -t rsa -C “imsofter@163.com”三次回车，即可设置密码为空 将生成的C:\\Users\\用户名.ssh目录下的id_rsa.pub添加到github上 再测试是否可以连接到github上，$ ssh git@github.comHi imsofter! You’ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"react生命周期详解","slug":"react生命周期详解","date":"2017-06-27T12:14:02.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2017/06/27/react生命周期详解/","link":"","permalink":"http://yoursite.com/2017/06/27/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"组件的生命周期分成三个状态 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM Mounting(装载) getInitialState(): 在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。 componentWillMount()：服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用。不会触发再次渲染。 componentDidMount()：在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）,可以设置state，会触发再次渲染，组件内部可以通过 Updating (更新) componentWillReceiveProps(nextProps) 在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。通常可以调用this.setState方法来比较this.props和nextProps的执行状态，完成对state的修改。在该函数中调用 this.setState() 将不会引起第二次渲染。 shouldComponentUpdate(nextProps,nextState): 在接收到新的 props 或者 state，将要渲染之前调用。该方法用来拦截新的props或state，然后判断是否更新组件 该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会。如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false。 componentWillUpdate(nextProps, nextState)：在接收到新的 props 或者 state 之前立刻调用，即更新之前调用 在初始化渲染的时候该方法不会被调用。使用该方法做一些更新之前的准备工作。 注意：你不能在该方法中使用 this.setState()。如果需要更新 state 来响应某个 prop 的改变，请使用 componentWillReceiveProps。 componentDidUpdate(prevProps, prevState): 在组件的更新已经同步到 DOM 中之后立刻被调用。 该方法不会在初始化渲染的时候调用。使用该方法可以在组件更新之后操作 DOM 元素。 Unmounting(移除) componentWillUnmount：在组件从 DOM 中移除的时候立刻被调用。 在该方法中执行任何必要的清理,收尾工作，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素。 参考文章: React-Native之React速学教程-(中)/) react生命周期","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"在javascript使用es6,es7","slug":"在javascript使用es6-es7","date":"2017-02-13T12:33:43.000Z","updated":"2022-06-06T03:22:14.525Z","comments":true,"path":"2017/02/13/在javascript使用es6-es7/","link":"","permalink":"http://yoursite.com/2017/02/13/%E5%9C%A8javascript%E4%BD%BF%E7%94%A8es6-es7/","excerpt":"","text":"const1234567const a=3; //定义常量// 如果要用es 5的方式怎么写呢？？Object.defineProperty(window, &quot;a&quot;, &#123; value: 37, writable: false,&#125;);console.log(window.a) 作用域es6的作用域123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined在es5中,并没有块级作用域，先用es5写一个作用域看看 123456789101112var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10a[5](); // 10a[4](); // 10a[3](); // 10a[2](); // 10a[1](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 ES6 定义属性es5怎么写呢12345678var x = 1, y = 2;var object = &#123; x: x, y: y&#125;;console.log(object.x); //output &quot;1&quot;```javascript在es6中//给一个属性赋一个变量值，如果变量名和属性名相同，ES6 提供了一个简洁的语法，可以省略变量名 let x = 1, y = 2;let object = { x, y};console.log(object.x); //output “1”12345678910111213141516171819202122232425262728293031### 箭头函数```javascript// es5中的thisvar A = function () &#123; this.a = &#x27;a&#x27;; this.b = &#x27;b&#x27;; this.c = &#123; a: &#x27;a++&#x27;, b: function () &#123; console.log(this.a); &#125; &#125;&#125;console.log(new A().c.b()) // a++ 因为es5中的this即谁调用它，this就指向谁//es6var A = function () &#123; this.a = &#x27;a&#x27;; this.b = &#x27;b&#x27;; this.c = &#123; a: &#x27;a++&#x27;, b: ()=&gt;&#123; console.log(this.a); &#125; &#125;&#125;console.log(new A().c.b()) // a,箭头函数this的指向是定义时this的指向，b函数在定义的时候this就指向函数体里面的this 123456//带有默认参数的箭头函数let hello =(name=&#x27;world&#x27;)=&gt;&#123; console.log(`hello $&#123;name&#125;`) //注意这边不是单引号&#125;hello() //hello worldhello(&#x27;skl&#x27;)//hello skl 1234//多个参数let cal1 =(num1,num2)=&gt;num1*num2let arr=[6,7]console.log(cal1(...arr))//展开 123456789function hello(name1,name2)&#123; console.log(name1,name2)&#125;let arr =[&#x27;skl1&#x27;,&#x27;skl2&#x27;];//es5//hello.apply(null,arr)//es6hello(...arr) 默认参数123456789// es5function a(x,y ) &#123; x=x||1; y=y||2;&#125;// es6function b(x=1,y=2)&#123; return x+y;&#125; 可变参数12345678910111213141516171819202122232425262728293031323334353637&#123; //es5 function f() &#123; var a = Array.prototype.slice.call(arguments); var sum = 0; a.forEach(function (item) &#123; sum += item; &#125;) return sum; &#125; console.log(f(1, 2, 3, 4)) &#125;&#123; //es5 function f(...a) &#123; var sum = 0; a.forEach(function (item) &#123; sum += item; &#125;) return sum; &#125; console.log(f(1, 2, 3, 4)) &#125;// 扩展运算符的使用// 合并数组 es5&#123; var a=[1,2,4]; var b=[11,111,111]; var c=b.concat(a); console.log(c)&#125;// 合并数组 es6运用扩展运算符&#123; var a=[1,2,4]; var b=[11,111,111]; var c=[...a,...b]; console.log(c)&#125; 对象扩展1234567var obj=&#123; name:&#x27;skl&#x27;, age:18,&#125;console.log(Object.keys(obj))//[&quot;name&quot;,&quot;age&quot;]console.log(Object.values(obj))//[&quot;skl&quot;,18]console.log(Object.entries(obj))// key 和value变成一个数组 123456789const name = &#x27;skl&#x27;const age=&#x27;nian&#x27;;const height=&#x27;shengao&#x27;const obj = &#123; [age]:18, height&#125;obj[name] = &#x27;hello skl&#x27;;console.log(obj)//&#123;nian: 18, height: &quot;shengao&quot;, skl: &quot;hello skl&quot;&#125; 1234const obj1=&#123;name:&#x27;skl&#x27;,age:18&#125;const obj2=&#123;type:&#x27;ha&#x27;,aa:90&#125;console.log(&#123;...obj1,...obj2&#125;)//&#123;name: &quot;skl&quot;, age: 18, type: &quot;ha&quot;, aa: 90&#125; 12345678//结构赋值const arr =[&#x27;skl&#x27;,&#x27;sk2&#x27;];let [arg1,arg2]=arr;console.log(arg1,arg2)//skl sk2const obj=&#123;nian: 18, height: &quot;shengao&quot;, skl: &quot;hello skl&quot;&#125;const &#123;nian,height&#125;=obj;console.log(nian,height)//18 shengao 代理做数据保护es5中的数据保护123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // 数据保护（相当于私有变量）es5的写法,定义一个构造函数 var Person = function () &#123; var data = &#123; name: &#x27;es5&#x27;, sex: &#x27;male&#x27;, age: 20 &#125; // getter 和setter this.get = function (key) &#123; return data[key] &#125; this.set = function (key, value) &#123; if (key !== &#x27;sex&#x27;) &#123; data[key] = value; &#125; &#125; &#125; // 声明实例 var person = new Person(); // 读取 console.table(&#123; name: person.get(&#x27;name&#x27;), sex: person.get(&#x27;sex&#x27;), aeg: person.get(&#x27;ageqe3w&#x27;) &#125;) // 修改 person.set(&#x27;name&#x27;, &#x27;啦啦啦&#x27;);// 这时候console的结果就会变了 person.set(&#x27;sex&#x27;, &#x27;male&#x27;)// console出来发现没有用因为数据被保护了&#125;&#123; // 另一种写法 var Person = &#123; name: &#x27;skl&#x27;, age: 10, &#125; // sex只可读不可写 Object.defineProperties(Person, &#x27;sex&#x27;, &#123; writeable: false, value: &#x27;male&#x27;, &#125;) console.table(&#123; name: Person.name, age: Person.age, sex: Person.sex, &#125;) // 若强行给只读属性复制会报错&#125; es6中通过代理的方式做数据保护12345678910111213141516171819&#123; // es的代理 let Person = &#123; name: &#x27;11&#x27;, age: 11, sex: &#x27;male&#x27; &#125; //person是暴露给用户的，吧上面的Person保护起来 let person = new Proxy(Person, &#123; get(target, key) &#123; return target[key] &#125;, set(target, key, value) &#123; if (key !== &#x27;sex&#x27;) &#123; target[key] = value; &#125; &#125; &#125;)&#125; 字符串拼接在es5中，凭借字符串要不断的+,尤其是在html模板的时候，变得特别不方便1234const a=3;console.log(`skl$&#123;a&#125;`)//skl3`Hello $&#123;&#x27;World&#x27;&#125;`// &quot;Hello World&quot; for… of…12345678910var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();console.log(iterator) //Array Iterator &#123;&#125;for (let e of iterator) &#123; //返回有下标的数组 console.log(e) //[0, &quot;a&quot;] //[1, &quot;b&quot;] //[2, &quot;c&quot;]&#125; 1234567var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr;for (let e of iterator) &#123; console.log(e); //a b c&#125; 123456789var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();for (let [index,e] of iterator) &#123; console.log(index,e); // 0 &quot;a&quot; // 1 &quot;b&quot; // 2 &quot;c&quot;&#125; 123456789var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var iterator = arr.entries();for (let [index,e] of iterator) &#123; console.log(e);&#125;// a // b// c promise123456789101112131415161718192021222324252627282930313233343536373839let state = 1;function step1(resolve, reject) &#123; console.log(&#x27;1.开始-做饭&#x27;); if (state == 1) &#123; resolve(&#x27;做饭--完成&#x27;); &#125; else &#123; reject(&#x27;做饭--出错&#x27;); &#125;&#125;function step2(resolve, reject) &#123; console.log(&#x27;2.开始-吃饭&#x27;); if (state == 1) &#123; resolve(&#x27;吃饭--完成&#x27;); &#125; else &#123; reject(&#x27;吃饭--出错&#x27;); &#125;&#125;function step3(resolve, reject) &#123; console.log(&#x27;3.开始-收拾&#x27;); if (state == 1) &#123; resolve(&#x27;收拾--完成&#x27;); &#125; else &#123; reject(&#x27;收拾--出错&#x27;); &#125;&#125;new Promise(step1) .then(function (val) &#123; console.log(val) return new Promise(step2) &#125;) .then(function (val) &#123; console.log(val) return new Promise(step3) &#125;).then(function (val) &#123; console.log(val) &#125;) async12345async function testAsync()&#123; return &#x27;hello async&#x27;&#125;const result =testAsync();console.log(result); // 返回的是一个promise 12345678910111213141516function getSomething()&#123; return &#x27;something&#x27;&#125;async function testAsync()&#123; return &#x27;hello async&#x27;&#125;async function test()&#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1,v2)&#125;test() 模拟异步请求12345678910111213function takeLongTime()&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&quot;long_time_value&quot;) &#125;,1000) &#125;)&#125;async function test()&#123; const v = await takeLongTime() console.log(v)&#125;test()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"es7s","slug":"es7s","permalink":"http://yoursite.com/tags/es7s/"}]}]}