<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zh&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-06-06T06:08:30.130Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native中渲染的坑</title>
    <link href="http://yoursite.com/2022/06/06/React%20Native%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2022/06/06/React Native中渲染的坑/</id>
    <published>2022-06-06T03:55:00.000Z</published>
    <updated>2022-06-06T06:08:30.130Z</updated>
    
    <content type="html"><![CDATA[<p>解决方案来自<a href="https://stackoverflow.com/questions/52368342/invariant-violation-text-strings-must-be-rendered-within-a-text-component">StackOverflow</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当<strong>React Native</strong>从 0.54 升级到 0.57，代码报了以下错误</p><p><code>Invariant Violation: Text strings must be rendered within a &lt;Text&gt; component</code></p><p>乍一看好像是文本没有写在<code>&lt;Text&gt;</code>标签里，查了一下代码发现没有这个问题。最后网上搜索后解决</p><p>以下为伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">condition &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>需要修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">condition ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span> : <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>这是因为<code>condition</code>为<code>undefined</code>时，将不会渲染任何组件，而<code>null</code>或<code>空数组</code>可以安全的显示空白区域</p><blockquote><p>Tips: undefined &amp;&amp; true 与 true &amp;&amp; undefined 的结果都为 undefined</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决方案来自&lt;a href=&quot;https://stackoverflow.com/questions/52368342/invariant-violation-text-strings-must-be-rendered-within-a-text-component&quot;&gt;St
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>什么是事件委托（代理）？</title>
    <link href="http://yoursite.com/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/04/04/什么是事件委托（代理）？/</id>
    <published>2022-04-04T11:35:24.000Z</published>
    <updated>2022-06-06T03:22:14.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="事件冒泡-amp-amp-事件捕获"><a href="#事件冒泡-amp-amp-事件捕获" class="headerlink" title="事件冒泡 &amp;&amp; 事件捕获"></a>事件冒泡 &amp;&amp; 事件捕获</h3><p>当我们触发一个元素事件时，如果事件从最内层元素传递到最外层元素，此过程为<code>事件冒泡</code>，如果从最外层元素传递到最内层元素，此过程为<code>事件捕获</code></p><p>如以下代码所示：</p><ul><li>若触发<code>事件冒泡</code>，则事件执行顺序为<code>c</code>、<code>b</code>、<code>a</code></li><li>若触发<code>事件捕获</code>，则事件执行顺序为<code>a</code>、<code>b</code>、<code>c</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Javascript中<code>addEventListener</code>为元素绑定事件的方法，它接收三个参数</p><ol><li><strong>event</strong>：绑定的事件名</li><li><strong>function</strong>：执行的回调函数</li><li><strong>useCapture</strong><ul><li>false: 默认，代表冒泡时绑定</li><li>true: 代表捕获时绑定</li></ul></li></ol><h2 id="e-target和e-currentTarget"><a href="#e-target和e-currentTarget" class="headerlink" title="e.target和e.currentTarget"></a>e.target和e.currentTarget</h2><p>在以上的例子中新增js代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> a =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.a&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> b =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.b&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> c =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.c&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    a.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    b.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    c.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击c元素，控制台打印结果为：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：<span class="hljs-keyword">c</span><br><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：b<br><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：a<br></code></pre></td></tr></table></figure><p>由此我们可以得出结论<code>e.target</code>为我们点击的元素（可以理解为c在a、b的上层，所以我们点击的是c），e.currentTarget为绑定事件的元素（这里是冒泡，所以从c-&gt;a）</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="　事件委托"></a>　事件委托</h2><p>考虑一个需求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上所示，<code>ul</code>中有4个<code>li</code>，如果我们想在点击<code>li</code>后输出对应<code>li</code>的内容怎么办？</p><p>没错，我们可以给每个<code>li</code>都绑定一个事件，但你有没有想过，这里只有4个<code>li</code>，实际应用场景可能不止这么多，那难道我们给每个<code>li</code>都绑定事件吗？</p><p>利用我们之前所学的知识，我们可以进行如下操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.ul&#x27;</span>)</span><br><span class="language-javascript">  ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">innerHTML</span>)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就是<strong>事件委托</strong>啦，就是把子元素的事件，其原理就是利用<code>事件冒泡</code>和<code>e.target</code>，把处理子元素的操作，委托在父元素的事件中处理。，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;事件冒泡-amp-amp-事件捕获&quot;&gt;&lt;a href=&quot;#事件冒泡-amp-amp-事件捕获&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript常见手写题</title>
    <link href="http://yoursite.com/2022/03/20/Javascript%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98/"/>
    <id>http://yoursite.com/2022/03/20/Javascript常见手写题/</id>
    <published>2022-03-20T11:17:24.000Z</published>
    <updated>2022-06-06T03:22:14.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, timeout)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, timeout)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数柯里化（Currying）"><a href="#函数柯里化（Currying）" class="headerlink" title="函数柯里化（Currying）"></a>函数柯里化（Currying）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">const</span> args = [];<br><br>    <span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        args.<span class="hljs-title function_">push</span>(...<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br><br>    add.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args)<br>    &#125;<br>    <span class="hljs-keyword">return</span> add;<br>&#125;<br><br><span class="hljs-keyword">const</span> add = <span class="hljs-title function_">curry</span>(dynamicAdd);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">typeOf</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(x).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">toLowerCase</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&#x27;1&#x27;</span>)) <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>))) <span class="hljs-comment">// symbol</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1</span>))) <span class="hljs-comment">// bigint</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>([]))) <span class="hljs-comment">// array</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())) <span class="hljs-comment">// date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(&#123;&#125;)) <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ES6实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)])<br></code></pre></td></tr></table></figure></p><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>ES5实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> res = []<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>      res = res.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flatten</span>(arr[i]))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i])<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ES6实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>    arr = [].<span class="hljs-title function_">concat</span>(...arr)<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">all</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = []<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">index, value</span>) =&gt; &#123;<br>          result[index] = value<br>          count++<br>          <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result)<br>      &#125;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(index, res)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">addData</span>(index, promise)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">race</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">resolve</span>(res)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">reject</span>(err)<br>              &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">resolve</span>(promise)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">allSettled</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> res = []<br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>          res[i] = &#123;<br>              status,<br>              value<br>          &#125;<br>          count++<br>          <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-title function_">resolve</span>(res)<br>          &#125;<br>      &#125;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, i</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i)<br>              &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, promise, i)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">any</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>            promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>              <span class="hljs-title function_">resolve</span>(val)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                &#125;<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(promise)<br>        &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防抖（debounce）&quot;&gt;&lt;a href=&quot;#防抖（debounce）&quot; class=&quot;headerlink&quot; title=&quot;防抖（debounce）&quot;&gt;&lt;/a&gt;防抖（debounce）&lt;/h2&gt;&lt;figure class=&quot;highlight javascri
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器到底是怎么渲染页面的?</title>
    <link href="http://yoursite.com/2022/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/03/20/浏览器到底是怎么渲染页面的？/</id>
    <published>2022-03-20T02:21:23.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>当<strong>url</strong>输入到地址栏，到页面渲染完成，总共会有<strong>三个阶段</strong></p><ol><li>HTTP请求阶段</li><li>HTTP响应阶段</li><li>浏览器渲染阶段</li></ol><p>让我们来看看每个阶段到底发生了什么</p><h2 id="HTTP请求阶段"><a href="#HTTP请求阶段" class="headerlink" title="HTTP请求阶段"></a>HTTP请求阶段</h2><ol><li>在浏览器地址栏输入<strong>URL</strong>后，点击回车跳转</li><li>浏览器向服务器发起HTTP请求</li><li>DNS解析</li><li>TCP三次握手建立连接</li><li>建立连接后发起请求</li></ol><h2 id="HTTP响应阶段"><a href="#HTTP响应阶段" class="headerlink" title="HTTP响应阶段"></a>HTTP响应阶段</h2><ol><li>服务端准备资源</li><li>服务端将资源返回给浏览器</li><li>TCP四次挥手断开连接</li></ol><h2 id="浏览器渲染阶段"><a href="#浏览器渲染阶段" class="headerlink" title="浏览器渲染阶段"></a>浏览器渲染阶段</h2><ol><li>接受返回的资源</li><li>在内存中开辟出一块栈内存</li><li>解析代码（当遇到link、img、script等需要加载外部资源的文件后，开辟新的线程去加载资源文件）</li><li>解析DOM，形成DOM树，加载CSS，形成CSSOM树（DOM和CSSOM通常并行构建）</li><li>浏览器将DOM树和CSS树合并生成Render Tree（渲染树）</li><li>页面进行回流，完成基本的布局</li><li>页面进行重绘，进行样式的展示</li><li>GPU渲染整个页面</li></ol><blockquote><p>HTML与CSS的解析主要由GUI渲染线程负责，js由Javascript引擎线程负责，由于js可以操作dom元素和样式，所以如果GUI线程和Javascript引擎线程一起并行会造成冲突。因此GUI渲染线程与Javascript引擎线程是<strong>互斥</strong>的。</p><p>若解析dom时遇到script需要执行js，则会阻塞js的执行，直到css样式表加载完成</p><p>若解析dom时css已加载完毕，遇到script需要执行js，则会停止解析dom，先执行js。因此，我们最好把script放在body的最后面。</p></blockquote><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220320111120678.png" alt="image-20220320111120678"></p><h2 id="DOMContentLoaded-与-load-的区别"><a href="#DOMContentLoaded-与-load-的区别" class="headerlink" title="DOMContentLoaded 与 load 的区别?"></a>DOMContentLoaded 与 load 的区别?</h2><ul><li>当<code>DOMContentLoaded</code>事件触发时,仅当 <code>DOM 解析</code>完成后,不包括样式表,图片。我们前面提到<code>CSS 加载</code>会阻塞 <code>Dom 的渲染</code>和后面 <code>js 的执行</code>,<code>js</code>会阻塞 <code>Dom 解析</code>,所以我们可以得到结论:当文档中没有脚本时,浏览器解析完文档便能触发 <code>DOMContentLoaded</code> 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等<code>CSSOM 构建完成</code>才能执行。在任何情况下,<code>DOMContentLoaded</code> 的触发不需要等待图片等其他资源加载完成。</li><li>当 <code>onload</code> 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。</li><li><code>DOMContentLoaded</code> -&gt; <code>load</code>。</li></ul><h2 id="link标签为什么放在head标签里？"><a href="#link标签为什么放在head标签里？" class="headerlink" title="link标签为什么放在head标签里？"></a>link标签为什么放在head标签里？</h2><p>我们平时编写代码时，一般都把加载css的<code>&lt;link&gt;</code>标签都放在<code>&lt;head&gt;</code>标签中，而不是像加载js文件的<code>script</code>标签那样放在<code>body</code>中最后，这是为什么呢？</p><ol><li><strong>放在body中</strong>：DOM Tree构建完成之后便开始构建Render Tree, 并计算布局渲染网页, 等加载解析完css之后, 开始构建CSSOM Tree, 并和DOM Tree重新构建Render Tree, 重新计算布局渲染网页。</li><li><strong>放在head中</strong>：先加载css, 之后解析css构建CSSOM Tree, 于此同时构建DOMTree, CSSOM Tree和DOM Tree都构建完毕之后开始构建Render Tree, 计算布局渲染网页。</li></ol><p>对比两者, css放在<code>&lt;head&gt;</code>标签中比css放在body标签尾部少了一次构建Render Tree, 一次计算布局和一次渲染网页, 因此性能会更好; 并且css放在body标签尾部时会在网页中短暂出现”裸奔”的HTML, 这不利于用户体验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三个阶段&quot;&gt;&lt;a href=&quot;#三个阶段&quot; class=&quot;headerlink&quot; title=&quot;三个阶段&quot;&gt;&lt;/a&gt;三个阶段&lt;/h2&gt;&lt;p&gt;当&lt;strong&gt;url&lt;/strong&gt;输入到地址栏，到页面渲染完成，总共会有&lt;strong&gt;三个阶段&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript伪数组与arguments</title>
    <link href="http://yoursite.com/2022/03/19/Javascript%E4%BC%AA%E6%95%B0%E7%BB%84%E4%B8%8Earguments/"/>
    <id>http://yoursite.com/2022/03/19/Javascript伪数组与arguments/</id>
    <published>2022-03-19T13:59:01.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是伪数组？"><a href="#什么是伪数组？" class="headerlink" title="什么是伪数组？"></a>什么是伪数组？</h2><p>所谓伪数组，也称为类数组对象，指的是<code>可以通过索引属性访问元素</code>并且<code>拥有 length 属性</code>的<code>对象</code>。</p><p>以下为一个简单的伪数组的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arrFake = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;job&#x27;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它所对应的数组如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>];<br></code></pre></td></tr></table></figure><p>它们的<strong>相同点</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrFake[<span class="hljs-number">0</span>]) <span class="hljs-comment">// name</span><br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span><br>arrFake[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrFake.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>它们的<strong>不同点</strong>在于，伪数组不能调用数组原型链上的方法，且伪数组调用<code>Array.isArray</code>方法输出<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrFake.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>)  <span class="hljs-comment">// Uncaught TypeError: arrFake.push is not a function</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>); <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;]</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arrFake) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们可以用<strong>Array.from</strong>将伪数组转化为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrFake) <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]</span><br>newArr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>) <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;]</span><br></code></pre></td></tr></table></figure><blockquote><p>也可以使用<br>1.Array.prototype.slice等返回新数组的方法<br>2.扩展运算符[…arguments]</p></blockquote><p>js中的伪数组对象：</p><ul><li><code>document.getElementsByTagName</code>获取的元素标签集合</li><li>函数中的<code>arguments</code></li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>定义如下函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><br><span class="hljs-title function_">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意！箭头函数没有 arguments</p></blockquote><p>在控制台显示打印结果：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220319225005184.png" alt="image-20220319225005184"></p><p>显然，<code>arguments</code>就是一个伪数组，<code>callee</code>属性如上图所示，为函数本身，我们可以使用<code>arguments.callee()</code>的方式调用函数。</p><p>再思考一下以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">length</span>) <span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) <span class="hljs-comment">// 4</span><br>&#125;<br><br><span class="hljs-title function_">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>其中<code>function</code>本身的<code>length</code>代表行参的长度，而<code>arguments</code>的<code>length</code>代表实参的长度。</p><blockquote><p>注意！function本身的length不包括有默认值的形参和剩余参数…args</p></blockquote><h2 id="arguments的应用"><a href="#arguments的应用" class="headerlink" title="arguments的应用"></a>arguments的应用</h2><p>实现函数的重载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">doAdd</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 6</span><br><span class="hljs-title function_">doAdd</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是伪数组？&quot;&gt;&lt;a href=&quot;#什么是伪数组？&quot; class=&quot;headerlink&quot; title=&quot;什么是伪数组？&quot;&gt;&lt;/a&gt;什么是伪数组？&lt;/h2&gt;&lt;p&gt;所谓伪数组，也称为类数组对象，指的是&lt;code&gt;可以通过索引属性访问元素&lt;/code&gt;并且&lt;code
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>V8引擎的垃圾回收机制</title>
    <link href="http://yoursite.com/2022/03/10/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2022/03/10/V8引擎的垃圾回收机制/</id>
    <published>2022-03-10T13:17:51.000Z</published>
    <updated>2022-06-06T03:22:14.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Javascript内存管理"><a href="#一、Javascript内存管理" class="headerlink" title="一、Javascript内存管理"></a>一、Javascript内存管理</h2><p>JavaScript内存的流程很简单，分为3步：</p><ol><li>分配给<strong>使用者</strong>所需的内存</li><li><strong>使用者</strong>拿到这些内存，并使用内存</li><li><strong>使用者</strong>不需要这些内存了，释放并归还给系统</li></ol><p>那么这些使用者是谁呢？举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Zh&#x27;</span><br><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Zh&#x27;</span> &#125;<br>obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Zh&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><br>上面这些num，str，obj就是就是使用者，我们都知道，JavaScript数据类型分为基础数据类型和引用数据类型:</p><ul><li>基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问</li><li>引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问</li></ul><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310195900386.png" alt="image-20220310195900386"></p><ul><li>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的</li><li>由于堆内存所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存<h2 id="二、V8引擎的垃圾回收机制"><a href="#二、V8引擎的垃圾回收机制" class="headerlink" title="二、V8引擎的垃圾回收机制"></a>二、V8引擎的垃圾回收机制</h2><h3 id="为何需要垃圾回收"><a href="#为何需要垃圾回收" class="headerlink" title="为何需要垃圾回收"></a>为何需要垃圾回收</h3>在Chrome中，V8被限制了内存的使用（<strong>64位约1.4G/1464MB</strong> ，<strong> 32位约0.7G/732MB</strong>），为什么要限制呢？</li><li>表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景</li><li>深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）</li></ul><h2 id="三、V8引擎的垃圾回收算法"><a href="#三、V8引擎的垃圾回收算法" class="headerlink" title="三、V8引擎的垃圾回收算法"></a>三、V8引擎的垃圾回收算法</h2><h3 id="1-分代回收"><a href="#1-分代回收" class="headerlink" title="1.分代回收"></a>1.分代回收</h3><p>在JavaScript中，对象存活周期分为两种情况。</p><ul><li>存活周期很短：经过一次垃圾回收后，就被释放回收掉</li><li>存活周期很长：经过多次垃圾回收后，他还存在，赖着不走</li></ul><p>那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？</p><p>对于这个问题，V8做了<strong>分代回收</strong>的优化方法，通俗点说就是：<strong>V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方</strong></p><p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p><p><code>副垃圾回收器 + Scavenge算法</code>：主要负责新生代的垃圾回收<br><code>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法</code>：主要负责老生代的垃圾回收</p><h3 id="1-1-新生代"><a href="#1-1-新生代" class="headerlink" title="1.1 新生代"></a>1.1 新生代</h3><p>在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。<br><code>Scavange</code>算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310205820365.png" alt="image-20220310205820365"></p><p>具体步骤为以下4步：</p><ol><li>标记活动对象和非活动对象</li><li>复制<code>from-space</code>的活动对象到<code>to-space</code>中并进行排序</li><li>清除<code>from-space</code>中的非活动对象</li><li>将<code>from-space</code>和<code>to-space</code>进行角色互换，以便下一次的<code>Scavenge</code>算法垃圾回收</li></ol><p>那么，垃圾回收器是怎么知道哪些对象是活动对象，哪些是非活动对象呢？</p><p>这就要不得不提一个东西了——<code>可达性</code>。什么是可达性呢？就是从初始的<code>根对象（window或者global）</code>的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。</p><p>新生代中的对象什么时候变成老生代的对象？</p><p>在新生代中，还进一步进行了细分。分为<code>nursery子代</code>和<code>intermediate</code>子代两个区域，一个对象第一次分配内存时会被分配到新生代中的<code>nursery子代</code>，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到<code>intermediate子代</code>，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为<code>晋升</code></p><h3 id="1-2老生代"><a href="#1-2老生代" class="headerlink" title="1.2老生代"></a>1.2老生代</h3><p>新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用<code>Scavenge</code>算法，为啥呢，有以下原因：</p><ul><li>cavenge`算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低</li><li>cavenge<code>算法是以空间换时间的算法，老生代是内存很大的空间，如果使用</code>Scavenge`法，空间资源非常浪费，得不偿失啊。。</li></ul><p>所以老生代里使用了Mark-Sweep算法(标记清理)和Mark-Compact算法(标记整理)</p><h3 id="Mark-Sweep-标记清理"><a href="#Mark-Sweep-标记清理" class="headerlink" title="Mark-Sweep(标记清理)"></a>Mark-Sweep(标记清理)</h3><p><code>Mark-Sweep</code>两个阶段，标记和清理阶段，之前的<code>Scavenge算法</code>标记和清理，但是<code>Mark-Sweep算法</code>跟Scavenge算法的区别是，后者需要复制后再清理，前者不需要，<code>Mark-Sweep</code>直接标记活动对象和非活动对象之后，就直接执行清理了。</p><ul><li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li><li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/e8767d07d348429d8205e33c77637c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></li></ul><p>由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多零零散散的空位。</p><h3 id="Mark-Compact-标记整理"><a href="#Mark-Compact-标记整理" class="headerlink" title="Mark-Compact(标记整理)"></a>Mark-Compact(标记整理)</h3><p><code>Mark-Sweep算法</code>执行垃圾回收之后，留下了很多<code>零零散散的空位</code>，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从<code>零零散散的空位</code>中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是<code>Mark-Sweep算法</code>的一个缺点<br>这个时候<code>Mark-Compact算法</code>出现了，他是<code>Mark-Sweep算法</code>的加强版，在Mark-Sweep算法的基础上，加上了<code>整理阶段</code>，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/f7da553309a04432ba93840a1c06ca36~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="2-全停顿-Stop-The-World"><a href="#2-全停顿-Stop-The-World" class="headerlink" title="2. 全停顿(Stop-The-World)"></a>2. 全停顿(Stop-The-World)</h3><p>说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，<code>垃圾回收优先于代码执行</code>，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为<code>全停顿</code></p><p>由于新生代空间小，并且存活对象少，再配合<code>Scavenge算法</code>顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了<code>卡顿现象</code></p><h3 id="3-Orinoco优化"><a href="#3-Orinoco优化" class="headerlink" title="3. Orinoco优化"></a>3. Orinoco优化</h3><p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决<code>全停顿问题</code>,它提出了<code>增量标记、懒性清理、并发、并行</code>的优化方法。</p><h3 id="3-1-增量标记-Incremental-marking"><a href="#3-1-增量标记-Incremental-marking" class="headerlink" title="3.1 增量标记(Incremental marking)"></a>3.1 增量标记(Incremental marking)</h3><p>咱们前面不断强调了<code>先标记，后清除</code>，而增量标记就是在<code>标记</code>这个阶段进行了优化。我举个生动的例子：路上有很多<code>垃圾</code>，害得<code>路人</code>都走不了路，需要<code>清洁工</code>打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。</p><p>大家把上面例子里，<code>清洁工清理垃圾的过程——标记过程，路人——JS代码</code>，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：<code>标记一点，JS代码运行一段</code>，从而提高效率</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/a5719b8cec604c98b5d55a39df776fb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="3-2-惰性清理-Lazy-sweeping"><a href="#3-2-惰性清理-Lazy-sweeping" class="headerlink" title="3.2 惰性清理(Lazy sweeping)"></a>3.2 惰性清理(Lazy sweeping)</h3><p>上面说了，增量标记只是针对<code>标记</code>阶段，而惰性清理就是针对<code>清除</code>阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就<code>延迟了清理</code>，让JS代码先执行，或者<code>只清理部分垃圾</code>，而不清理全部。这个优化就叫做<code>惰性清理</code><br>整理标记和惰性清理的出现，大大改善了<code>全停顿</code>现象。但是问题也来了：增量标记是<code>标记一点，JS运行一段</code>，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成<code>对象引用改变，标记错误</code>现象。这就需要使用<code>写屏障</code>技术来记录这些引用关系的变化</p><h3 id="3-3-并发-Concurrent"><a href="#3-3-并发-Concurrent" class="headerlink" title="3.3 并发(Concurrent)"></a>3.3 并发(Concurrent)</h3><p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行<code>写屏障</code>操作。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/204846e6d5614529b71bc67114c2b6df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="3-4-并行"><a href="#3-4-并行" class="headerlink" title="3.4 并行"></a>3.4 并行</h3><p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/d55ad43196a34c8b996aa21f2e1dabf7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h2 id="V8当前的垃圾回收机制"><a href="#V8当前的垃圾回收机制" class="headerlink" title="V8当前的垃圾回收机制"></a>V8当前的垃圾回收机制</h2><p>2011年，V8应用了<code>增量标记机制</code>。直至2018年，Chrome64和Node.js V10启动<code>并发标记（Concurrent）</code>，同时在并发的基础上添加<code>并行（Parallel）技术</code>，使得垃圾回收时间大幅度缩短。</p><h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从<code>from-to</code>复制到<code>space-to</code>的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/ca66013ea62f4637bd57744a5e62326f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，<code>写屏障（write barriers）</code>技术会在辅助线程在进行并发标记的时候进行追踪。</p><p>当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/97a854ba9a464ba8adf143a5612ad91c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Javascript内存管理&quot;&gt;&lt;a href=&quot;#一、Javascript内存管理&quot; class=&quot;headerlink&quot; title=&quot;一、Javascript内存管理&quot;&gt;&lt;/a&gt;一、Javascript内存管理&lt;/h2&gt;&lt;p&gt;JavaScript内存的流
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="V8" scheme="http://yoursite.com/tags/V8/"/>
    
      <category term="垃圾回收机制" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Javascript如何避免内存泄漏</title>
    <link href="http://yoursite.com/2022/03/10/Javascript%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2022/03/10/Javascript如何避免内存泄漏/</id>
    <published>2022-03-10T12:49:51.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何监控内存状况"><a href="#一、如何监控内存状况" class="headerlink" title="一、如何监控内存状况"></a>一、如何监控内存状况</h2><p>这里借用一下<a href="https://juejin.cn/user/1292681407377624">林三心</a>大佬的图文。</p><h3 id="浏览器任务管理器"><a href="#浏览器任务管理器" class="headerlink" title="浏览器任务管理器"></a>浏览器任务管理器</h3><p>打开方式：在浏览器顶部右键，打开任务管理器：</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310164329157.png" alt="image-20220310164329157"></p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310164734409.png" alt="image-20220310164734409"></p><p>打开后，可以看到内存和JavaScript内存：</p><ul><li>内存：页面里的原始内存，也就是<strong>DOM节点</strong>的总占用内存</li><li>JavaScript内存(括号里)：是该页面中所有<strong>可达对象</strong>的总占用内存</li></ul><p>那什么是<strong>可达对象</strong>呢？简单说就是：就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，搜不到，说明该子节点对象不可达。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可达，可以通过window.name访问</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Zh&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> () &#123;<br>    <span class="hljs-comment">// 不可达，访问不了</span><br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Zh&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到我们的任务管理，此时我们在页面中编写一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><br>点击前：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165143724.png" alt="image-20220310165143724"><br>点击后，发现内存瞬间上升：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165024376.png" alt="image-20220310165024376"></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>使用Chrome浏览器的<strong>无痕模式</strong>，是为了避免很多其他因素，影响咱们查看内存：</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165336577.png" alt="image-20220310165336577"></p><p>按F12打开调试窗口，选择<strong>Performance</strong></p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165416413.png" alt="image-20220310165416413"></p><p>咱们就以掘金首页为例吧！<strong>点击录制 -&gt; 刷新掘金 -&gt; 点击stop</strong>，可以看到以下指标随着时间的<code>上下波动</code>：</p><ul><li><p><code>JS Heap</code>：JS堆</p></li><li><p><code>Documents</code>: 文档</p></li><li><p><code>Nodes</code>: DOM节点</p></li><li><p><code>Listeners</code>: 监听器</p></li><li><p><code>GPU Memory</code>: GPU内存</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/1c8bc35ae2c64dc692fe94a925c0ed5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="juejinperf.gif"></p></li></ul><h3 id="堆快照"><a href="#堆快照" class="headerlink" title="堆快照"></a>堆快照</h3><p><strong>堆快照</strong>，顾名思义，就是将当前某一个页面的堆内存拍下照片存起来，同一个页面，执行某个操作前，录制堆快照是一个样，有可能执行完后，录制的堆快照又是另外一个样。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165725251.png" alt="image-20220310165725251"></p><p>还是以<strong>掘金首页</strong>为例，可以看到当前页面内存为<strong>13.3M</strong>，咱们可以选择<strong>Statistics</strong>，查看<strong>数组，对象，字符串</strong>等所占内存。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/f3159441afe843c4b36993f9db54d19b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="掘金堆快照.gif"></p><h2 id="二、内存泄漏的场景"><a href="#二、内存泄漏的场景" class="headerlink" title="二、内存泄漏的场景"></a>二、内存泄漏的场景</h2><p>下面列举了可能会造成<strong>内存泄漏</strong>的情况：</p><ol><li>闭包使用不当引起内存泄漏</li><li>全局变量</li><li>分离的DOM节</li><li>控制台的打印</li><li>未清除的定时器<br>接下来我们一一来介绍这些情况。</li></ol><h3 id="1-闭包使用不当"><a href="#1-闭包使用不当" class="headerlink" title="1.闭包使用不当"></a>1.闭包使用不当</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br><br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">let</span> a = []<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    a.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn1</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中<strong>f1</strong>被调用后，从<strong>可达性</strong>的角度来说，<strong>arr</strong>应该被回收，但实际上并不是这样的。<strong>f1</strong>将<strong>arr</strong>return之后，<strong>arr</strong>被<strong>push</strong>进了数组<strong>a</strong>，而数组<strong>a</strong>是一个全局变量，并不会被回收，这就导致了<strong>arr</strong>不会被回收。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量一般不会被垃圾回收机制回收。当然，这并不意味着完全禁止我们定义全局变量，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 此处变量arr未被声明</span><br>    arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br>&#125;<br><span class="hljs-title function_">fn1</span>()<br></code></pre></td></tr></table></figure><p>上述代码会自动在全局创建一个变量<strong>arr</strong>，并将数组赋值给<strong>arr</strong>，由于是全局变量，所以<strong>arr</strong>的内存一直不会释放。</p><p>因此，我们平时需多加注意，不要在变量未声明前赋值，或者也可以开启严格模式，这样就会在不知情犯错时，收到报错警告，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>    name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br>&#125;<br><br><span class="hljs-title function_">fn1</span>()<br></code></pre></td></tr></table></figure><h3 id="3-分离的dom节点"><a href="#3-分离的dom节点" class="headerlink" title="3.分离的dom节点"></a>3.分离的dom节点</h3><p>让我们用代码来解释一下什么为<strong>分离的dom节点</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(btn)<br></code></pre></td></tr></table></figure></p><p>如上所示，虽然最后把<strong>button</strong>给删除了，但是因为全局变量<strong>btn</strong>对此<strong>DOM对象</strong>引用着，导致此<strong>DOM对象</strong>一直没有被回收，这个<strong>DOM对象</strong>就称为<strong>分离DOM</strong></p><p>这个问题很好解决，删除button后，顺便把btn设置成null就行了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(btn)<br>btn = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></p><h3 id="4-控制台的打印"><a href="#4-控制台的打印" class="headerlink" title="4.控制台的打印"></a>4.控制台的打印</h3><p>控制台的打印也会造成内存泄漏吗？？？是的呀，如果浏览器不一直保存着我们打印对象的信息，我们为何能在每次打开控制的Console时看到具体的数据呢？先来看一段测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;按钮&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100000</span>)</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.log(obj);</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml">    &#125;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>当我们点击按钮时，这个<strong>arr</strong>会被控制台打印下来，浏览器一直保存着这个<strong>arr</strong>的信息，并不会被垃圾回收机制回收。</p><p>虽然<strong>console.log</strong>便于调试，但是我们在<strong>生产环境</strong>，我们尽可能不要在控制台打印数据，所以我们经常会在代码中看到类似如下的操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果在开发环境下，打印变量obj</span><br><span class="hljs-keyword">if</span>(isDev) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br>&#125;<br></code></pre></td></tr></table></figure><br>这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了<strong>console.log</strong>之外，<strong>console.error</strong>、<strong>console.info</strong>、<strong>console.dir</strong>等等都不要在生产环境下使用</p><h3 id="5-未清除的定时器"><a href="#5-未清除的定时器" class="headerlink" title="5.未清除的定时器"></a>5.未清除的定时器</h3><p>下面这段代码中，执行完<strong>fn1</strong>函数，按理说<strong>arr</strong>数组会被回收，但是他却回收不了。为什么呢？因为定时器里的<strong>a</strong>引用着<strong>arr</strong>，并且定时器不清除的话，<strong>a</strong>就不会被回收，<strong>a</strong>不回收就会一直引用着<strong>arr</strong>，那么<strong>arr</strong>肯定也回收不了了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;Sunshine_Lin&#x27;</span>)<br>      <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> a = arr<br>     &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>处理的方法也很简单，只要我们清除定时器就行了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;Sunshine_Lin&#x27;</span>)<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>)  <span class="hljs-built_in">clearInterval</span>(timer)<br>    <span class="hljs-keyword">let</span> a = arr<br>    i++<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在项目过程中，如果遇到了某些性能问题可能跟内存泄漏有关时，就可以参照以上列举的5种情况去排查。</p><p>虽然JavaScript的垃圾回收是自动的，但我们有时也是需要考虑要不要手动清除某些变量的内存占用的，例如你明确某个变量在一定条件下再也不需要，但是还会被外部变量引用导致内存无法得到释放时，你可以用null对该变量重新赋值就可以在后续垃圾回收阶段释放该变量的内存了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6995706341041897486">赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！</a><br><a href="https://juejin.cn/post/6996828267068014600">哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了</a><br><a href="https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、如何监控内存状况&quot;&gt;&lt;a href=&quot;#一、如何监控内存状况&quot; class=&quot;headerlink&quot; title=&quot;一、如何监控内存状况&quot;&gt;&lt;/a&gt;一、如何监控内存状况&lt;/h2&gt;&lt;p&gt;这里借用一下&lt;a href=&quot;https://juejin.cn/user/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中isNaN和Numer.isNaN的区别</title>
    <link href="http://yoursite.com/2022/03/09/Javascript%E4%B8%ADisNaN%E5%92%8CNumer.isNaN%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2022/03/09/Javascript中isNaN和Numer.isNaN的区别/</id>
    <published>2022-03-09T02:32:01.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p>当我们将参数传入<strong>isNaN</strong>时，它的内部实现调用了<strong>Number()</strong>方法将参数转换为Number类型，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>若能成功转换为Number类型，<strong>isNaN</strong>返回false，否则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><blockquote><p>Javascript中0 / 0返回的是NaN，而非0数值除以0返回的是Infinity</p></blockquote><h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h3><p><strong>判断传入的参数是否严格等于NaN（也就是===）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>使用场景：判断某个运算的结果是否为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">value</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>();<br>&#125;<br><span class="hljs-title function_">check</span>(<span class="hljs-number">1</span> / <span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;isNaN&quot;&gt;&lt;a href=&quot;#isNaN&quot; class=&quot;headerlink&quot; title=&quot;isNaN()&quot;&gt;&lt;/a&gt;isNaN()&lt;/h3&gt;&lt;p&gt;当我们将参数传入&lt;strong&gt;isNaN&lt;/strong&gt;时，它的内部实现调用了&lt;strong&gt;Numbe
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域？动态作用域？闭包是如何产生的？</title>
    <link href="http://yoursite.com/2022/03/08/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/03/08/词法作用域？动态作用域？闭包是如何产生的？/</id>
    <published>2022-03-08T11:50:03.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域，就是说跟我们写代码时将变量定义在哪个函数作用域或者块作用域中有关系，大多数情况是不变的（evel/with会修改）<img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220308203325592.png" alt="image-20220308203325592"></p><blockquote><p>图片来自《你不知道的Javascript》</p></blockquote><ol><li>包含着全局作用域，包括标识符foo</li><li>包含着foo所创建的作用域，包括标识符：a,bar和b</li><li>包含着bar所创建的作用域, 包括标识符c<br>无论函数在哪里被调用，它的词法作用域都只有函数被声明时所处的位置决定。</li></ol><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>首先我们先了解一下什么是动态作用域，再看闭包与它的区别。</p><p><strong>动态作用域</strong>就是说当查询标识符的时候不是按照词法作用域嵌套来查找，而是按照调用顺序来查找的， 也就是说 动态作用域不关注你在什么地方声明，它只关心是在何处调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span> <br>  <span class="hljs-title function_">foo</span>()<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> <br><br><span class="hljs-title function_">bar</span>() <span class="hljs-comment">// 3 不是2</span><br></code></pre></td></tr></table></figure><blockquote><p>事实上输出的是2，JavaScript并不具有动态作用域,它只有词法作用域,简单明了,但是this机制某种程度上很像动态作用域</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当函数<strong>可以记住并访问所在的词法作用域</strong>时，就产生了<strong>闭包</strong>，即使函数是在当前词法作用域之外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar<br>&#125;<br><br><span class="hljs-keyword">let</span> baz = <span class="hljs-title function_">foo</span>()<br><span class="hljs-title function_">baz</span>() <span class="hljs-comment">// 2 </span><br></code></pre></td></tr></table></figure><p>上述代码中<strong>foo()</strong>执行之后返回一个内部函数<strong>bar</strong>，然后被赋值给了<strong>baz</strong>，当<strong>baz</strong>被调用时实际上就是调用了<strong>bar</strong>，输出了函数<strong>foo</strong>作用域中的变量<strong>a</strong>。</p><p><strong>无论使用何种方式对函数类型的值传递，当函数在其他作用域被调用时都可以理解为闭包。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;词法作用域&quot;&gt;&lt;a href=&quot;#词法作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h2&gt;&lt;p&gt;词法作用域就是定义在词法阶段的作用域，就是说跟我们写代码时将变量定义在哪个函数作用域或者块作用域中有关系，大多数情况
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的事件循环机制(event loop)</title>
    <link href="http://yoursite.com/2022/03/04/Javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6(event%20loop)/"/>
    <id>http://yoursite.com/2022/03/04/Javascript的事件循环机制(event loop)/</id>
    <published>2022-03-04T13:47:33.000Z</published>
    <updated>2022-06-06T03:22:14.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Javascript引擎的特点：单线程与非阻塞"><a href="#一、Javascript引擎的特点：单线程与非阻塞" class="headerlink" title="一、Javascript引擎的特点：单线程与非阻塞"></a>一、Javascript引擎的特点：单线程与非阻塞</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><blockquote><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p></blockquote><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。非阻塞是通过事件循环机制实现的。JS通常是非阻塞的，除了某些特殊情况，JS会停止代码执行。</p><h2 id="二、事件循环（Event-Loop）"><a href="#二、事件循环（Event-Loop）" class="headerlink" title="二、事件循环（Event Loop）"></a>二、事件循环（Event Loop）</h2><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>单线程意味着所有任务需要排队，如果前一个任务耗时很长，就会对后续任务造成阻塞。</p><p>如果造成阻塞的任务是因为计算量大，那么情有可原，毕竟CPU的利用率高，但如果是等待IO设备的响应，那么这种情况下CPU利用率很低，那显然是不合理的。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><blockquote><p>（1） 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><p>下图就是主线程和任务队列的示意图。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220304213510129.png" alt=""></p><h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><p>以一道经典的面试题为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);   <br>  &#125;,<span class="hljs-number">0</span>); <br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题的结果为：3，3，3</p><blockquote><p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p></blockquote><p>然而，即使第二个参数真实值也为0ms，答案依然为3，3，3。如前面所述，setTimeout()将事件插入了”任务队列“，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()</li><li>setImmediate(Node.js 环境)</li></ul><p>以下事件属于微任务：</p><ul><li>Promise.then</li><li>Object.observe</li><li>MutationObserver</li><li><p>process.nextTick(Node.js 环境)</p><p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><blockquote><p>微任务在本轮“事件循环”结束时执行，宏任务在下一轮“事件循环”开始时执行。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Javascript引擎的特点：单线程与非阻塞&quot;&gt;&lt;a href=&quot;#一、Javascript引擎的特点：单线程与非阻塞&quot; class=&quot;headerlink&quot; title=&quot;一、Javascript引擎的特点：单线程与非阻塞&quot;&gt;&lt;/a&gt;一、Javascrip
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：TwoStreamVAN</title>
    <link href="http://yoursite.com/2020/12/25/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9ATwoStreamVAN/"/>
    <id>http://yoursite.com/2020/12/25/论文速读：TwoStreamVAN/</id>
    <published>2020-12-25T03:13:07.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_WACV_2020/papers/Sun_TwoStreamVAN_Improving_Motion_Modeling_in_Video_Generation_WACV_2020_paper.pdf">TwoStreamVAN: Improving Motion Modeling in Video Generation</a></p></blockquote><p><img src="https://i.loli.net/2020/12/24/QuJrB95NZzkI42s.png" alt=""></p><p>像素级视频预测[27，36，40]和生成方法的一个主要问题是，它们试图在单个纠缠生成器中对静态内容和动态运动进行建模，而不管它们是否在潜在空间中解开运动和内容\</p><p>本文认为在解码阶段分离运动和内容建模是至关重要的。一方面，它消除了内容生成过程中的运动干扰，并产生了更好的内容结构。另一方面，单独的运动建模有助于在整个序列中一致地产生与动作相关的运动。</p><p>本文提出了一个新的<strong>TwoStreamVAN</strong>，它从一个动作标签和一个分离的噪声向量生成一个视频，如上x`图所示。通过两个并行的生成器，分别处理内容和运动，并将它们融合在一起以预测下一帧，而不是高估单个生成器的能力（如MoCoGAN的做法）。</p><p>直观地说，运动通常以其局部上下文窗口内的空间信息为条件，例如，在做跳跃动作时，手臂和腿部附近的不同运动。因此，我们将运动和内容的融合定义为对每个位置唯一的像素值的学习细化。为了精确地生成多尺度运动，我们在具有几个不同分辨率的中间内容层上进行这种细化。此外，我们还引入了运动蒙版，使运动聚焦于它所在的区域。</p><p>本文将引入<strong>图像级监控（image-levelsupervision）</strong>，虽然<strong>MoCoGAN</strong>尝试了图像级监控缺效果甚微，因为内容生成仍然受到单个共享生成器中运动建模的影响。本文使用的双流生成器的关键优势是能分别学习每个流，从而更准确。我们通过图像级监控完全了解其自身生成器中的图像结构，这显著提高了内容生成性能。训练有素的内容生成进一步有利于视频级监控中的动作学习。</p><p>本文贡献如下：</p><ul><li>我们提出了一个视频生成模型TwoStreamVAN和一个更有效的学习方案，解决了生成阶段的运动和内容问题。</li><li>我们设计了一种多尺度运动融合机制，并通过对空间环境的调节进一步改进了运动建模</li><li>我们创建了一个大规模的合成视频生成数据集，供研究团体使用</li><li>我们在四个视频数据集上通过定量和定性分析评估了我们的模型（通过用户研究），并证明了强于几个强基线的结果。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>本文结合了<strong>VAE</strong>和<strong>GAN</strong>，提出了一个<strong>变分对抗网络(VAN)</strong>来学习一个可解释的潜在空间以及生成现实的图像。鉴于<strong>VAN</strong>在图像生成方面的成功，我们在此将其用于视频生成。</p><p>MoCoGAN试图通过从单独的潜在空间中采样来解开内容和运动，但是使用单个生成器来一起解码这两个潜在代码。为了克服统一生成过程中无效的运动建模和随之而来的内容恶化，我们进一步引入了分离的内容和运动生成器来分别对空间结构和时间动态进行建模。</p><h2 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3. Approach"></a>3. Approach</h2><p>我们引入了一个双流变分对抗网络(图2)，它生成一个给定输入动作标签和随机噪声向量的视频。我们定义动作条件视频生成如下。假设我们有<strong>K</strong>个不同的动作类。在每个类别<strong>k ∈ 1: K</strong> 的情况下，<script type="math/tex">C_{k}</script>为该类别训练视频的数量。使<script type="math/tex">V_{k}</script> = {<script type="math/tex">V_{i,k}, \forall i \in 1:C_{k}</script>}为类别<strong>k</strong>视频的集合，<script type="math/tex">v_{i,k}</script>={<script type="math/tex">x_{1},x_{2},...,x_{T}</script>}为一个T帧的短视频。任务是定义一个函数<strong>G</strong>，该函数根据来自潜在向量<script type="math/tex">\epsilon</script> ∈ <script type="math/tex">ℝ^{N}</script>，给定类别标签k，生成可信的视频<script type="math/tex">\hat{v}</script>，即<script type="math/tex">\hat{v} = G(k,\epsilon)</script></p><p>我们将潜在空间<script type="math/tex">\epsilon</script>分解成两个独立的代码:内容代码<script type="math/tex">\epsilon_{c}</script>∈ <script type="math/tex">ℝ^{C}</script>和动作代码<script type="math/tex">\epsilon_{m}</script>∈<script type="math/tex">ℝ^{M}</script>，N = C + M.我们还将视频生成函数<strong>G</strong>分解为两个独立的内容和运动函数($ G<em>{c} $和$ G</em>{m} $)，与以前使用单个生成器的工作形成对比，我们设计了一种新的多尺度融合机制。</p><p><img src="https://i.loli.net/2020/12/24/XulgzWHeoixMRTb.png" alt=""></p><h3 id="3-1-Two-Stream-Generation"><a href="#3-1-Two-Stream-Generation" class="headerlink" title="3.1 Two-Stream Generation"></a>3.1 Two-Stream Generation</h3><p>为了学习内容和运动建模的生成函数$ G<em>{c} $和$ G</em>{m} $，我们引入了两个独立的、在几个阶段具有交互作用的以动作为条件的VAN streams。每个steam包含一个<strong>Encoder</strong>，一个<strong>Generator</strong>和一个<strong>Discriminator</strong>，其中<strong>Encoder</strong>和<strong>Generator</strong>作为<strong>VAE</strong>的自动编码器，<strong>Generator</strong>和<strong>Discriminator</strong>组成了<strong>GAN</strong></p><p><strong>Content VAN Stream</strong>由内容编码器$ E<em>{c} $、内容生成器$ G</em>{c} $和图像鉴别器$ D<em>{I} $组成，在观察了<strong>x</strong>之后，生成了后验内容潜在分布$ q(z</em>{c}|x,k) $，这接近于它的真实先验分布$ p(z<em>{c}|k) $.$ G</em>{c} $将采样自内容分布的的内容向量$ \epsilon<em>{c} $解码成帧。$ D</em>{I} $鉴别帧的真假以鼓励$ G_{c} $生成更真实的图像。</p><p>类似地，<strong>Motion VAN Stream</strong>由运动编码器$ E<em>{m} $、运动生成器$ G</em>{m} $和视频鉴别器$ D<em>{V} $组成，在我们的方法中，$ E{m} $不是对空间内容进行编码，而是对相邻帧之间的差异图$ \triangle x $的时间动态进行编码。它产生的后验运动潜在分布$ q(z</em>{m}|\triangle x,k) $接近其真实的先验分布$ p(z<em>{m}|k) $.<strong>convLSTM</strong>对运动历史进行累积，并生成当前运动，嵌入$ e</em>{m} $，从所有先前时间步长的运动分布中接收$ \epsilon<em>{m} $序列。$ G</em>{m} $通过$ \epsilon<em>{c} $和$ e</em>{m} $在不同的尺度上产生运动。我们通过将生成的运动与<strong>T</strong>时间步长的相应内容融合来生成每个视频$ \hat{v} $。$ D<em>{V} $对真实/生成的视频进行了分类，并对他们的行为进行了分类，以鼓励$ G</em>{m} $生成逼真的动作</p><h3 id="Multi-scale-Motion-Generation-and-Fusion"><a href="#Multi-scale-Motion-Generation-and-Fusion" class="headerlink" title="Multi-scale Motion Generation and Fusion"></a>Multi-scale Motion Generation and Fusion</h3><p>在像素(a, b)处，运动通常发生在相邻帧之间的局部窗口内。受帧插值空间卷积的启发，我们将运动表示为当前像素值基础局部上下文的细化，并通过空间自适应卷积将这种运动与内容融合。此外，我们提出了一种新的多尺度融合机制来克服其方法的缺点，即:1)由于在全分辨率图像上执行单个融合步骤而导致的多尺度运动的无效建模，以及2)由于用于表示最大可能运动的大卷积核而导致的对存储器的高需求。</p><p><img src="https://i.loli.net/2020/12/24/4NQFA9ECBtfpxza.png" alt=""></p><p>为了生成精确的运动，$ G<em>{m} $将解开的内容和运动嵌入($ \epsilon</em>{c} $和$ e<em>{m} $)作为输入。在$ G</em>{m} $中，不同尺度的运动将相应的隐藏层分开:大的运动来自低分辨率层，小的运动来自高分辨率层。在每一层，$ G_{m} $将当前特征映射为:1)以具有尺寸n的像素方式的2D核的形式计算运动(像素细化);2)识别运动遮罩中包含实际运动的区域；3)生成下一层的运动图。为了将运动与内容融合，仅当像素位于运动被激活的区域中时，我们才分别将生成的2D核与以相应像素为中心的面片进行卷积(即，执行空间自适应卷积)(参见上图)。</p><p>具体来说，假设我们把运动分成<strong>S</strong>个尺度。对于每个尺度的<strong>s</strong>，让$ l<em>{s} $为相对应的分辨率隐藏层，$ w^{s} ∈ ℝ^{l</em>{s}×l<em>{s}×n^{2}} $为$ G</em>{m} $产生的卷积核，$ h<em>{c}^{s} ∈ ℝ^{l</em>{s} × l<em>{s} × d</em>{s}} $为相对应的内容层，其中$ d<em>{s} $是内容特征维度。我们在以下步骤中执行空间自适应卷积。首先，对于每个位置(a,b)，我们从展开形式$ w^{s}(a,b) $恢复一个2D卷积核$ K^{s}(a,b) $.然后，我们将$ K^{s}(a,b) $与在$ h</em>{c}^{s} $的补丁$ P^{s}(a,b) ∈ ℝ^{n×n×d<em>{s}} $做卷积运算来生成一个位置(a,b)中间内容表示 $ \tilde{h}</em>{c}^{s}(a,b) $:</p><p><img src="https://i.loli.net/2020/12/25/F4I7zgub9ahVnft.png" alt="image-20201225105952830"></p><p>我们通过向较小的层添加自适应卷积来处理较大的运动，而[29]则通过增加核大小来处理较大的运动。由于要存储和建模的参数数量在核大小中是平方的，因此在我们的多尺度融合框架中，我们通过对所有层利用小核(푛=3或5)来显著降低内存使用量和模型复杂度</p><p>为了$ G<em>{m} $的注意力集中学习尺度<strong>s</strong>在实际发生的区域的运动上，我们预测了一个带有$ w^{s} $的运动遮罩$ M^{s} ∈ ℝ^{l</em>{s}×l<em>{s}} $，以识别这样的区域。每个$ M^{s} $的的值都在[0，1]中。我们在$ M^{s}(a,b) $:的指导下通过融合运动从$ h</em>{c}^{s}(a,b) $和 $ \tilde{h}<em>{c}^{s}(a,b) $生成了新的内容$ \hat{h}</em>{c}^{s} $：</p><p><img src="https://i.loli.net/2020/12/25/NLE6c9F4XHe2CaY.png" alt="image-20201225110922089"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：G3AN</title>
    <link href="http://yoursite.com/2020/12/24/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AG3AN/"/>
    <id>http://yoursite.com/2020/12/24/论文速读：G3AN/</id>
    <published>2020-12-24T03:53:37.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Wang_G3AN_Disentangling_Appearance_and_Motion_for_Video_Generation_CVPR_2020_paper.pdf">G3AN: Disentangling Appearance and Motion for Video Generation</a></p></blockquote><p>在推断和建模人类视频的分布时，生成模型面临三个主要挑战:(a)生成不确定运动，(b)在整个生成的视频中保持人类外观，以及(c)建模时空一致性。</p><p>本文提出了一个新的被简化的生成模型<script type="math/tex">G^{3}AN</script>，以学习视频生成因子外观和运动的解纠结表示，允许对两者进行操作。解纠缠表示被定义为单个潜在单位对单个生成因素的变化敏感，而对其他因素的变化相对不变[4]。在这种情况下，我们的G3AN被赋予了一个<strong> three-stream</strong>生成器架构，其中主流编码时空视频表示，由两个辅助流增强，表示独立的生成因子外观和运动。针对高级功能图的<strong>self-attention</strong>机制可确保令人满意的视频质量。</p><p><script type="math/tex">G^{3}AN</script>因此能够通过遵循训练分布而不需要额外的输入来生成逼真的视频(应对挑战(a)和(c))，并且能够分离地操纵外观和运动，同时强调保持外观(挑战(b))。</p><p>本文的技术贡献包括以下内容：</p><ul><li><p>一种新的生成模型G3AN，它试图从人类视频数据中学习生成外观和运动因素的解纠缠表示。这些表示允许对这两个因素进行单独操作。</p></li><li><p>一种新颖的<strong>three-stream</strong>生成器，它同时考虑了个体外观特征(空间流)、运动特征(时间流)和平滑生成的视频(主流)的学习</p></li><li><p>一种新的<strong>factorized spatio-temporal self-attention(F-SA)</strong>被认为是第一个应用于视频生成的<strong>self-attention</strong>模块，用于对全局时空表示进行建模，提高生成视频的质量。</p></li><li><p>广泛的定性和定量评估，证明了G3AN在一系列数据集上系统地、显著地优于最先进的基线。</p></li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>虽然视频生成任务旨在生成真实的时间动态，但这些任务会随着条件作用的水平而变化。我们有基于与运动或外观相关的附加先验的视频生成，相反，视频生成仅遵循训练分布。我们注意到，从建模的角度来看，后者更具挑战性，因为缺少关于例如生成的视频的结构的附加输入。因此，迄今为止的大多数方法都包含某种<strong>条件作用</strong>。</p><p><strong>Video generation from noise</strong>。从噪声中直接生成视频需要捕获数据集分布并对其建模。最接近本文工作的是<strong>MoCoGAN</strong>，它将每一帧的潜在表现分解为运动和内容，旨在控制这两个因素。然而，<strong>MoCoGAN</strong>和<script type="math/tex">G^{3}AN</script>之间有两个关键的区别。首先，<strong>MoCoGAN</strong>不是对每个视频只采样两个噪声矢量，而是采样一系列噪声矢量作为运动，一个固定的噪声作为内容。然而，为每一帧引入随机噪声来表示运动增加了学习难度，因为模型必须将这些噪声向量映射到生成的视频中的连续人体运动。因此，MoCoGAN逐渐忽略输入噪声，并倾向于产生类似的运动。</p><h2 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3.Approach"></a>3.Approach</h2><p>在这项工作中，我们提出了<script type="math/tex">G^{3}AN</script>，一种新颖的GAN架构，旨在从两个噪声矢量<script type="math/tex">z_{a}</script> ∈ <script type="math/tex">Z_{A}</script>和<script type="math/tex">z_{m}</script>∈ <script type="math/tex">Z_{M}</script>(分别代表外观和运动)中以分离的方式生成视频。<script type="math/tex">G^{3}AN</script>由一个三流发生器<strong>G</strong>和一个双流鉴别器<strong>D</strong>组成，如下图所示。<strong>G</strong>的目标是生成能够同时调节外观和运动的视频，而<strong>D</strong>则分别在视频和帧中区分生成的样本和真实数据。</p><p><img src="https://i.loli.net/2020/12/24/DqKO3zug159r7da.png" alt=""></p><p><img src="https://i.loli.net/2020/12/24/SHYvbkaCuUIN7rw.png" alt=""></p><h3 id="3-1-Generator"><a href="#3-1-Generator" class="headerlink" title="3.1 Generator"></a>3.1 Generator</h3><p>我们在<script type="math/tex">G^{3}</script>模块的层次结构中设计<strong>G</strong>。具体来说，我们有<code>N</code>个层次，表示为<script type="math/tex">G_{n=0...N-1}^{3}</script>。第一个<script type="math/tex">G^{3}</script>模块<script type="math/tex">G_{0}^{3}</script>接受两个噪声矢量<script type="math/tex">z_{a}</script>和<script type="math/tex">z_{m}</script>作为输入。其余模块<script type="math/tex">G_{n=1...N-1}^{3}</script>，继承三个特征映射<script type="math/tex">F_{S_{n-1}}</script>、<script type="math/tex">F_{V_{n-1}}</script>和<script type="math/tex">F_{T_{n-1}}</script>，作为它们来自每个先前<script type="math/tex">G_{n-1}^{3}</script>模块的输入，如上图所示。</p><p>每个<script type="math/tex">G^{3}</script>模块由三个并行流组成:空间流<script type="math/tex">G_{S_{n}}</script>、时间流<script type="math/tex">G_{T_{n}}</script>以及视频流<script type="math/tex">G_{V_{n}}</script>。它们被设计成产生三种不同类型的特征。在上图中用蓝线表示的空间流将n  = 0时的<script type="math/tex">z_{a}</script>和n &gt;  1时的<script type="math/tex">F_{S_{n-1}}</script>作为输入，并通过使用转置的2D卷积层对输入特征进行上采样来生成2D外观特征<script type="math/tex">F_{S_{n}}</script>。这些特征在空间维度上发展，并在所有时间实例中共享。用橙色线表示的时间流<script type="math/tex">G_{T_{n}}</script>接受n  = 0的<script type="math/tex">z_{m}</script>和n &gt;  1的<script type="math/tex">F_{T_{n-1}}</script>作为输入，并试图通过用转置的1D卷积层对输入特征进行上采样来生成1D运动特征<script type="math/tex">F_{T_{n}}</script>。这些特征在时间维度上演化，并包含每个时间步长的全局信息。然后，用黑线表示的视频流<script type="math/tex">G_{V_{n}}</script>将n  = 0的<script type="math/tex">z_{a}</script>、<script type="math/tex">z_{m}</script>和n &gt; 1的<script type="math/tex">F_{V_{n-1}}</script>的连接作为输入。它对时空一致性进行建模，并通过对输入要素进行上采样和因子化转置时空卷积来产生3D联合嵌入<script type="math/tex">F_{V_{n}^{'}}</script>。然后将<script type="math/tex">F_{S_{n}}</script>和<script type="math/tex">F_{T_{n}}</script>弹射到时空融合块，在此与<script type="math/tex">F_{V_{n}^{'}}</script>融合，产生<script type="math/tex">F_{V_{n}}</script>。最后，<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{V_{n}}</script>作为下一个分层<script type="math/tex">G_{n+1}^{3}</script>的输入。</p><p>王等人在[40]中提出了<strong>Factorized transposed spatio-temporal convolution</strong>。它明确地将转置的3D卷积分解成两个独立且连续的运算，M个转置的1D时间卷积之后是2D独立的空间卷积，其被称为转置的(1+2)D卷积。这种分解在这两个操作之间带来了额外的非线性激活，并有助于优化。至关重要的是，分解转置的3D卷积产生了视频质量的显著提高</p><p><strong>Spatio-temporal fusion</strong>是学习好解纠缠特征的关键，其输入是来自每个<script type="math/tex">G^{3}</script>模块卷积层的输出特征映射<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>以及<script type="math/tex">F_{V_{n}^{'}}</script>。融合包含三个步骤(见下图)。首先，分别对<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{S_{n}}</script>进行空间和时间复制，以获得两个新的特征图<script type="math/tex">F_{T_{n}}^{R}</script>和<script type="math/tex">F_{S_{n}}^{R}</script>。两个新的特征图都具有与<script type="math/tex">F_{V_{n}^{'}}</script>相同的时空大小。接下来，通过位置相加将<script type="math/tex">F_{T_{n}}^{R}</script>和<script type="math/tex">F_{V_{n}^{'}}</script>合并，创建新的时空嵌入<script type="math/tex">F_{V_{n}^{''}}</script>。最后，将<script type="math/tex">F_{S_{n}}^{R}</script>与<script type="math/tex">F_{V_{n}^{''}}</script>通道相连接，获得最终的融合特征图<script type="math/tex">F_{V_{n}}</script>。该功能将<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{V_{n}}</script>映射为以下<script type="math/tex">G_{n+1}^{3}</script>模块的输入。</p><p><img src="https://i.loli.net/2020/12/24/5H1inxpkBuYWTyE.png" alt="image-20201224114926234"></p><p><strong>Factorized spatio-temporal Self-Attention (F-SA)：</strong>在这里，我们结合了一个时空模拟模块，使<strong>G</strong>能够利用来自所有时空特征位置的线索，并对广泛分离的区域之间的关系进行建模。然而，计算3D时空特征地图中每个位置与所有其他位置之间的相关性在计算上非常昂贵，特别是如果它应用于G中的更高特征地图。因此，我们提出了一种新的因子化时空自我注意，即<strong>F-SA</strong>，如下图所示。它由一个时间上的模拟退火算法和一个空间上的模拟退火算法组成。这种因子分解减少了计算的复杂性，允许在更大的特征地图上应用因子分析</p><p><img src="https://i.loli.net/2020/12/24/Wk6O7SocAsxRIum.png" alt="image-20201224115132598"></p><h3 id="3-2-Discriminator"><a href="#3-2-Discriminator" class="headerlink" title="3.2 Discriminator"></a>3.2 Discriminator</h3><p>为了提高视频和帧质量，类似于MoCoGAN，我们使用了一个双流鉴别器架构，包含一个视频流DV和一个图像流DI。在训练期间，数字视频接受完整的视频作为输入，而双标签从视频中随机抽取帧</p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：ImaGINator</title>
    <link href="http://yoursite.com/2020/12/23/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AImaGINator/"/>
    <id>http://yoursite.com/2020/12/23/论文速读：ImaGINator/</id>
    <published>2020-12-23T13:56:29.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文提出了一个新的<strong>conditional</strong> GAN模型，即<strong>ImaGINator</strong>，在给定单个图像<script type="math/tex">c_{a}</script>、运动类<script type="math/tex">c_{m}</script>以及噪声<strong>z</strong>的条件下，生成视频序列，如下图所示。</p><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_WACV_2020/papers/WANG_ImaGINator_Conditional_Spatio-Temporal_GAN_for_Video_Generation_WACV_2020_paper.pdf">ImaGINator: Conditional Spatio-Temporal GAN for Video Generation</a></p></blockquote><p><img src="https://i.loli.net/2020/12/23/ktXIgMHDd1f5cL8.png" alt="1"></p><p><strong>ImaGINator</strong>的特性如下：</p><ul><li>采用了一种新的时空融合机制，旨在通过增强<strong>G</strong>在低和高特征级别中使用空间信息来保持外观。通过向<strong>Decoder</strong>注入<script type="math/tex">c_{a}</script>，我们使<strong>G</strong>能够将重点放在生成单独的运动上。这是基于这样的假设，即视频可以在潜在空间以及多级时空特征空间中分解成外观和运动。虽然在每一层外观被保留，只有运动被改变。</li><li>一种新颖的转置<strong>(1+2)</strong>D卷积，将转置的三维卷积滤波器分解成独立的时间和空间分量。这带来了几个好处:(1)额外的非线性校正允许模型表示更复杂的函数，(2)它便于优化，因为转置(1+2)D卷积块比完全转置的3D卷积滤波器更容易优化，以及(3)它在视频质量和速度方面产生显著的增益</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>与之前文章中的MoCoGAN进行比较，MoCoGAN基于seq2seq架构，旨在将时空生成分为两步(将每个视频帧分解为不同潜在空间中的运动和外观)。然而，这种两步生成省略了在更高空间级别的时间一致性的建模，这通常不能保持原始外观。</p><p>与此不同，我们提出了一种单步架构，它在多级特征空间中分解运动和外观，用于图像到视频的生成。</p><h2 id="3-NetWork-Architecture"><a href="#3-NetWork-Architecture" class="headerlink" title="3. NetWork Architecture"></a>3. NetWork Architecture</h2><p>我们的目标是生成给定外观信息(作为单个图像帧)和运动类别(例如，确定面部表情)的视频序列。我们在这里假设一个视频y可以分解为外观<script type="math/tex">c_{a}</script>(源自输入图像)和运动<script type="math/tex">c_{m}</script>(源自类别标签)，在此基础上我们继续生成视频。因此，我们将我们的任务表述为学习一个条件映射G: {z，<script type="math/tex">c_{a}</script>，<script type="math/tex">c_{m}</script>} → y，其中z ~ N(0，1)表示随机噪声。</p><p><img src="https://i.loli.net/2020/12/23/iQ3yBHj9XNCYGmr.png" alt="2"></p><h3 id="3-1-Generator"><a href="#3-1-Generator" class="headerlink" title="3.1 Generator"></a>3.1 Generator</h3><p>我们的<strong>Generator</strong>由一个图像编码器和一个视频解码器组成，见上图。<strong>Encoder</strong>提取各种层中的外观信息，从浅的精细层到深的粗糙层。它将输入图像<script type="math/tex">c_{a}</script>编码为一个潜在矢量<strong>p</strong>，然后通过连接<strong>p</strong>、<script type="math/tex">c_{m}</script>以及随机噪声z ~ N(0，1)，<strong>Decoder</strong>生成一个视频序列。</p><p>在我们的生成器<strong>B</strong>中，我们将使用从2个跳跃连接的FCN-8的想法扩展到4个跳跃连接，但不同之处在于，最初的跳跃连接用于融合预测，而我们的跳跃连接用于融合外观和运动时空特征。我们的跳过连接允许<strong>Decoder</strong>直接从<strong>Encoder</strong>访问低级特征，使<strong>Decoder</strong>能够在每个时间片重用外观特征，并专注于生成运动。</p><h4 id="3-1-1-Spatio-temporal-fusion"><a href="#3-1-1-Spatio-temporal-fusion" class="headerlink" title="3.1.1 Spatio-temporal fusion."></a>3.1.1 Spatio-temporal fusion.</h4><p>假设<strong>G</strong>有<code>n</code>个图层，且<script type="math/tex">F_{i}^{H×W×C_{1}×T}</script>是<strong>G</strong>第<code>i</code>层中有<script type="math/tex">C_{1}</script>个通道的的特征图，<script type="math/tex">f_{i,t}^{H×W×C_{1}}</script>，t ∈ {1, …, T}是<script type="math/tex">F_{i}</script>中第<code>t</code>帧的特征图，<script type="math/tex">F_{n-i}^{H×W×C_{2}}</script>是第<code>n-i</code>层的特征图。</p><p>如下图所示，我们设计<strong>Decoder</strong>和<strong>Encoder</strong>的每一层的输出具有相同的空间维度。我们提出了一种融合机制，在通道方向的维度上连接每个<script type="math/tex">f_{i,t}</script>和<script type="math/tex">F_{n-i}</script>串联成同一个通道尺寸，得到一个新的特征映射<script type="math/tex">F_{i}^{'  H×W×(C_{1}+C_{2})×T}</script>，称为<strong>时空融合(Spatio-temporal fusion)</strong>。这里我们注意到，每个初始特征映射<script type="math/tex">F_{i}</script>呈现生成的视频中几个连续帧的时空特征。通过在不同的特征层次上直接时空融合<script type="math/tex">F_{i}</script>和 <script type="math/tex">F_{n-i}</script>，可以在生成的视频中很好地保留输入信息。</p><p>此外，我们将类别标签(构成一个one-hot向量)直接融合到解码器中，以便为每个层提供对标签的访问。为此，我们首先将热点向量投影到热点特征图上。然后，我们在解码器中将类别标签信息时空融合到不同的层中。我们最终的特征地图是大小为H  × W × (C1+ C2+<script type="math/tex">C_{category}</script>)× T</p><p><img src="https://i.loli.net/2020/12/23/7cL2kewg64tDmsy.png" alt="image-20201223214650481"></p><h4 id="3-1-2-Transposed-1-2-D-Convolution"><a href="#3-1-2-Transposed-1-2-D-Convolution" class="headerlink" title="3.1.2 Transposed (1+2)D Convolution"></a>3.1.2 Transposed (1+2)D Convolution</h4><p>我们注意到，由于难以优化，在一步方法中使用的3D卷积通常会导致产生模糊的视频。然而，得益于空间和时间分解，帧可以在两步方法中单独生成。因此，为了将这种分解结合到一步方法中，我们设计了一个新的卷积层，集成了转置的(1+2)维卷积</p><p>我们建议明确地将转置的3D卷积滤波器分解为两个独立且连续的运算，M个转置的1D时间卷积滤波器之后是一个2D独立的空间分量，我们称之为转置的(1+2)D卷积，如下图所示。这种分解带来了几个好处。第一个好处与这两个操作之间的额外非线性校正有关，因此允许模型表示更复杂的函数。第二个潜在的好处是，分解有助于优化，因为具有分解的时间和空间分量的转置(1+2)D卷积块是比完全转置3D卷积滤波器更容易优化。此外，我们表明，分解转置的3D卷积滤波器在视频质量和速度方面都产生了显著的增益。</p><p><img src="https://i.loli.net/2020/12/23/eUCXnR7S6LHmDVI.png" alt="image-20201223214950367"></p><h3 id="3-2-Two-stream-Discriminator"><a href="#3-2-Two-stream-Discriminator" class="headerlink" title="3.2 Two-stream Discriminator"></a>3.2 Two-stream Discriminator</h3><p>为了提高视频生成中的图像质量，我们设计了一个包含<script type="math/tex">D_{V}</script>和<script type="math/tex">D_{I}</script>的<strong>Two-stream Discriminator</strong>架构。虽然数字视频有五个3D卷积层，但数字视频只包含具有相同数字视频层数的2D卷积。<script type="math/tex">D_{V}</script>接受完整生成的视频作为输入，使用建议的时空融合来融合类别标签的“热点特征图”和第一层的输出，类似于<strong>G</strong>. <script type="math/tex">D_{V}</script>试图测量联合分布p(<script type="math/tex">x_{real}</script>, <script type="math/tex">c_{m}</script>)和p(<script type="math/tex">x_{fake}</script>, <script type="math/tex">c_{m}</script>)间的<strong>KL散度</strong>。我们分别从真实和生成的视频中随机抽取N帧作为输入。</p><h2 id="4-Conclunsion"><a href="#4-Conclunsion" class="headerlink" title="4. Conclunsion"></a>4. Conclunsion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;本文提出了一个新的&lt;strong&gt;con
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：MoCoGAN Decomposing Motion and Content for Video</title>
    <link href="http://yoursite.com/2020/12/21/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AMoCoGAN%20Decomposing%20Motion%20and%20Content%20for%20Video/"/>
    <id>http://yoursite.com/2020/12/21/论文速读：MoCoGAN Decomposing Motion and Content for Video/</id>
    <published>2020-12-21T13:26:14.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>视频中的视觉信号可以分为内容和运动。内容指定视频中的对象，运动描述它们的动态。在此基础上，本文提出了基于运动和内容分解的生成性对抗网络(MoCoGAN)的视频生成框架。</p><blockquote><p>代码地址：<a href="https://github.com/sergeytulyakov/mocogan">https://github.com/sergeytulyakov/mocogan</a>.</p></blockquote><h3 id="1-1-Related-Work"><a href="#1-1-Related-Work" class="headerlink" title="1.1 Related Work"></a>1.1 Related Work</h3><ul><li>使用循环机制来生成视频片段中帧的运动嵌入（motion）。</li><li>使用卷积神经网络生成图像（content）。</li></ul><h3 id="1-2-Contribution"><a href="#1-2-Contribution" class="headerlink" title="1.2 Contribution"></a>1.2 Contribution</h3><ol><li>我们提出了一种新的用于无条件视频生成的GAN框架，将<strong>噪声向量（noise）</strong>映射到视频中。</li><li>我们展示了所提出的框架提供了一种在视频生成中控制<strong>内容</strong>和<strong>运动</strong>的方法，这是现有视频生成框架所缺乏的。</li><li>为了验证算法的有效性，我们在基准数据集上进行了大量的实验验证，并与目前最先进的视频生成算法<strong>VGAN</strong>和<strong>TGAN</strong>进行了定量和主观比较</li></ol><h2 id="2-MoCoGAN-Framework"><a href="#2-MoCoGAN-Framework" class="headerlink" title="2. MoCoGAN Framework"></a>2. MoCoGAN Framework</h2><p><strong>MoCoGAN</strong>由四个子网络组成，即循环神经网络<script type="math/tex">R_{M}</script>、图像生成器<script type="math/tex">G_{I}</script>、图像鉴别器<script type="math/tex">D_{I}</script>和视频鉴别器<script type="math/tex">D_{V}</script></p><p><img src="https://i.loli.net/2020/12/21/m5Va9dhrUixQyI6.png" alt="1"></p><ol><li>使用高斯分布初始化<script type="math/tex">Z_{C}</script>对内容子空间建模，由于在剪辑的短视频中内容基本保持不变，所以我们使用相同的<script type="math/tex">Z_{C}</script>来生成不同帧。</li><li>视频中的运动由动作子空间<script type="math/tex">Z_{M}</script>建模。用于作为<script type="math/tex">G_{I}</script>输入的向量序列<strong>Z</strong>表示</li></ol><p><img src="https://i.loli.net/2020/12/21/8rB9gz1fp6UKXLq.png" alt="2"></p><blockquote><p>其中<script type="math/tex">z_{C}</script> ∈  <script type="math/tex">Z_{C}</script>以及<script type="math/tex">z_{M}^{(k)}</script> ∈ <script type="math/tex">Z_{M}</script>都各有k个，因为<script type="math/tex">Z_{M}</script>中并不是所有的路径都对应于路径上合理的运动，我们需要学会生成有效的路径，通过循环神经网络对路径生成过程进行建模。</p></blockquote><ol><li><script type="math/tex">R_{M}</script>即为一个循环神经网络，在每一个时间步<strong>k</strong>，都会输入一个服从高斯分布的<script type="math/tex">\epsilon^{(k)}</script>,以及输出一个<script type="math/tex">z_{M}^{(k)}</script>。假设<script type="math/tex">R_{M}</script>(k)为时刻k的输出，则<script type="math/tex">z_{M}^{(k)}</script> = <script type="math/tex">R_{M}</script>(k)。本论文中，使用<strong>GRU</strong>作为<script type="math/tex">R_{M}</script>的实现。</li><li><script type="math/tex">G_{I}</script>将向量序列<strong>Z</strong>映射为向量序列<script type="math/tex">\tilde{v}</script>，其中<script type="math/tex">\tilde{v}</script> = [<script type="math/tex">\tilde{x}^(1)</script>, …, <script type="math/tex">\tilde{x}^(k)</script>]</li><li><script type="math/tex">D_{I}</script>和<script type="math/tex">D_{V}</script>分别用于鉴别单个图像和视频序列。<script type="math/tex">D_{V}</script>获取固定长度的视频片段，例如<strong>T</strong>帧，<strong>T</strong>为一个超参数，论文中设为<strong>16</strong>。<strong>T</strong>可以小于所生成的视频长度<strong>K</strong>。长度为K的视频可以以滑动窗口的方式被分成<strong>K-T+1</strong>个片段，并且每个片段都可以被馈送到<script type="math/tex">D_{V}</script>中。</li><li><script type="math/tex">D_{V}</script>也用来评估所生成的动作。因为<script type="math/tex">G_{I}</script>没有运动的概念，因此对于运动的损失将会直接指向循环神经网络<script type="math/tex">R_{M}</script>。为了骗过<script type="math/tex">D_{V}</script>，生成具有较为真实动作的视频，<script type="math/tex">R_{M}</script>必须学会将输入<script type="math/tex">\epsilon^{(k)}</script>映射为动作系列<strong>Z</strong></li></ol><h2 id="3-Categorical-Dynamics"><a href="#3-Categorical-Dynamics" class="headerlink" title="3. Categorical Dynamics"></a>3. Categorical Dynamics</h2><p>视频中的动态通常是绝对的(例如，离散的动作类别：行走、跑步、跳跃等)。为了对这个分类信号建模，我们用一个分类随机变量<script type="math/tex">Z_{A}</script>来增加RM的输入，其中每个实现都是一个<strong>one-hot</strong>向量。我们保持其不变，因为短视频中动作类别保持不变，因此<script type="math/tex">R_{M}</script>的输入如下图所示。</p><p><img src="https://i.loli.net/2020/12/21/8Tklze5RjWM2JqL.png" alt="3"></p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;视频中的视觉信号可以分为内容和运动。内容
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>LaTex公式总结</title>
    <link href="http://yoursite.com/2020/12/21/LaTex%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/21/LaTex公式总结/</id>
    <published>2020-12-21T13:18:10.000Z</published>
    <updated>2022-06-06T03:22:14.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.jianshu.com/p/22117d964baf">简书</a></p><h3 id="Markdown中的LaTeX格式"><a href="#Markdown中的LaTeX格式" class="headerlink" title="Markdown中的LaTeX格式"></a>Markdown中的LaTeX格式</h3><p>大部分情况下，我对于latex的数学公式都是内嵌于Markdown文本编辑器中的，分为两种形式</p><ol><li>行内公式排版：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>c = \sqrt&#123;a^&#123;<span class="hljs-number">2</span>&#125;+b_&#123;<span class="hljs-number">0</span>&#125;^&#123;<span class="hljs-number">2</span>&#125;+e^&#123;x&#125;&#125; $<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=c%20%3D%20%5Csqrt%7Ba%5E%7B2%7D%2Bb_%7B0%7D%5E%7B2%7D%2Be%5E%7Bx%7D%7D" alt="c = \sqrt{a^{2}+b_{0}^{2}+e^{x}}"></p><ol><li>块公式排版：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> c = \sqrt&#123;a^&#123;<span class="hljs-number">2</span>&#125;+b_&#123;<span class="hljs-number">0</span>&#125;^&#123;<span class="hljs-number">2</span>&#125; +e^&#123;x&#125;&#125; <span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=c%20%3D%20%5Csqrt%7Ba%5E%7B2%7D%2Bb_%7B0%7D%5E%7B2%7D%20%2Be%5E%7Bx%7D%7D" alt="c = \sqrt{a^{2}+b_{0}^{2} +e^{x}}"></p><h3 id="LaTex的数学公式基本规则"><a href="#LaTex的数学公式基本规则" class="headerlink" title="LaTex的数学公式基本规则"></a>LaTex的数学公式基本规则</h3><ol><li>转义</li></ol><blockquote><p>以下几个字符: # $ % &amp; ~ _ ^ \ { }有特殊意义，需要表示这些字符时，需要转义，即在每个字符前加上\（转义字符的具体含义下面会解释）<br><img src="/image/LaTex/1.jpg" alt=""></p></blockquote><p>&gt;</p><blockquote><p>不知为何简书不支持~的表示，需要时写作\sim</p><p>\boxed命令给公式加一个方框。\fbox具有类似功能<br> \mathbf将字体加粗<br> \boldsymbol将字体斜体且加粗</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$E</span> = mc^<span class="hljs-number">2</span> <span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$ </span>\boxed&#123;E=mc^<span class="hljs-number">2</span>&#125; <span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>fbox&#123;E=mc^<span class="hljs-number">2</span>&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>mathbf&#123;E = mc^<span class="hljs-number">2</span>&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>boldsymbol&#123;E = mc^<span class="hljs-number">2</span>&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=E%20%3D%20mc%5E2" alt="E = mc^2"><br> <img src="https://math.jianshu.com/math?formula=%5Cboxed%7BE%3Dmc%5E2%7D" alt="\boxed{E=mc^2}"><br> <img src="https://math.jianshu.com/math?formula=%5Cfbox%7BE%3Dmc%5E2%7D" alt="\fbox{E=mc^2}"><br> <img src="https://math.jianshu.com/math?formula=%5Cmathbf%7BE%20%3D%20mc%5E2%7D" alt="\mathbf{E = mc^2}"><br> <img src="https://math.jianshu.com/math?formula=%5Cboldsymbol%7BE%20%3D%20mc%5E2%7D" alt="\boldsymbol{E = mc^2}"></p><ol><li>希腊字母与特殊字符</li></ol><p><img src="/image/LaTex/2.jpg" alt=""></p><p><img src="/image/LaTex/3.jpg" alt=""></p><p><img src="/image/LaTex/4.jpg" alt=""></p><ol><li>上下标及常用符号</li></ol><blockquote><p>用^来表示上标<br> 用_来表示下标<br> 根号用\sqrt表示</p></blockquote><p>注意：这些有特殊含义的表示中（不限于这三种内容），如果超过一个字符或符号，需要用{}括起来。</p><p>对角标的使用中，如果角标位置看起来不明显时，可以强制改变角标大小或层次，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$y_N</span>, y_&#123;_N&#125;,$<br></code></pre></td></tr></table></figure><p>显示为：<br> <img src="https://math.jianshu.com/math?formula=y_N%2C%20y_%7B_N%7D%2C" alt="y_N, y_{_N},"></p><p>第一种输出为正常输出，但输出效果不明显；第二种是将一级角标改为二级角标，字体也自动变为二级角标字体</p><p>当需要在左右两边都有上下标，可以用 \sideset 命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> \sideset&#123;^<span class="hljs-number">1_2</span>&#125;&#123;^<span class="hljs-number">3_4</span>&#125;\bigotimes <span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Csideset%7B%5E1_2%7D%7B%5E3_4%7D%5Cbigotimes" alt="\sideset{^1_2}{^3_4}\bigotimes"></p><p>\sqrt[开方次数，默认为2]{开方公式}， 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$$ x_&#123;k&#125;^<span class="hljs-number">2</span>\quad \sqrt&#123;x&#125;\quad \sqrt[<span class="hljs-number">3</span>]&#123;x+y&#125; $$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=x_%7Bk%7D%5E2%5Cquad%20%5Csqrt%7Bx%7D%5Cquad%20%5Csqrt%5B3%5D%7Bx%2By%7D" alt="x_{k}^2\quad \sqrt{x}\quad \sqrt[3]{x+y}"></p><blockquote><p>公式中插入文本\text{}或\mbox{}，建议使用前者，它对于latex内置的\mbox{}的优势在于它可以根据当前位置自动调整文本样式（尤其是大小），而\mbox采用统一的正文样式。这一点在你的文本被用作上下标的时候非常重要。</p></blockquote><p><img src="https://math.jianshu.com/math?formula=y%20%3D%20x%5E2%20%5Cmbox%7B(%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0" alt="y = x^2 \mbox{(二次函数)}">%7D)</p><blockquote><p>公式中插入空格，间隔效果如下表：</p></blockquote><p><img src="/image/LaTex/5.jpg" alt=""></p><blockquote><p>若需要显示更大或更小的字符，在符号前插入 \large 或 \small 命令</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$A</span>\large  A  \small A$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=A%5Clarge%20A%20%5Csmall%20A" alt="A\large A \small A"></p><blockquote><p>省略号\dots, \cdots,\vdots \ddots表示，\cdot常表示点乘，\vots是竖直方向的，\ddots是斜线方向的</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> x_1, x_2, \dots, x_n\quad <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,\cdots,n\quad \vdots\quad \ddots <span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=x_1%2C%20x_2%2C%20%5Cdots%2C%20x_n%5Cquad%201%2C2%2C%5Ccdots%2Cn%5Cquad%20%5Cvdots%5Cquad%20%5Cddots" alt="x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots"></p><blockquote><p>关系符如下表所示</p></blockquote><p><img src="/image/LaTex/6.jpg" alt=""></p><blockquote><p>其他常用符号</p></blockquote><p><img src="/image/LaTex/7.jpg" alt=""></p><ol><li>分数与组合数</li></ol><blockquote><p>分数用\frac{分子}{分母}表示，\cfrac用于连分数表示(这样相较于\frac不会产生字体自动缩小的问题)</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$x</span> = a _ <span class="hljs-number">0</span> + \cfrac &#123;<span class="hljs-number">1</span>&#125; &#123;a _ <span class="hljs-number">1</span><br>          + \cfrac &#123;<span class="hljs-number">1</span>&#125; &#123;a _ <span class="hljs-number">2</span><br>          + \cfrac &#123;<span class="hljs-number">1</span>&#125; &#123;a _ <span class="hljs-number">3</span> + \cfrac &#123;<span class="hljs-number">1</span>&#125; &#123;a _ <span class="hljs-number">4</span>&#125; &#125; &#125; &#125; <br>$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=x%20%3D%20a%20_%200%20%2B%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%201%20%2B%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%202%20%2B%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%203%20%2B%20%5Ccfrac%20%7B1%7D%20%7Ba%20_%204%7D%20%7D%20%7D%20%7D" alt="x = a _ 0 + \cfrac {1} {a _ 1 + \cfrac {1} {a _ 2 + \cfrac {1} {a _ 3 + \cfrac {1} {a _ 4} } } }"></p><p>字号工具环境设置：<br> \dfrac命令把字号设置为独立公式中的大小；<br> \tfrac则把字号设置为行间公式中的大小。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\frac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125; \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125; <span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%20%5Cdfrac%7B1%7D%7B2%7D" alt="\frac{1}{2} \dfrac{1}{2}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> \frac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125; \tfrac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125; <span class="hljs-variable">$$</span> <br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B2%7D%20%5Ctfrac%7B1%7D%7B2%7D" alt="\frac{1}{2} \tfrac{1}{2}"></p><blockquote><p>组合数用法与分数类似，在命令前加d和t也能达到分数字号设置同样的功能</p></blockquote><p>\binom{233}{x^2}<img src="https://math.jianshu.com/math?formula=%5Cbinom%7B233%7D%7Bx%5E2%7D" alt="\binom{233}{x^2}"></p><ol><li>运算符</li></ol><blockquote><p>基本加减乘除等于 +-*/= 可以直接输入<br> 特殊运算则用以下特殊命令\pm; \times; \div; \cdot; \cap; \cup; \geq; \leq; \neq; \approx; \equiv<br> <img src="https://math.jianshu.com/math?formula=%5Cpm%5C%3B%20%5Ctimes%5C%3B%20%5Cdiv%5C%3B%20%5Ccdot%5C%3B%20%5Ccap%5C%3B%20%5Ccup%5C%3B%20%5Cgeq%5C%3B%20%5Cleq%5C%3B%20%5Cneq%5C%3B%20%5Capprox%5C%3B%20%5Cequiv" alt="\pm\; \times\; \div\; \cdot\; \cap\; \cup\; \geq\; \leq\; \neq\; \approx\; \equiv"><br> 在此之上，如果想要使用堆积符号有以下三种形式</p></blockquote><ul><li>\stackrel{上位符号}{基位符号} 基位符号大，上位符号小</li><li>{上位公式\atop 下位公式} 上下符号一样大</li><li>{上位公式\choose 下位公式} 上下符号一样大；上下符号被包括在圆弧内</li></ul><p><img src="https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B%3D%7D%7Bx_1%2C%5Cdots%2Cx_n%7D%5C%5C%20%5Csum_%7Bk_0%2Ck_1%2C%5Cldots%3E0%20%5Catop%20k_0%2Bk_1%2B%5Ccdots%3Dn%7D%5C%5CA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots%7Bn%2B1%20%5Cchoose%20k%7D%3D%7Bn%20%5Cchoose%20k%7D%2B%7Bn%20%5Cchoose%20k-1%7D%5C%5C" alt="\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}\\ \sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}\\A_{k_0}A_{k_1}\cdots{n+1 \choose k}={n \choose k}+{n \choose k-1}\\"></p><blockquote><p>和、积、极限、积分等运算符用\sum, \prod, \lim, \int,这些公式在行内公式被压缩，以适应行高，可以通过\limits和\nolimits命令其是否压缩。<br> <img src="https://math.jianshu.com/math?formula=%5Csum%2C%20%5Cprod%2C%20%5Clim%2C%20%5Cint" alt="\sum, \prod, \lim, \int"></p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\sum_&#123;i=<span class="hljs-number">1</span>&#125;^n i <span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$ </span>\prod_&#123;i=<span class="hljs-number">1</span>&#125;^n i<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>lim_&#123;x\to0&#125;x^<span class="hljs-number">2</span> <span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>int_&#123;a&#125;^&#123;b&#125;x^<span class="hljs-number">2</span> dx <span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>sum\nolimits_&#123;i=<span class="hljs-number">1</span>&#125;^n i \quad\prod\nolimits_&#123;i=<span class="hljs-number">1</span>&#125;^n i<br>\quad<br>\lim\nolimits_&#123;x\to0&#125;x^<span class="hljs-number">2</span> \quad\int\limits_&#123;a&#125;^&#123;b&#125;x^<span class="hljs-number">2</span> dx <br>$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Csum_%7Bi%3D1%7D%5En%20i%20%5Cquad%20%5Cprod_%7Bi%3D1%7D%5En%20%5Cquad%5Clim_%7Bx%5Cto0%7Dx%5E2%20%5Cquad%5Cint_%7Ba%7D%5E%7Bb%7Dx%5E2%20dx" alt="\sum_{i=1}^n i \quad \prod_{i=1}^n \quad\lim_{x\to0}x^2 \quad\int_{a}^{b}x^2 dx"><br> <img src="https://math.jianshu.com/math?formula=%5Csum%5Cnolimits_%7Bi%3D1%7D%5En%20i%20%5Cquad%5Cprod%5Cnolimits_%7Bi%3D1%7D%5En%20i%20%5Cquad%20%5Clim%5Cnolimits_%7Bx%5Cto0%7Dx%5E2%20%5Cquad%5Cint%5Climits_%7Ba%7D%5E%7Bb%7Dx%5E2%20dx" alt="\sum\nolimits_{i=1}^n i \quad\prod\nolimits_{i=1}^n i \quad \lim\nolimits_{x\to0}x^2 \quad\int\limits_{a}^{b}x^2 dx"></p><ol><li>积分及箭头</li></ol><blockquote><p>积分符号使用如下形式：\int、\iint、\iiint、\iiiint、\idotsint</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$$ \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \quad \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \quad <br> \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \<span class="hljs-type">int</span> \quad \<span class="hljs-type">int</span> \dots（表示...） \<span class="hljs-type">int</span> $$<br><br>$$ \iint \quad \iiint \quad \iiiint \quad \idotsint $$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cint%20%5Cint%20%5Cquad%20%5Cint%20%5Cint%20%5Cint%20%5Cquad%20%5Cint%20%5Cint%20%5Cint%20%5Cint%20%5Cquad%20%5Cint%20%5Cdots%20%5Cint" alt="\int \int \quad \int \int \int \quad \int \int \int \int \quad \int \dots \int"></p><p><img src="https://math.jianshu.com/math?formula=%5Ciint%20%5Cquad%20%5Ciiint%20%5Cquad%20%5Ciiiint%20%5Cquad%20%5Cidotsint" alt="\iint \quad \iiint \quad \iiiint \quad \idotsint"></p><blockquote><p>箭头的种类过于繁多，这里不就一一列举了，但是箭头符号的名字很有规律，一般命名规则为方向+箭头种类：</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center">\leftarrow 或 \gets</td><td style="text-align:center"><img src="https://math.jianshu.com/math?formula=%5Cgets" alt="\gets"></td></tr><tr><td style="text-align:center">\rightarrow 或 \to</td><td style="text-align:center"><img src="https://math.jianshu.com/math?formula=%5C%2C%5Cto" alt="\,\to"></td></tr><tr><td style="text-align:center">\uparrow</td><td style="text-align:center"><img src="https://math.jianshu.com/math?formula=%5Cuparrow" alt="\uparrow"></td></tr><tr><td style="text-align:center">\downarrow</td><td style="text-align:center"><img src="https://math.jianshu.com/math?formula=%5Cdownarrow" alt="\downarrow"></td></tr></tbody></table></div><blockquote><blockquote><p>四个基本方向上下左右不多说，斜着的箭头的方向部分为\ne \se \nw \sw，为东北、东南、西北、西南简写<br> 示例：\nearrow <img src="https://math.jianshu.com/math?formula=%5Cnearrow" alt="\nearrow"></p><p>还有左右、上下两个方向的箭头：<br> \leftrightarrow   <img src="https://math.jianshu.com/math?formula=%5Cleftrightarrow" alt="\leftrightarrow"><br> \updownarrow  <img src="https://math.jianshu.com/math?formula=%5Cupdownarrow" alt="\updownarrow"></p><p>上面的箭头只有一根线，可以通过大写第一个字母变成双线：<br> \Leftrightarrow  <img src="https://math.jianshu.com/math?formula=%5CLeftrightarrow" alt="\Leftrightarrow"><br> \Uparrow  <img src="https://math.jianshu.com/math?formula=%5CUparrow" alt="\Uparrow"></p><p>在前面加上long可以把箭头变长，仅适用于左右箭头，注意双线箭头大写字母的位置：<br> \longleftarrow  <img src="https://math.jianshu.com/math?formula=%5Clongleftarrow" alt="\longleftarrow"><br> \longleftrightarrow  <img src="https://math.jianshu.com/math?formula=%5Clongleftrightarrow" alt="\longleftrightarrow"><br> \Longleftrightarrow 或 \iff <img src="https://math.jianshu.com/math?formula=%5Ciff" alt="\iff"></p><p>还有只有一边的箭头，名字为harpoon+up/down，表示那一边的位置，这种箭头似乎不支持上面的buff buffbuff，但拥有左右双向箭头：<br> \leftharpoonup  <img src="https://math.jianshu.com/math?formula=%5Cleftharpoonup" alt="\leftharpoonup"><br> \rightleftharpoons  <img src="https://math.jianshu.com/math?formula=%5Crightleftharpoons" alt="\rightleftharpoons"></p><p>意图在箭头上下位置添加说明时，有以下两种方式</p></blockquote></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-number">1</span>.\xleftarrow和\xrightarrow可根据内容自动调整（上下都可以添加内容）<br><br><span class="hljs-number">2</span>.\overset&#123;&#125;&#123;\rightarrow&#125;则是长度固定的箭头，适合单个字符，内容在上<br>  \overrightarrow&#123;&#125;则是长度变化的箭头，适合多个字符，箭头在上<br>注意<span class="hljs-number">2</span>中的都只适用于只在箭头上或下添加内容，改变位置将over改为under<br><br><span class="hljs-variable">$\</span>xleftarrow[x+y+z]&#123;x+y+z+<span class="hljs-number">1</span>&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>xrightarrow[x+y+z+<span class="hljs-number">1</span>]&#123;x+y+z&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>overset&#123;x+y+z&#125;&#123;\rightarrow&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br> <span class="hljs-variable">$\</span>underrightarrow&#123;x+y+z&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">$\</span>underset&#123;x+y+z&#125;&#123;\leftarrow&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><br> <span class="hljs-variable">$\</span>overleftarrow&#123;x+y+z&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cxleftarrow%5Bx%2By%2Bz%5D%7Bx%2By%2Bz%2B1%7D" alt="\xleftarrow[x+y+z]{x+y+z+1}"></p><p><img src="https://math.jianshu.com/math?formula=%5Cxrightarrow%5Bx%2By%2Bz%2B1%5D%7Bx%2By%2Bz%7D" alt="\xrightarrow[x+y+z+1]{x+y+z}"></p><p><img src="https://math.jianshu.com/math?formula=%5Coverset%7Bx%2By%2Bz%7D%7B%5Crightarrow%7D" alt="\overset{x+y+z}{\rightarrow}"></p><p><img src="https://math.jianshu.com/math?formula=%5Cunderrightarrow%7Bx%2By%2Bz%7D" alt="\underrightarrow{x+y+z}"></p><p><img src="https://math.jianshu.com/math?formula=%5Cunderset%7Bx%2By%2Bz%7D%7B%5Cleftarrow%7D" alt="\underset{x+y+z}{\leftarrow}"></p><p><img src="https://math.jianshu.com/math?formula=%5Coverleftarrow%7Bx%2By%2Bz%7D" alt="\overleftarrow{x+y+z}"></p><ol><li>注音和标注</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">字母上方横线\overline&#123;&#125;, \bar&#123;&#125;<br><span class="hljs-variable">$ </span>\bar&#123;x&#125; <span class="hljs-variable">$ </span>单个字符 <br><span class="hljs-variable">$\</span>overline&#123;xyz&#125;<span class="hljs-variable">$ </span>多个字符<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbar%7Bx%7D" alt="\bar{x}"><br> <img src="https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D" alt="\overline{xyz}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">字母下方横线\underline&#123;&#125;<br><span class="hljs-variable">$\</span>underline&#123;xyz&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cunderline%7Bxyz%7D" alt="\underline{xyz}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号<br><span class="hljs-variable">$\</span>overbrace&#123;a\dots a&#125;^&#123;n个&#125;<span class="hljs-variable">$ </span><br><span class="hljs-variable">$\</span>underbrace&#123;a\dots a&#125;_&#123;n个&#125;<span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Coverbrace%7Ba%5Cdots%20a%7D%5E%7Bn%E4%B8%AA%7D" alt="\overbrace{a\dots a}^{n个}"></p><p><img src="https://math.jianshu.com/math?formula=%5Cunderbrace%7Ba%5Cdots%20a%7D_%7Bn%E4%B8%AA%7D" alt="\underbrace{a\dots a}_{n个}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">向量表示有两种，单个字母用\vec&#123;x&#125;，多个字母用\overrightarrow 和\overleftarrow<br><span class="hljs-variable">$ </span>\vec&#123;x&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>overrightarrow&#123;AB&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>overleftarrow&#123;ABC&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D" alt="\vec{x}"><br> <img src="https://math.jianshu.com/math?formula=%5Coverrightarrow%7BAB%7D" alt="\overrightarrow{AB}"><br> <img src="https://math.jianshu.com/math?formula=%5Coverleftarrow%7BABC%7D" alt="\overleftarrow{ABC}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">字母上方波浪线\tilde&#123;&#125;, \widetilde&#123;&#125;<br><span class="hljs-variable">$ </span>\tilde&#123;x&#125;<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$ </span>\widetilde&#123;xyz&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Ctilde%7Bx%7D" alt="\tilde{x}"><br> <img src="https://math.jianshu.com/math?formula=%5Cwidetilde%7Bxyz%7D" alt="\widetilde{xyz}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\dot&#123;x&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cdot%7Bx%7D" alt="\dot{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\hat&#123;x&#125;<span class="hljs-variable">$ </span><br><span class="hljs-variable">$ </span>\widehat&#123;xyz&#125;<span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Chat%7Bx%7D" alt="\hat{x}"><br> <img src="https://math.jianshu.com/math?formula=%5Cwidehat%7Bxyz%7D" alt="\widehat{xyz}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\acute&#123;x&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cacute%7Bx%7D" alt="\acute{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\grave&#123;x&#125; $<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cgrave%7Bx%7D" alt="\grave{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\mathring&#123;x&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cmathring%7Bx%7D" alt="\mathring{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\ddot&#123;x&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cddot%7Bx%7D" alt="\ddot{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\check&#123;x&#125; $<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Ccheck%7Bx%7D" alt="\check{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\breve&#123;x&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbreve%7Bx%7D" alt="\breve{x}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\dddot&#123;x&#125; $<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cdddot%7Bx%7D" alt="\dddot{x}"></p><ol><li>编号</li></ol><blockquote><p>插入编号：<br> 使用\tag指令指定公式的具体编号，并使用\label指令埋下锚点。如y=x^2 \tag{1.5a}</p></blockquote><p><img src="https://math.jianshu.com/math?formula=y%3Dx%5E2%20%5Ctag%7B1.5a%7D" alt="y=x^2 \tag{1.5a}"></p><blockquote><p>引用编号：<br> 在markdown中不支持编号的锚点设置 \label与\ref 的使用</p></blockquote><ol><li>括号及嵌套</li></ol><p>常用括号有以下几种</p><p><img src="https:////upload-images.jianshu.io/upload_images/9368615-9db47069b8031901.png?imageMogr2/auto-orient/strip|imageView2/2/w/959/format/webp" alt="img"></p><blockquote><p>括号的大小调整</p></blockquote><p>对括号的大小，手动模式可以用\big, \Big, \bigg, \Bigg等一系列命令(从小到大，默认是最小)放在上述括号前面调整大小。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span>Bigg( \bigg( \Big( \big((x) \big) \Big) \bigg) \Bigg)<span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-variable">$\</span>Bigg\&#123; \bigg\&#123; \Big\&#123; \big\&#123;\&#123;x\&#125; \big\&#125; \Big\&#125; \bigg\&#125; \Bigg\&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5CBigg(%20%5Cbigg(%20%5CBig(%20%5Cbig((x" alt="\Bigg( \bigg( \Big( \big((x) \big) \Big) \bigg) \Bigg)\quad \Bigg\{ \bigg\{ \Big\{ \big\{\{x\} \big\} \Big\} \bigg\} \Bigg\}">%20%5Cbig)%20%5CBig)%20%5Cbigg)%20%5CBigg)%5Cquad%20%5CBigg%5C%7B%20%5Cbigg%5C%7B%20%5CBig%5C%7B%20%5Cbig%5C%7B%5C%7Bx%5C%7D%20%5Cbig%5C%7D%20%5CBig%5C%7D%20%5Cbigg%5C%7D%20%5CBigg%5C%7D)<br> 自动模式下要用 \left 和 \right 命令后面跟上所需分隔符，用来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 等分隔符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span> f(x,y,z) = 3y^2z \left( <span class="hljs-number">3</span>+\frac&#123;7x+<span class="hljs-number">5</span>&#125;&#123;<span class="hljs-number">1</span>+y^<span class="hljs-number">2</span>&#125; \right) <span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=f(x%2Cy%2Cz" alt="f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)">%20%3D%203y%5E2z%20%5Cleft(%203%2B%5Cfrac%7B7x%2B5%7D%7B1%2By%5E2%7D%20%5Cright))</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift">$$<br>f\left(<br>   \left[ <br>     \frac&#123;<br>       <span class="hljs-number">1</span><span class="hljs-operator">+</span>\left\&#123;x,y\right\&#125;<br>     &#125;&#123;<br>       \left(<br>          \frac&#123;x&#125;&#123;y&#125;<span class="hljs-operator">+</span>\frac&#123;y&#125;&#123;x&#125;<br>       \right)<br>       \left(u<span class="hljs-operator">+</span><span class="hljs-number">1</span>\right)<br>     &#125;<span class="hljs-operator">+</span>a<br>   \right]<span class="hljs-operator">^</span>&#123;<span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">2</span>&#125;<br>\right)<br>\tag&#123;<span class="hljs-number">1.2</span>&#125;<br>$$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=f%5Cleft(%20%5Cleft%5B%20%5Cfrac%7B%201%2B%5Cleft%5C%7Bx%2Cy%5Cright%5C%7D%20%7D%7B%20%5Cleft(%20%5Cfrac%7Bx%7D%7By%7D%2B%5Cfrac%7By%7D%7Bx%7D%20%5Cright" alt="f\left( \left[ \frac{ 1+\left\{x,y\right\} }{ \left( \frac{x}{y}+\frac{y}{x} \right) \left(u+1\right) }+a \right]^{3/2} \right) \tag{行标}">%20%5Cleft(u%2B1%5Cright)%20%7D%2Ba%20%5Cright%5D%5E%7B3%2F2%7D%20%5Cright)%20%5Ctag%7B%E8%A1%8C%E6%A0%87%7D)<br> 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \left. 或 \right. 来放一个”影子”括号：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;aligned&#125;<br>a=&amp;\left(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+  \cdots \right. \\<br>&amp; \cdots+ \left. \infty-<span class="hljs-number">2</span>+\infty-<span class="hljs-number">1</span>+\infty\right)<br>\<span class="hljs-keyword">end</span>&#123;aligned&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a%3D%26%5Cleft(1%2B2%2B3%2B%20%5Ccdots%20%5Cright.%20%5C%5C%20%26%20%5Ccdots%2B%20%5Cleft.%20%5Cinfty-2%2B%5Cinfty-1%2B%5Cinfty%5Cright" alt="\begin{aligned} a=&amp;\left(1+2+3+ \cdots \right. \\ &amp; \cdots+ \left. \infty-2+\infty-1+\infty\right) \end{aligned}">%20%5Cend%7Baligned%7D)</p><p>而如果分隔符不在左右而在中间，为了能够格式对齐，要用\middle加分隔符表示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-variable">$P</span><span class="hljs-operator">=</span>\left(<span class="hljs-type">A</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>\middle<span class="hljs-operator">|</span>\frac&#123;<span class="hljs-type">A</span><span class="hljs-operator">^</span><span class="hljs-number">2</span>&#125;&#123;<span class="hljs-type">B</span>&#125;<span class="hljs-operator">&gt;</span><span class="hljs-number">4</span>\right)$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=P%3D%5Cleft(A%3D2%5Cmiddle%7C%5Cfrac%7BA%5E2%7D%7BB%7D%3E4%5Cright" alt="P=\left(A=2\middle|\frac{A^2}{B}&gt;4\right)">)</p><ol><li>颜色设置</li></ol><p><img src="https:////upload-images.jianshu.io/upload_images/9368615-2fbc10b9e7ecae71.png?imageMogr2/auto-orient/strip|imageView2/2/w/963/format/webp" alt="img"></p><ol><li>原文照排</li></ol><blockquote><p>LATEX 提供了 \verb 命令(一般用于在正文中插入较短的命令)来实现</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span>verb<span class="hljs-params">|x^2|</span>\quad x^<span class="hljs-number">2</span>$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cverb%7Cx%5E2%7C%5Cquad%20x%5E2" alt="\verb|x^2|\quad x^2"></p><ol><li>删除线</li></ol><blockquote><p>在公式内使用 \require{cancel} 来允许 片段删除线 的显示。<br> 声明片段删除线后，使用 \cancel{字符}、\bcancel{字符}、\xcancel{字符} 和 \cancelto{字符} 来实现各种片段删除线效果。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">\<span class="hljs-keyword">require</span>&#123;cancel&#125;\<span class="hljs-keyword">begin</span>&#123;array&#125;&#123;rl&#125;<br>\verb<span class="hljs-params">|y+\cancel&#123;x&#125;|</span> &amp; y+\cancel&#123;x&#125;\\<br>\verb<span class="hljs-params">|\cancel&#123;y+x&#125;|</span> &amp; \cancel&#123;y+x&#125;\\<br>\verb<span class="hljs-params">|y+\bcancel&#123;x&#125;|</span> &amp; y+\bcancel&#123;x&#125;\\<br>\verb<span class="hljs-params">|y+\xcancel&#123;x&#125;|</span> &amp; y+\xcancel&#123;x&#125;\\<br>\verb<span class="hljs-params">|y+\cancelto&#123;0&#125;&#123;x&#125;|</span> &amp; y+\cancelto&#123;<span class="hljs-number">0</span>&#125;&#123;x&#125;\\<br>\verb+\frac&#123;<span class="hljs-number">1</span>\cancel9&#125;&#123;\cancel95&#125; = \frac15+&amp; \frac&#123;<span class="hljs-number">1</span>\cancel9&#125;&#123;\cancel95&#125; = \frac15 \\<br>\<span class="hljs-keyword">end</span>&#123;array&#125;<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Crequire%7Bcancel%7D%5Cbegin%7Barray%7D%7Brl%7D%20%5Cverb%7Cy%2B%5Ccancel%7Bx%7D%7C%20%26%20y%2B%5Ccancel%7Bx%7D%5C%5C%20%5Cverb%7C%5Ccancel%7By%2Bx%7D%7C%20%26%20%5Ccancel%7By%2Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Cbcancel%7Bx%7D%7C%20%26%20y%2B%5Cbcancel%7Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Cxcancel%7Bx%7D%7C%20%26%20y%2B%5Cxcancel%7Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Ccancelto%7B0%7D%7Bx%7D%7C%20%26%20y%2B%5Ccancelto%7B0%7D%7Bx%7D%5C%5C%20%5Cverb%2B%5Cfrac%7B1%5Ccancel9%7D%7B%5Ccancel95%7D%20%3D%20%5Cfrac15%2B%26%20%5Cfrac%7B1%5Ccancel9%7D%7B%5Ccancel95%7D%20%3D%20%5Cfrac15%20%5C%5C%20%5Cend%7Barray%7D" alt="\require{cancel}\begin{array}{rl} \verb|y+\cancel{x}| &amp; y+\cancel{x}\\ \verb|\cancel{y+x}| &amp; \cancel{y+x}\\ \verb|y+\bcancel{x}| &amp; y+\bcancel{x}\\ \verb|y+\xcancel{x}| &amp; y+\xcancel{x}\\ \verb|y+\cancelto{0}{x}| &amp; y+\cancelto{0}{x}\\ \verb+\frac{1\cancel9}{\cancel95} = \frac15+&amp; \frac{1\cancel9}{\cancel95} = \frac15 \\ \end{array}"></p><h3 id="数学公式高级规则"><a href="#数学公式高级规则" class="headerlink" title="数学公式高级规则"></a>数学公式高级规则</h3><ol><li>公式环境与对齐<br> 在下文的公式环境中，形如 equation<em>中， 带</em>号的不将公式标号排出来, 而不带*的自动给每行式子编排标号<br> latex的公式环境有很多种，这里只列举我常用的，更多请查阅latex官方说明</li></ol><blockquote><p>单行公式环境 equation<br> \begin{equation}<br> …<br> \end{equation}<br> 是最一般的公式环境，表示一个公式，默认情况下之表示一个单行的公式，但是它的功能可以通过内嵌各种其他环境进行扩展，不可以使用\与&amp;功能。它可以内嵌的一些关于对齐的环境将在后面介绍。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;equation&#125;<br>f(x)=3x^&#123;<span class="hljs-number">2</span>&#125;+<span class="hljs-number">6</span>(x-<span class="hljs-number">2</span>)-<span class="hljs-number">1</span><br>\<span class="hljs-keyword">end</span>&#123;equation&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20f(x" alt="\begin{equation} f(x)=3x^{2}+6(x-2)-1 \end{equation}">%3D3x%5E%7B2%7D%2B6(x-2)-1%20%5Cend%7Bequation%7D)</p><blockquote><p>align（多个公式）<br> 这是最基本的对齐环境，其他多公式环境都不同程度地依赖它。它采用“&amp;”分割各个对齐单元，使用“\”换行。它的每行是一个公式，都会独立编号。在排版过程中，它将&amp;分出来的列又分成组，组间特定方式排版，具体方式在flalign环境中讨论。<br> 通常情况下在公式中可以通过\tag设置标号，\label设置引用名称，但好像简书的markdown不支持\label，所以编号的意义就无所谓了。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;align&#125;<br> f(x) &amp;= (x+a)(x+b) \\<br> &amp;= x^<span class="hljs-number">2</span> + (a+b)x + ab \tag&#123;<span class="hljs-number">1.1</span>&#125;<br>\<span class="hljs-keyword">end</span>&#123;align&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Balign%7D%20f(x" alt="\begin{align} f(x) &amp;= (x+a)(x+b) \\ &amp;= x^2 + (a+b)x + ab \tag{1.1} \end{align}">%20%26%3D%20(x%2Ba)(x%2Bb)%20%5C%5C%20%26%3D%20x%5E2%20%2B%20(a%2Bb)x%20%2B%20ab%20%5Ctag%7B1.1%7D%20%5Cend%7Balign%7D)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;align&#125;<br>A_&#123;<span class="hljs-number">1</span>&#125;&amp;=B_&#123;<span class="hljs-number">1</span>&#125;B_&#123;<span class="hljs-number">2</span>&#125; &amp; A_&#123;<span class="hljs-number">3</span>&#125; &amp; = B_&#123;<span class="hljs-number">1</span>&#125;\\<br>A_&#123;<span class="hljs-number">2</span>&#125;&amp;=B_&#123;<span class="hljs-number">3</span>&#125;&amp; A_&#123;<span class="hljs-number">3</span>&#125;A_&#123;<span class="hljs-number">4</span>&#125; &amp; = B_&#123;<span class="hljs-number">4</span>&#125;<br>\<span class="hljs-keyword">end</span>&#123;align&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Balign%7D%20A_%7B1%7D%26%3DB_%7B1%7DB_%7B2%7D%20%26%20A_%7B3%7D%20%26%20%3D%20B_%7B1%7D%5C%5C%20A_%7B2%7D%26%3DB_%7B3%7D%26%20A_%7B3%7DA_%7B4%7D%20%26%20%3D%20B_%7B4%7D%20%5Cend%7Balign%7D" alt="\begin{align} A_{1}&amp;=B_{1}B_{2} &amp; A_{3} &amp; = B_{1}\\ A_{2}&amp;=B_{3}&amp; A_{3}A_{4} &amp; = B_{4} \end{align}"></p><blockquote><p>公式组环境flalign与align的功能基本相同，唯一区别是列对之间的距离为弹性宽度，以使公式组两端对齐。然而简书不支持。。。</p><p>gather环境<br> 它是最简单的多行公式环境，自己不提供任何对齐。其中的各行公式按照全局方式分别对齐。<br> 在设置了全局左对齐之后，因为不存在内部各个公式之间对排版的干扰，这种环境非常适合写数学推导或者证明。而默认情况下，是居中对齐。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">\begin&#123;gather*&#125;<br>E(X)=\<span class="hljs-keyword">lambda</span>    \qquad  D(X)=\<span class="hljs-keyword">lambda</span>    \\<br>E(\bar&#123;X&#125;)=\<span class="hljs-keyword">lambda</span>  \\<br>D(\bar&#123;X&#125;)=\frac&#123;\<span class="hljs-keyword">lambda</span>&#125;&#123;n&#125;    \\<br>E(S^<span class="hljs-number">2</span>)=\frac&#123;n-<span class="hljs-number">1</span>&#125;&#123;n&#125;\<span class="hljs-keyword">lambda</span> \\<br>\end&#123;gather*&#125;<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bgather%7D%20%5Cbecause%20E(X" alt="\begin{gather} \because E(X)=\lambda \qquad D(X)=\lambda \\ \therefore E(\bar{X})=\lambda \\ D(\bar{X})=\frac{\lambda}{n} \\ E(S^2)=\frac{n-1}{n}\lambda \\ \end{gather}">%3D%5Clambda%20%5Cqquad%20D(X)%3D%5Clambda%20%5C%5C%20%5Ctherefore%20E(%5Cbar%7BX%7D)%3D%5Clambda%20%5C%5C%20D(%5Cbar%7BX%7D)%3D%5Cfrac%7B%5Clambda%7D%7Bn%7D%20%5C%5C%20E(S%5E2)%3D%5Cfrac%7Bn-1%7D%7Bn%7D%5Clambda%20%5C%5C%20%5Cend%7Bgather%7D)</p><blockquote><p>与上文中公式组类似的，长公式也有两种multline和split两种环境，分别对应不对齐与对齐。</p></blockquote><p>multline不支持“&amp;”分列。其首行左对齐，末行右对齐，其余各行分别按照全局方式对齐。<br> split也用于排版多行公式，但它与多行公式环境multline的区别主要是以下三点：</p><ul><li>用&amp;作为分列符，但至多两列；左列右对齐，右列左对齐，形成一个列对，可使多行公式关于某个符号垂直对齐。因此用它排版的多行公式更为整齐美观。如果不用分列符&amp;,所有公式行为一列，且全都与首行公式的右端对齐。</li><li>必须置于除multline环境之外的其它公式环境中。</li><li>自身并不生成公式序号，而是由外在公式环境提供，序号垂直居中。</li></ul><p>示例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span>\<span class="hljs-keyword">begin</span>&#123;multline&#125;<br>x=a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\<span class="hljs-keyword">end</span>&#123;multline&#125;<span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmultline%7D%20x%3Da%2Bb%2Bc%2B%7B%7D%20%5C%5C%20d%2Be%2Bf%2Bg%20%5Cend%7Bmultline%7D" alt="\begin{multline} x=a+b+c+{} \\ d+e+f+g \end{multline}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span>\<span class="hljs-keyword">begin</span>&#123;split&#125;<br>x=&amp;a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\<span class="hljs-keyword">end</span>&#123;split&#125;<span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bsplit%7D%20x%3D%26a%2Bb%2Bc%2B%7B%7D%20%5C%5C%20%26d%2Be%2Bf%2Bg%20%5Cend%7Bsplit%7D" alt="\begin{split} x=&amp;a+b+c+{} \\ &amp;d+e+f+g \end{split}"></p><blockquote><p>/gathered，/aligned。以上几种方程组环境，无论每个公式多小，都会占满一行。而/gathered，/aligned环境，则只占据公式的实际宽度，整体作为一个特大的符号与其他符号一同处理。<br> 这个结构还可以添加位置参数，以决定与其他符号的竖直对齐方式(b,t)。而且这种环境不再具有自动编号功能。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;equation&#125;<br> \left.\<span class="hljs-keyword">begin</span>&#123;aligned&#125;<br>        B<span class="hljs-string">&#x27;&amp;=-\partial \times E,\\</span><br><span class="hljs-string">        E&#x27;</span>&amp;=\partial \times B - <span class="hljs-number">4</span>\pi j,<br>       \<span class="hljs-keyword">end</span>&#123;aligned&#125;<br> \right\&#125;<br> \qquad \text&#123;Maxwell<span class="hljs-string">&#x27;s equations&#125;</span><br><span class="hljs-string">\end&#123;equation&#125;</span><br><span class="hljs-string">$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20%5Cleft.%5Cbegin%7Baligned%7D%20B&#39;%26%3D-%5Cpartial%20%5Ctimes%20E%2C%5C%5C%20E&#39;%26%3D%5Cpartial%20%5Ctimes%20B%20-%204%5Cpi%20j%2C%20%5Cend%7Baligned%7D%20%5Cright%5C%7D%20%5Cqquad%20%5Ctext%7BMaxwell&#39;s%20equations%7D%20%5Cend%7Bequation%7D" alt="\begin{equation} \left.\begin{aligned} B&#39;&amp;=-\partial \times E,\\ E&#39;&amp;=\partial \times B - 4\pi j, \end{aligned} \right\} \qquad \text{Maxwell&#39;s equations} \end{equation}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;equation&#125;<br>\left.<br>\<span class="hljs-keyword">begin</span>&#123;aligned&#125;<br>x+y &amp;&gt; <span class="hljs-number">5</span> \\<br>y-y &amp;&gt; <span class="hljs-number">11</span><br>\<span class="hljs-keyword">end</span>&#123;aligned&#125;<br>\ \right\&#125;\Rightarrow x^<span class="hljs-number">2</span> - y^<span class="hljs-number">2</span> &gt; <span class="hljs-number">55</span><br>\<span class="hljs-keyword">end</span>&#123;equation&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20%5Cleft.%20%5Cbegin%7Baligned%7D%20x%2By%20%26%3E%205%20%5C%5C%20y-y%20%26%3E%2011%20%5Cend%7Baligned%7D%20%5C%20%5Cright%5C%7D%5CRightarrow%20x%5E2%20-%20y%5E2%20%3E%2055%20%5Cend%7Bequation%7D" alt="\begin{equation} \left. \begin{aligned} x+y &amp;&gt; 5 \\ y-y &amp;&gt; 11 \end{aligned} \ \right\}\Rightarrow x^2 - y^2 &gt; 55 \end{equation}"></p><blockquote><p>cases环境常用于分段函数，上面的环境虽然支持分段函数形式的表达，但比较繁琐</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span><br>L(Y,f(X))=<br>\<span class="hljs-keyword">begin</span>&#123;cases&#125;<br><span class="hljs-number">1</span>,\quad &amp;Y\neq f(X)\\<br><span class="hljs-number">0</span>,\quad &amp;Y=f(X)<br>\<span class="hljs-keyword">end</span>&#123;cases&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=L(Y%2Cf(X" alt="L(Y,f(X))= \begin{cases} 1,\quad &amp;Y\neq f(X)\\ 0,\quad &amp;Y=f(X) \end{cases}">)%3D%20%5Cbegin%7Bcases%7D%201%2C%5Cquad%20%26Y%5Cneq%20f(X)%5C%5C%200%2C%5Cquad%20%26Y%3Df(X)%20%5Cend%7Bcases%7D)</p><blockquote><p>阵列环境 array可以帮助我们输入一个数组或表格<br> 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，字母c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \ 结尾，最后以 end{array} 结束数组。下面是几个示例：</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;array&#125;&#123;c<span class="hljs-params">|l|</span>c<span class="hljs-params">|r&#125;</span><br><span class="hljs-params">n &amp; \text&#123;左对齐&#125; &amp; \text&#123;居中对齐&#125; &amp; \text&#123;右对齐&#125; \\</span><br><span class="hljs-params">\hline</span><br><span class="hljs-params">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span><br><span class="hljs-params">\hline</span><br><span class="hljs-params">2 &amp; -1 &amp; 189 &amp; -8 \\</span><br><span class="hljs-params">\hline</span><br><span class="hljs-params">3 &amp; -20 &amp; 2000 &amp; 1+10i</span><br><span class="hljs-params">\<span class="hljs-keyword">end</span>&#123;array&#125;$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Cl%7Cc%7Cr%7D%20n%20%26%20%5Ctext%7B%E5%B7%A6%E5%AF%B9%E9%BD%90%7D%20%26%20%5Ctext%7B%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%7D%20%26%20%5Ctext%7B%E5%8F%B3%E5%AF%B9%E9%BD%90%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%20%5Chline%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%20%5Chline%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5Cend%7Barray%7D" alt="\begin{array}{c|l|c|r} n &amp; \text{左对齐} &amp; \text{居中对齐} &amp; \text{右对齐} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ \hline 2 &amp; -1 &amp; 189 &amp; -8 \\ \hline 3 &amp; -20 &amp; 2000 &amp; 1+10i \end{array}"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span>left(\<span class="hljs-keyword">begin</span>&#123;array&#125;&#123;ccc<span class="hljs-params">|c&#125;</span><br><span class="hljs-params"> a11 &amp; a12 &amp; a13  &amp; b1 \\</span><br><span class="hljs-params">a21 &amp; a22  &amp; a23 &amp; b2  \\ </span><br><span class="hljs-params">a31 &amp; a32  &amp; a33 &amp; b3  \\</span><br><span class="hljs-params"> \<span class="hljs-keyword">end</span>&#123;array&#125;\right)$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cleft(%5Cbegin%7Barray%7D%7Bccc%7Cc%7D%20a11%20%26%20a12%20%26%20a13%20%26%20b1%20%5C%5C%20a21%20%26%20a22%20%26%20a23%20%26%20b2%20%5C%5C%20a31%20%26%20a32%20%26%20a33%20%26%20b3%20%5C%5C%20%5Cend%7Barray%7D%5Cright" alt="\left(\begin{array}{ccc|c} a11 &amp; a12 &amp; a13 &amp; b1 \\ a21 &amp; a22 &amp; a23 &amp; b2 \\ a31 &amp; a32 &amp; a33 &amp; b3 \\ \end{array}\right)">)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span><br>\left\&#123; <br>\<span class="hljs-keyword">begin</span>&#123;array&#125;&#123;c&#125;<br>a_1x+b_1y+c_1z=d_1 \\ <br>a_2x+b_2y+c_2z=d_2 \\ <br>a_3x+b_3y+c_3z=d_3<br>\<span class="hljs-keyword">end</span>&#123;array&#125;<br>\right. <br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cleft%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5C%5C%20a_3x%2Bb_3y%2Bc_3z%3Dd_3%20%5Cend%7Barray%7D%20%5Cright." alt="\left\{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{array} \right."></p><ol><li>矩阵</li></ol><ul><li>第一种方式：使用matrix、pmatrix、bmatrix、Bmatrix、vmatrix或者Vmatrix，smallmatrix<br> 一个最基本的矩阵</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>\<span class="hljs-keyword">begin</span>&#123;matrix&#125;<br><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> \\<br><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> <br>\<span class="hljs-keyword">end</span>&#123;matrix&#125; <span class="hljs-variable">$ </span>  <br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%200%20%26%201%20%5C%5C%201%20%26%200%20%5Cend%7Bmatrix%7D" alt="\begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix}"></p><p>可以看到矩阵中用 &amp; 分隔列，用 \ 分隔行，在矩阵开始和结束部分\begin和\end+矩阵类型<br> 下面给出这几种矩阵类型的图示</p><div class="table-container"><table><thead><tr><th>矩阵类型</th><th>矩阵图示</th></tr></thead><tbody><tr><td>matrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bmatrix%7D" alt="\begin{matrix}0 &amp; 1 \\1 &amp; 0 \end{matrix}"></td></tr><tr><td>pmatrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bpmatrix%7D" alt="\begin{pmatrix}0 &amp; 1 \\1 &amp; 0 \end{pmatrix}"></td></tr><tr><td>bmatrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bbmatrix%7D" alt="\begin{bmatrix}0 &amp; 1 \\1 &amp; 0 \end{bmatrix}"></td></tr><tr><td>Bmatrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7BBmatrix%7D" alt="\begin{Bmatrix}0 &amp; 1 \\1 &amp; 0 \end{Bmatrix}"></td></tr><tr><td>vmatrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bvmatrix%7D" alt="\begin{vmatrix}0 &amp; 1 \\1 &amp; 0 \end{vmatrix}"></td></tr><tr><td>Vmatrix</td><td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7BVmatrix%7D" alt="\begin{Vmatrix}0 &amp; 1 \\1 &amp; 0 \end{Vmatrix}"></td></tr><tr><td>smallmatrix</td><td><img src="https://math.jianshu.com/math?formula=(%5Cbegin%7Bsmallmatrix%7D%200%20%26%201%20%5C%5C%201%20%26%200%20%5Cend%7Bsmallmatrix%7D" alt="(\begin{smallmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{smallmatrix})">)</td></tr></tbody></table></div><p>在此之上，如果我们需要对矩阵起始和结束部分的括号进行变化，可以使用诸如</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span>left\&#123;\<span class="hljs-keyword">begin</span>&#123;matrix&#125;<br> x_1&amp; x_2\\ <br> y_1&amp; y_2<br>\<span class="hljs-keyword">end</span>&#123;matrix&#125;\right.<span class="hljs-variable">$ </span>   (此处.作为占位符表示不需要分隔符)<br><span class="hljs-variable">$\</span>left.\<span class="hljs-keyword">begin</span>&#123;matrix&#125;<br>x_1 &amp; x_2\\ <br> y_1&amp; y_2<br>\<span class="hljs-keyword">end</span>&#123;matrix&#125;\right\&#125;<span class="hljs-variable">$ </span> <br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%20x_1%26%20x_2%5C%5C%20y_1%26%20y_2%20%5Cend%7Bmatrix%7D%5Cright." alt="\left\{\begin{matrix} x_1&amp; x_2\\ y_1&amp; y_2 \end{matrix}\right."><br> <img src="https://math.jianshu.com/math?formula=%5Cleft.%5Cbegin%7Bmatrix%7D%20x_1%20%26%20x_2%5C%5C%20y_1%26%20y_2%20%5Cend%7Bmatrix%7D%5Cright%5C%7D" alt="\left.\begin{matrix} x_1 &amp; x_2\\ y_1&amp; y_2 \end{matrix}\right\}"></p><p>第二种方式就是使用array环境，在左右端加上所需括号即可</p><blockquote><p>输入带省略符号的矩阵</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$$</span><br>        \<span class="hljs-keyword">begin</span>&#123;pmatrix&#125;<br>        <span class="hljs-number">1</span> &amp; a_1 &amp; a_1^<span class="hljs-number">2</span> &amp; \cdots &amp; a_1^n \\<br>        <span class="hljs-number">1</span> &amp; a_2 &amp; a_2^<span class="hljs-number">2</span> &amp; \cdots &amp; a_2^n \\<br>        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>        <span class="hljs-number">1</span> &amp; a_m &amp; a_m^<span class="hljs-number">2</span> &amp; \cdots &amp; a_m^n \\<br>        \<span class="hljs-keyword">end</span>&#123;pmatrix&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201%20%26%20a_1%20%26%20a_1%5E2%20%26%20%5Ccdots%20%26%20a_1%5En%20%5C%5C%201%20%26%20a_2%20%26%20a_2%5E2%20%26%20%5Ccdots%20%26%20a_2%5En%20%5C%5C%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%201%20%26%20a_m%20%26%20a_m%5E2%20%26%20%5Ccdots%20%26%20a_m%5En%20%5C%5C%20%5Cend%7Bpmatrix%7D" alt="\begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\ 1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\ \end{pmatrix}"></p><ol><li>交换图表</li></ol><blockquote><p>使用一行  \require{AMScd}  语句来允许交换图表的显示。<br> 声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \ 。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">require</span>&#123;AMScd&#125;<br>\<span class="hljs-keyword">begin</span>&#123;CD&#125;<br>    A @&gt;a&gt;&gt; B\\<br>    <span class="hljs-variable">@V</span> b V V\<span class="hljs-comment"># <span class="hljs-doctag">@VV</span> c V\\</span><br>    C @&gt;&gt;d&gt; D<br>\<span class="hljs-keyword">end</span>&#123;CD&#125;$<br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Crequire%7BAMScd%7D%20%5Cbegin%7BCD%7D%20A%20%40%3Ea%3E%3E%20B%5C%5C%20%40V%20b%20V%20V%5C%23%20%40VV%20c%20V%5C%5C%20C%20%40%3E%3Ed%3E%20D%20%5Cend%7BCD%7D" alt="\require{AMScd} \begin{CD} A @&gt;a&gt;&gt; B\\ @V b V V\# @VV c V\\ C @&gt;&gt;d&gt; D \end{CD}"><br> 其中，@&gt;&gt;&gt; 代表右箭头、@&lt;&lt;&lt; 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。<br> 在 @&gt;&gt;&gt; 的 &gt;&gt;&gt; 之间任意插入文字即代表该箭头的注释文字。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$\</span><span class="hljs-keyword">begin</span>&#123;CD&#125;<br>    A @&gt;&gt;&gt; B @&gt;&#123;\text&#123;very long label&#125;&#125;&gt;&gt; C \\<br>    @. <span class="hljs-variable">@AAA</span> @<span class="hljs-params">| \\</span><br><span class="hljs-params">    D @= E @&lt;&lt;&lt; F</span><br><span class="hljs-params">\<span class="hljs-keyword">end</span>&#123;CD&#125;$</span><br></code></pre></td></tr></table></figure><p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7BCD%7D%20A%20%40%3E%3E%3E%20B%20%40%3E%7B%5Ctext%7Bvery%20long%20label%7D%7D%3E%3E%20C%20%5C%5C%20%40.%20%40AAA%20%40%7C%20%5C%5C%20D%20%40%3D%20E%20%40%3C%3C%3C%20F%20%5Cend%7BCD%7D" alt="\begin{CD} A @&gt;&gt;&gt; B @&gt;{\text{very long label}}&gt;&gt; C \\ @. @AAA @| \\ D @= E @&lt;&lt;&lt; F \end{CD}"></p><p>以上内容大致上应该能把绝大多数数学公式优美的书写下来了，更多内容还需要自行查阅官方说明~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转载自&lt;a href=&quot;https://www.jianshu.com/p/22117d964baf&quot;&gt;简书&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Markdown中的LaTeX格式&quot;&gt;&lt;a href=&quot;#Markdown中的LaTeX格式&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="数学" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>目标检测之YOLO理解与总结</title>
    <link href="http://yoursite.com/2020/11/25/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B9%8BYOLO%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/11/25/目标检测之YOLO理解与总结/</id>
    <published>2020-11-25T05:31:04.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><ul><li>我们知道，目标检测通常分为两个步骤： <strong>（1）生成bounding box（边界框）（2）对物体分类</strong>。因此目标检测算法也因此分为<strong>one-stage</strong>与<strong>two-stage</strong>两个算法系列。</li><li>顾名思义，<strong>two-stage</strong>算法就是把两个步骤分别进行，比如<strong>R-CNN</strong>方法使用<code>region proposal</code>来生成整张图像中可能包含待检测物体的<code>potential bounding boxes</code>，然后用分类器来评估这些<code>boxes</code>，接着通过<code>post-processing</code>来改善<code>bounding boxes</code>，消除重复的检测目标，并基于整个场景中的其他物体重新对<code>boxes</code>进行打分。整个流程执行下来很慢，而且因为这些环节都是分开训练的，检测性能很难进行优化。</li><li>作者提出的<strong>YOLO（you only look once）</strong>就是<strong>one-stage</strong>算法系列的代表。它将目标检测任务当做回归问题<code>（regression problem）</code>来处理，直接通过整张图片的所有像素得到 的坐标、box中包含物体的置信度和<code>class probabilities</code>。顾名思义，通过<strong>YOLO</strong>，每张图像只需要看一眼就能得出图像中都有哪些物体和这些物体的位置。</li></ul><h1 id="2-内容介绍"><a href="#2-内容介绍" class="headerlink" title="2.内容介绍"></a>2.内容介绍</h1><p>本篇博客记录我对YOLO的学习，我会分别对YOLOV1，YOLOV2，YOLOV3的内容进行总结，并进行比较。</p><h1 id="3-YOLO-V1"><a href="#3-YOLO-V1" class="headerlink" title="3.YOLO V1"></a>3.YOLO V1</h1><h2 id="3-1-流程"><a href="#3-1-流程" class="headerlink" title="3.1 流程"></a>3.1 流程</h2><ol><li>将一幅图像分成<strong>S×S</strong>个网格（grid cell），如果某个<code>object</code>的中心落在这个网格中，则这个网格就负责预测这个<code>object</code></li><li>每个网格要预测<strong>B</strong>个<code>bounding box</code>，每个<code>bounding box</code>除了要预测位置之外，还要附带预测一个<code>confidence(置信度)</code>。每个网格还要预测<strong>C</strong>个类别的分数</li></ol><p><img src="/image/目标检测之YOLO理解与总结/1.png" alt=""></p><p>比如将上图分为了7×7个网格，要识别的目标狗的中心点落在第5行，第2列的网格点，那么这个网格点就负责预测狗这个object</p><p><img src="/image/目标检测之YOLO理解与总结/2.png" alt=""></p><blockquote><p>For evaluating YOLO on PASACL VOC, we use S = 7, B = 2, PASCAL VOC has 20 labelled classes so C = 20. Our final prediction is a 7 × 7 × 30 tensor</p></blockquote><p>以上为摘自原论文，在<code>PASCAL VOC</code>数据集上，我们通过YOLO，最终获得了<strong>7 × 7 × 30</strong>的特征矩阵，由上图可知，沿着深度方向我们发现有<strong>30</strong>个数值，因为<strong>B = 2</strong>，所以有2个<code>bounding box</code>，每个<code>bounding box</code>有<strong>4+1</strong>个数值，分别为目标的<code>坐标信息(中心点位置和宽高)</code>与<code>confidence</code>，最后<strong>20</strong>个为PASCAL VOC <strong>20</strong>个类别的分数。所以总共是<strong>30</strong></p><h2 id="3-2-网络结构"><a href="#3-2-网络结构" class="headerlink" title="3.2 网络结构"></a>3.2 网络结构</h2><p>YOLO将图像resize到448×448作为神经网络的输入 。</p><p>YOLO检测网络包括<strong>24个卷积层和2个全连接层</strong>，YOLO网络借鉴了<strong>GoogLeNet</strong>分类网络结构。不同的是，YOLO未使用inception module，而是使用1x1卷积层（此处1x1卷积层的存在是为了跨通道信息整合）+3x3卷积层简单替代。、</p><p><img src="/image/目标检测之YOLO理解与总结/3.png" alt=""></p><h2 id="3-3-损失函数"><a href="#3-3-损失函数" class="headerlink" title="3.3 损失函数"></a>3.3 损失函数</h2><p>YOLO V1的损失函数分为三个部分</p><p><img src="/image/目标检测之YOLO理解与总结/4.png" alt=""></p><p>计算损失过程中，用的都是误差平方和，但是对宽高处理，是先对其开根号处理，为什么这么做呢，看到一个很棒的解释。</p><p><img src="/image/目标检测之YOLO理解与总结/5.png" alt=""></p><p>从上图右侧所示，当预测边界框相对于真实边界框便宜相同的高度和宽度时，小目标改变的IoU与大目标不同。画出y - x和$ \sqrt{y} $ - $ \sqrt{x} $图，如左侧所示，我们会发现,y与x的差值一样时,小目标在纵坐标上的差值大于大目标</p><h2 id="3-4-YOLO-V1的不足之处"><a href="#3-4-YOLO-V1的不足之处" class="headerlink" title="3.4 YOLO V1的不足之处"></a>3.4 YOLO V1的不足之处</h2><ul><li>YOLO V1对<strong>小目标</strong>的预测效果不理想,因为在YOLO V1的每个grid cell只预测2个<code>bounding box</code>,而且这两个<code>bounding box</code>属于同个类别</li><li>当检测目标出现了新的尺寸时,检测效果会变差</li><li>主要的错误原因,都来自于定位不准确,因为不像<strong>Faster RCNN</strong>和<strong>SSD</strong>使用了<strong>anchor box</strong>的回归参数来调整位置</li></ul><h1 id="4-YOLO-V2"><a href="#4-YOLO-V2" class="headerlink" title="4.YOLO V2"></a>4.YOLO V2</h1><h2 id="4-1-对比YOLO-V1"><a href="#4-1-对比YOLO-V1" class="headerlink" title="4.1 对比YOLO V1"></a>4.1 对比YOLO V1</h2><p>作者在YOLO v1的基础上，借鉴了很多<strong>trick</strong>，比如<code>Batch Normalization</code>、<code>High Resolution Classifier</code>等，提出YOLO v2，让预测变得更<strong>准确（Better）</strong>，<strong>更快速（Faster）</strong>，下图为性能对比。</p><p><img src="/image/目标检测之YOLO理解与总结/6.png" alt=""><br><img src="/image/目标检测之YOLO理解与总结/123.png" alt=""></p><h2 id="4-2-YOLO-V2中的各种尝试"><a href="#4-2-YOLO-V2中的各种尝试" class="headerlink" title="4.2 YOLO V2中的各种尝试"></a>4.2 YOLO V2中的各种尝试</h2><h3 id="1-Batch-Normalization（批量归一化）"><a href="#1-Batch-Normalization（批量归一化）" class="headerlink" title="1. Batch Normalization（批量归一化）"></a>1. Batch Normalization（批量归一化）</h3><ul><li><strong>批量归一化</strong>有助于解决反向传播过程中出现的<strong>梯度消失</strong>和<strong>梯度爆炸</strong>问题，降低对一些超参数的敏感性，并且起到一定的<strong>正则化</strong>效果（YOLO2不再使用dropout），从而能够获得更好的收敛速度和收敛效果，加了BN层后mAP提高了<strong>2%</strong></li></ul><h3 id="2-High-Resolution-Classifier（使用高分辨率图像微调分类模型）"><a href="#2-High-Resolution-Classifier（使用高分辨率图像微调分类模型）" class="headerlink" title="2.High Resolution Classifier（使用高分辨率图像微调分类模型）"></a>2.High Resolution Classifier（使用高分辨率图像微调分类模型）</h3><ul><li>目前先进的目标检测方法中，基本上都会先在<code>ImageNet</code>上进行预训练，而<code>ImageNet</code>的输入采用的是<strong>224×224</strong>，导致分辨率不够高，给检测带来困难。<strong>YOLO v1</strong>网络把分辨率直接提升到了<strong>448×448</strong>，但是直接切换分辨率，检测模型可能难以快速适应高分辨率，这也意味之原有的网络模型必须进行<strong>某种调整</strong>以适应新的分辨率输入。</li><li>所以<strong>YOLO v2</strong>增加了在<code>ImageNet</code>数据集上使用<strong>448×448</strong>输入来<strong>finetune</strong>分类网络这一中间过程（10 epochs），这可以使得模型在检测数据集（eg:COCO）上<strong>finetune</strong>之前已经<strong>适应</strong>高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约<strong>4%</strong>。</li></ul><h3 id="3-Convolutional-With-Anchor-Boxes（使用先验框Anchor-Box替换全连接层）"><a href="#3-Convolutional-With-Anchor-Boxes（使用先验框Anchor-Box替换全连接层）" class="headerlink" title="3.Convolutional With Anchor Boxes（使用先验框Anchor Box替换全连接层）"></a>3.Convolutional With Anchor Boxes（使用先验框Anchor Box替换全连接层）</h3><p>在之前的<strong>YOLO v1</strong>中，直接采用<strong>全连接层</strong>来预测边界框，效果不好(之前分析中的定位效果较差)。作者借鉴了<strong>Faster R-CNN</strong>中使用<strong>RPN</strong>预测<strong>偏移量offsets</strong>和<strong>置信度confidences</strong>的思想，预测<strong>bounding box</strong>与<strong>Anchor</strong>框的<strong>偏移（offset）</strong>而不是直接预测<strong>bounding box</strong>的坐标。</p><ol><li>首先作者<strong>去除了一个池化层</strong>，来使得输出的卷积特征图有<strong>更高的分辨率</strong>。</li><li>其次作者<strong>缩减了网络</strong>，把原本网络的输入<strong>448×448</strong> 缩减成<strong>416×416</strong>。因为<strong>YOLO v2</strong>模型<strong>下采样</strong>的总步长为<strong>32</strong>，对于<strong>416×416    </strong>大小的图片，最终得到的特征图大小为<strong>13×13</strong>，维度是<strong>奇</strong>数，这样特征图恰好只有一个中心位置。<strong>作者发现对于一些大物体，它们中心点往往落入图片中心位置，此时使用特征图的一个中心点而不是四个中心点去预测这些物体的边界框相对容易些</strong>。所以在YOLOv2设计中要保证输入对应的最终的特征图有奇数个位置</li></ol><ul><li>使用<strong>anchor boxes</strong>之后，mAP下降了<strong>0.3</strong>，但召回率提高了<strong>7%</strong>。这是因为<strong>YOLOv1</strong>只能预测<strong>98</strong>个边界框<strong>(7×7×2)</strong>，而<strong>YOLO v2</strong>使用<strong>anchor boxes</strong>之后可以预测<strong>上千个边界框（13×13×num_anchor）</strong>,召回率的提升使得模型拥有进一步的改进空间。</li></ul><h3 id="4-Dimension-Clusters-使用聚类算法获取anchor-box"><a href="#4-Dimension-Clusters-使用聚类算法获取anchor-box" class="headerlink" title="4.Dimension Clusters(使用聚类算法获取anchor box)"></a>4.Dimension Clusters(使用聚类算法获取anchor box)</h3><ul><li><p>之前<strong>anchor boxes</strong>都是<strong>手工设定</strong>的(如<strong>Faster RCNN</strong>,作者没有给出具体获取anchor boxes的方法,只是根据经验所得)，网络微调<strong>anchor boxes</strong>到实际位置的难度不小。而<strong>YOLO v2的做法是对训练集中标注的边框进行聚类分析，以自动找到更好的尺寸。</strong></p></li><li><p>聚类算法最重要的是选择如何计算两个边框之间的“距离”，对于常用的欧式距离，大边框会产生更大的误差，但我们关心的是<strong>anchor boxes</strong>和<strong>ground truth</strong>的<strong>IOU</strong>。所以，<strong>YOLO2在聚类时巧妙地采用以下公式来计算两个边框之间的距离：</strong></p><p><strong>d(box, centroid) = 1 - IoU(box, centroid)</strong></p></li><li><p><strong>centroid是聚类时被选作中心的边框，box就是其它anchor boxes。IOU越大，距离越近。</strong>YOLO2给出的聚类分析结果如下图所示：</p><p><img src="/image/目标检测之YOLO理解与总结/7.png" alt=""></p></li><li><p>随着聚类中心数目的增加，我们可以看到平均IOU值是增加的，但是综合考虑模型复杂度和召回率，作者最终选取<strong>5</strong>个聚类中心作为先验框，其相对于图片的大小如右边图所示。</p></li></ul><h3 id="5-Direct-location-prediction-直接位置预测"><a href="#5-Direct-location-prediction-直接位置预测" class="headerlink" title="5.Direct location prediction(直接位置预测)"></a>5.Direct location prediction(直接位置预测)</h3><ul><li><p>作者发现使用<strong>anchor boxes</strong>的时候模型<strong>不稳定</strong>，尤其是在早期迭代的时候。而大部分的不稳定现象出现在预测box的<strong>(x, y)</strong>坐标上了，而以往计算的公式如下（<strong>图中的两个减号应是加号，作者写错</strong>）：</p><p>  <img src="/image/目标检测之YOLO理解与总结/8.png" alt=""></p></li><li><p>这个公式没有任何限制，使得无论在什么位置进行预测，任何anchor boxes可以在图像中任意一点结束（这是因为偏移量<strong>tx, ty</strong>没有大小限制，可能会导致出现anchor偏离ground truth很远的情况。正确做法应该是每一个anchor只负责检测周围正负一个单位以内的目标box）。YOLO v2调整了预测公式，将<strong>预测边框的中心约束在网格内</strong>:</p><p>  <img src="/image/目标检测之YOLO理解与总结/9.png" alt=""></p></li><li><p>其中，<strong>bx, by, bw, bh</strong>是<strong>预测边框的中心和宽高</strong>。<br><strong>Pr(object) * IoU(b, object) = σ(to)</strong> 是<strong>预测边框的置信度</strong>，<strong>YOLO v1</strong>是直接预测置信度的值，这里对预测参数<strong>to</strong>进行σ变换后作为置信度的值。<strong>cx, cy</strong>是<strong>当前网格左上角到图像左上角的距离</strong>，要先将<strong>网格大小归一化，即令一个网格的宽=1，高=1</strong>。$ p^w $, $ p^h $ 是<strong>先验框的宽和高</strong>。 σ是<strong>sigmoid</strong>函数。<strong>tx, ty, tw, th, to</strong>是要学习的参数，分别用于<strong>预测边框的中心和宽高，以及置信度</strong>。</p></li></ul><p><img src="/image/目标检测之YOLO理解与总结/10.png" alt=""></p><ul><li>作者使用Dimension Clusters和Direct location prediction这两项anchor boxes改进方法，mAP获得了<strong>5%</strong>的提升。</li></ul><h3 id="6-Fine-Grained-Features（细粒度特征）"><a href="#6-Fine-Grained-Features（细粒度特征）" class="headerlink" title="6.Fine-Grained Features（细粒度特征）"></a>6.Fine-Grained Features（细粒度特征）</h3><ul><li><p>作者发现<strong>YOLO</strong>使用<strong>13×13</strong>的特征图进行预测<strong>大物体</strong>拥有很好的效果，而相对比较小的物体则效果一般。<strong>YOLO v2</strong>引入一种称为<strong>passthrough</strong>层的方法在特征图中保留一些细节信息。</p></li><li><p><strong>YOLO v2</strong>所利用的<strong>Fine-Grained Features</strong>是<strong>26×26</strong>大小的特征图（最后一个maxpooling层的输入）。<strong>passthrough</strong>层与<strong>ResNet</strong>网络的<strong>identity mappings</strong>类似，<strong>以前面更高分辨率的特征图为输入，然后将其连接到后面的低分辨率特征图上</strong>。前面的特征图维度是后面的特征图的<strong>2</strong>倍，<strong>passthrough</strong>层抽取前面层的每个<strong>2×2</strong>，然后将其转化为channel的维度，对于<strong>26×26×512</strong>的特征图，经<strong>passthrough</strong>层处理之后就变成了 <strong>13×13×25</strong>6的新特征图（特征图大小降低4倍，而channles增加4倍），这样就可以与后面的<strong>13×13×25</strong>6 特征图连接在一起形成<strong>13×13×1280</strong>大小的特征图。<br>  <img src="/image/目标检测之YOLO理解与总结/11.png" alt=""><br>  <img src="/image/目标检测之YOLO理解与总结/12.png" alt=""></p><h3 id="7-Multi-Scale-Training（多尺寸训练）"><a href="#7-Multi-Scale-Training（多尺寸训练）" class="headerlink" title="7.Multi-Scale Training（多尺寸训练）"></a>7.Multi-Scale Training（多尺寸训练）</h3></li><li><p>因为<strong>Yolo v2</strong>去掉了全连接层，只有卷积层与池化层，所以对于网络的输入大小，并没有限制，整个网络的<strong>降采样倍数为32</strong>，只要输入的特征图尺寸为32的倍数即可。<strong>所以Yolo v2可以使用不同尺寸的输入图片训练，来使模型适应不同分辨率的图片，让模型更鲁棒</strong>。</p></li><li><strong>具体来说就是在训练过程中每间隔一定的iterations（论文中是10）之后改变模型的输入图片大小</strong>。由于<strong>YOLOv2</strong>的下采样总步长为<strong>32</strong>，输入图片大小选择一系列为<strong>32倍数</strong>的值：<strong>{320,  352, ……, 608}</strong>，输入图片最小为<strong>320×320</strong>，此时对应的特征图大小为<strong>10×10</strong>（和<strong>Convolutional With Anchor Boxes</strong>中提到要是奇数相悖，但是问题也不是很大），而输入图片最大为<strong>608×608</strong>，对应的特征图大小为<strong>19×19</strong>。在训练过程，每隔<strong>10个iterations</strong>随机选择一种输入图片大小，然后只需要修改对最后检测层的处理就可以重新训练。</li><li>在<strong>小尺寸</strong>图片检测中，<strong>YOLO v2</strong>效果很好，输入为<strong>228×228</strong>的时候，帧率达到<strong>91FPS</strong>，<strong>mAP几乎和Faster R-CNN的水准相同</strong>。在<strong>大尺寸</strong>图片检测中，<strong>YOLO v2</strong>也达到了先进水平，在VOC2007数据集上<strong>mAP为78.6%</strong>，仍然高于平均水准，下图是<strong>YOLO v2</strong>和其他网络的效果对比：<br>  <img src="/image/目标检测之YOLO理解与总结/13.png" alt=""></li></ul><h3 id="8-BackBone-Darknet-19"><a href="#8-BackBone-Darknet-19" class="headerlink" title="8.BackBone: Darknet-19"></a>8.BackBone: Darknet-19</h3><ul><li>YOLOv2采用了一个新的网络，称为<strong>Darknet-19</strong>，包括19个卷积层和5个maxpooling层，在<code>ImageNet</code>数据集上，<strong>Darknet-19的top-1准确度为72.9%，top-5准确度为91.2%，但是模型参数相对小一些</strong>。使用Darknet-19之后，YOLOv2的mAP值没有显著提升，但是<strong>计算量却可以减少约33%</strong>。<br>  <img src="/image/目标检测之YOLO理解与总结/14.png" alt=""></li></ul><h2 id="4-3-网络结构"><a href="#4-3-网络结构" class="headerlink" title="4.3 网络结构"></a>4.3 网络结构</h2><p><img src="/image/目标检测之YOLO理解与总结/11.png" alt=""></p><h2 id="4-4-关于网络的训练细节"><a href="#4-4-关于网络的训练细节" class="headerlink" title="4.4 关于网络的训练细节"></a>4.4 关于网络的训练细节</h2><blockquote><p>We use a weight decay of 0.0005 and momentum of 0.9. We use a weight decay of 0.0005 and momentum of 0.9.We use a similar data augmentation to YOLO and SSD with<br>random crops, color shifting, etC. We use the same training<br>strategy on COCO and VOC.</p></blockquote><p>这是论文给出的原话,至于如何匹配正负样本,如何计算误差等细节并没有多讲,我将会在YOLO V3部分具体分析。</p><h1 id="5-YOLO-V3"><a href="#5-YOLO-V3" class="headerlink" title="5.YOLO V3"></a>5.YOLO V3</h1><h2 id="5-1-网络结构改进"><a href="#5-1-网络结构改进" class="headerlink" title="5.1 网络结构改进"></a>5.1 网络结构改进</h2><h3 id="1-BackBone-Darknet-53"><a href="#1-BackBone-Darknet-53" class="headerlink" title="1. BackBone: Darknet-53"></a>1. BackBone: Darknet-53</h3><ul><li>作者对YOLO v2时期的<code>Darknet-19</code>进行了升级,借鉴了<code>ResNet</code>的<strong>残差单元</strong>，<strong>在加深网络层数提高精度的同时大大降低计算量</strong>，接下来我们来具体剖析，先上backbone的结构图：<br>  <img src="/image/目标检测之YOLO理解与总结/15.png" alt=""></li><li><p>我们可以看到在<strong>Darknet-53</strong>中)，与<strong>Darknet-19</strong>最大的不同是没有池化层和全连接层,张量是通过卷积层来实现<strong>下采样</strong>的。比如stride=(2, 2)，这就等于将图像边长缩小了一半，整个特征图缩小$ 2^2 $ 倍。在<code>YOLO v3</code>中，最终要经历5次缩小，会将特征图缩小到原输入尺寸的$ \frac {1} {2^5} $ ，即$ \frac {1} {32} $。输入为<strong>416×416</strong> ，则输出为<strong>13×13(416/32 = 13)</strong> 。需要注意的是，最后三层<code>Avgpool、Connected</code>和 <code>softmax layer</code>是用于在 <code>Imagenet</code>数据集上作分类训练用的。当我们用 <code>Darknet-53</code> 层对图片提取特征时，是不会用到这三层的。</p></li><li><p>这个backbone的效果也非常好，<strong>比起同精度的ResNet-152速度也是它的两倍</strong>，具体见下图：</p></li></ul><p><img src="/image/目标检测之YOLO理解与总结/16.png" alt=""></p><h3 id="2-整体网络架构"><a href="#2-整体网络架构" class="headerlink" title="2.整体网络架构"></a>2.整体网络架构</h3><p><img src="/image/目标检测之YOLO理解与总结/17.png" alt=""></p><h2 id="5-2-目标边界框的预测"><a href="#5-2-目标边界框的预测" class="headerlink" title="5.2 目标边界框的预测"></a>5.2 目标边界框的预测</h2><p>YOLO V3的边界框预测与YOLO V2一样，如下图所示<br><img src="/image/目标检测之YOLO理解与总结/18.png" alt=""></p><blockquote><p>将tx，ty传入sigmoid函数能够限制范围在0-1内，避免中心点超出网格</p></blockquote><h2 id="5-3-正负样本的匹配"><a href="#5-3-正负样本的匹配" class="headerlink" title="5.3 正负样本的匹配"></a>5.3 正负样本的匹配</h2><blockquote><p>YOLOv3 predicts an objectness score for each bounding<br>box using logistic regression. This should be 1 if the bound-<br>ing box prior overlaps a ground truth object by more than<br>any other bounding box prior. If the bounding box prior<br>is not the best but does overlap a ground truth object by<br>more than some threshold we ignore the prediction, follow-<br>ing [17]. We use the threshold of .5. Unlike [17] our system<br>only assigns one bounding box prior for each ground truth<br>object. If a bounding box prior is not assigned to a ground<br>truth object it incurs no loss for coordinate or class predic-<br>tions, only objectness.</p></blockquote><p>从原论文可知，<strong>YOLO V3</strong>会为每个<code>ground truth</code>分配一个正样本，也就是一张图片有几个<code>ground truth</code>，就会有几个正样本。对于每个<code>ground truth</code>，会将与它重叠最大，也就是IoU最大的<code>bounding box</code>作为正样本。对于IoU大于设定的阈值,但不是最大的<code>bounding box</code>，将会直接丢弃。如果 某个<code>bounding box</code>没有被分配为正样本，那么它没有定位损失，类别损失，仅仅有<code>objectness loss(置信度的损失)</code>。</p><h2 id="5-4-损失函数的计算"><a href="#5-4-损失函数的计算" class="headerlink" title="5.4 损失函数的计算"></a>5.4 损失函数的计算</h2><p>YOLO V3损失函数计算如下图所示</p><p><img src="/image/目标检测之YOLO理解与总结/19.png" alt=""></p><h3 id="5-4-1-目标置信度损失"><a href="#5-4-1-目标置信度损失" class="headerlink" title="5.4.1 目标置信度损失"></a>5.4.1 目标置信度损失</h3><p><img src="/image/目标检测之YOLO理解与总结/20.png" alt=""></p><p>置信度损失用的是<strong>二值交叉熵损失(BCE)</strong>，其中o$ <em>{i} $∈[0,1]，表示预测目标边界框与真实目标边界框的<strong>IoU</strong>，c为预测值，$ \hat{C}</em>{i} $为c通过Sigmoid函数得到的预测置信度，N为正负样本个数。</p><h3 id="5-4-2-目标类别损失"><a href="#5-4-2-目标类别损失" class="headerlink" title="5.4.2 目标类别损失"></a>5.4.2 目标类别损失</h3><p><img src="/image/目标检测之YOLO理解与总结/21.png" alt=""><br>类别损失用的也是<strong>二值交叉熵损失(BCE)</strong>，其中O$ <em>{ij} $∈{0, 1}，表示预测目标边界框i中是否存在第j类目标，C$ </em>{ij} $为预测值，$ \hat{C}<em>{ij} $为C$ </em>{ij} $通过Sigmoid函数得到的目标概率，N$ _{pos} $为正样本个数</p><h3 id="5-4-3-目标定位损失"><a href="#5-4-3-目标定位损失" class="headerlink" title="5.4.3 目标定位损失"></a>5.4.3 目标定位损失</h3><p><img src="/image/目标检测之YOLO理解与总结/22.png" alt=""></p><blockquote><p>其中左下角的g就是右图中的b</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a&gt;1.背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;我们知道，目标检测通常分为两个步骤： &lt;strong&gt;（1）生成bounding box（边界框）（2）对物体分
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="YOLO" scheme="http://yoursite.com/tags/YOLO/"/>
    
  </entry>
  
  <entry>
    <title>目标检测mAP计算以及coco评价标准</title>
    <link href="http://yoursite.com/2020/11/24/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BmAP%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8Acoco%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/"/>
    <id>http://yoursite.com/2020/11/24/目标检测mAP计算以及coco评价标准/</id>
    <published>2020-11-24T03:39:05.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>当我们使用目标检测数据集（如COCO）进行评估时，最后会得到一个评估列表，如下图<br><img src="/image/目标检测mAP计算以及coco评价标准/1.png" alt=""></p><h1 id="2-目标检测中常见指标"><a href="#2-目标检测中常见指标" class="headerlink" title="2.目标检测中常见指标"></a>2.目标检测中常见指标</h1><h2 id="2-1精确率与召回率"><a href="#2-1精确率与召回率" class="headerlink" title="2.1精确率与召回率"></a>2.1精确率与召回率</h2><p>下面先引入目标检测中常见的一些指标</p><ul><li><strong>TP(True Positive)：</strong>IoU &gt; 0.5的检测框数（同一GT只计算一次） </li><li><strong>FP(False Positive)：</strong>IoU &lt;= 0.5的检测框（或者是检测到同一个GT的多余检测框数量）</li><li><strong>FN(False Negative)：</strong>没有检测到的GT的数量</li></ul><p><strong>Precision(精确率)： TP / (TP + FP)</strong>模型预测的所有目标中，预测正确的比例</p><p><strong>Recall(召回率)：TP / (TP + FN)</strong>所有真实目标中，模型预测正确的目标比例</p><blockquote><p>精确率与召回率缺一不可，举例说明：当一张图片中有5个检测对象时，假如算法检测到了10个个目标（其中5个正确，5个错误），那么TP=5，FP=5，FN=0，精确率=0.5，召回率=1。假如算法检测到了3个目标（都正确），那么TP=3，FP=0，FN=2，精确率=1，召回率=0.6。由此可以说明，单一的精确率与召回率，无法完全衡量结果的好坏。</p></blockquote><h2 id="2-2-AP"><a href="#2-2-AP" class="headerlink" title="2.2 AP"></a>2.2 AP</h2><p><strong>AP</strong>定义为P-R曲线下的面积<br><strong>P-R曲线</strong>：Precision-Recall曲线</p><p>举例如下图<br><img src="/image/目标检测mAP计算以及coco评价标准/2.png" alt=""></p><p>本图为目标检测中某个类别（比如检测猫）置信度取不同阈值得到的精确率与召回率绘制成的P-R曲线，其面积为：</p><p><strong>S = (0.14-0)×(0.28-0.14)×1.0+(0.42-0.28)×1.0+(0.57-0.42)×1.0+(0.71-0.57)×0.71=0.6694</strong></p><p>因此<strong>AP=0.6694</strong></p><h2 id="2-3-mAP"><a href="#2-3-mAP" class="headerlink" title="2.3 mAP"></a>2.3 mAP</h2><p><strong>mAP</strong>即为各个类别计算的AP取均值，比如目标检测的目标有猫、狗、兔子，将三个类别求得的AP相加除以三即可。</p><h1 id="3-COCO评价指标"><a href="#3-COCO评价指标" class="headerlink" title="3.COCO评价指标"></a>3.COCO评价指标</h1><p>再回过来看上面那张图<br><img src="/image/目标检测mAP计算以及coco评价标准/1.png" alt=""></p><p><strong>IoU</strong>代表交并比，可以观察算法在定位方面的指标</p><p><strong>area</strong>代表检测面积的大小，可以观察算法在检测大目标与小目标方面的指标</p><p><strong>maxDets</strong>代表检测目标数，可以观察算法在对多目标检测方面的指标</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h1&gt;&lt;p&gt;当我们使用目标检测数据集（如COCO）进行评估时，最后会得到一个评估列表，如下图&lt;br&gt;&lt;img src=&quot;/image/目
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="评估指标" scheme="http://yoursite.com/tags/%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>kaggle实战：Dog Breed Identification</title>
    <link href="http://yoursite.com/2020/11/11/kaggle%E5%AE%9E%E6%88%98%EF%BC%9ADog%20Breed%20Identification/"/>
    <id>http://yoursite.com/2020/11/11/kaggle实战：Dog Breed Identification/</id>
    <published>2020-11-11T13:26:20.000Z</published>
    <updated>2022-06-06T03:22:14.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将使用pytorch框架解决kaggle竞赛中犬种识别挑战的问题，该比赛的数据集为ImageNet数据集的子集，在本次挑战中，我们将尝试分类120种不同的犬种</p><blockquote><p>竞赛网址：<a href="https://www.kaggle.com/c/dog-breed-identification">https://www.kaggle.com/c/dog-breed-identification</a><br>数据集可在该网址获取</p></blockquote><h1 id="导入相关模块"><a href="#导入相关模块" class="headerlink" title="导入相关模块"></a>导入相关模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> random<br></code></pre></td></tr></table></figure><h1 id="设置随机数种子"><a href="#设置随机数种子" class="headerlink" title="设置随机数种子"></a>设置随机数种子</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">random.seed(<span class="hljs-number">0</span>)<br>torch.manual_seed(<span class="hljs-number">0</span>)<br>torch.cuda.manual_seed(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="整理数据集"><a href="#整理数据集" class="headerlink" title="整理数据集"></a>整理数据集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data_dir = <span class="hljs-string">&#x27;./dog-breed-identification&#x27;</span>  <span class="hljs-comment"># 数据集目录</span><br>label_file, train_dir, test_dir = <span class="hljs-string">&#x27;labels.csv&#x27;</span>, <span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>  <span class="hljs-comment"># data_dir中的文件夹、文件</span><br>new_data_dir = <span class="hljs-string">&#x27;./train_valid_test&#x27;</span>  <span class="hljs-comment"># 整理之后的数据存放的目录</span><br>valid_ratio = <span class="hljs-number">0.1</span>  <span class="hljs-comment"># 验证集所占比例</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mkdir_if_not_exist</span>(<span class="hljs-params">path</span>):<br>  <span class="hljs-comment"># 若目录path不存在，则创建目录</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(os.path.join(*path)):<br>    os.makedirs(os.path.join(*path))<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reorg_dog_data</span>(<span class="hljs-params">data_dir, label_file, train_dir, test_dir, new_data_dir, valid_ratio</span>):<br>  <span class="hljs-comment"># 读取训练数据标签</span><br>  labels = pd.read_csv(os.path.join(data_dir, label_file))<br>  id2label = &#123;Id: label <span class="hljs-keyword">for</span> Id, label <span class="hljs-keyword">in</span> labels.values&#125;  <span class="hljs-comment"># (key: value): (id: label)</span><br><br>  <span class="hljs-comment"># 随机打乱训练数据</span><br>  train_files = os.listdir(os.path.join(data_dir, train_dir))<br>  random.shuffle(train_files)    <br><br>  <span class="hljs-comment"># 原训练集</span><br>  valid_ds_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(train_files) * valid_ratio)  <span class="hljs-comment"># 验证集大小</span><br>  <span class="hljs-keyword">for</span> i, file <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_files):<br>    img_id = file.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># file是形式为id.jpg的字符串</span><br>    img_label = id2label[img_id]<br>    <span class="hljs-keyword">if</span> i &lt; valid_ds_size:<br>      mkdir_if_not_exist([new_data_dir, <span class="hljs-string">&#x27;valid&#x27;</span>, img_label])<br>      shutil.copy(os.path.join(data_dir, train_dir, file),<br>            os.path.join(new_data_dir, <span class="hljs-string">&#x27;valid&#x27;</span>, img_label))<br>    <span class="hljs-keyword">else</span>:<br>      mkdir_if_not_exist([new_data_dir, <span class="hljs-string">&#x27;train&#x27;</span>, img_label])<br>      shutil.copy(os.path.join(data_dir, train_dir, file),<br>            os.path.join(new_data_dir, <span class="hljs-string">&#x27;train&#x27;</span>, img_label))<br>    mkdir_if_not_exist([new_data_dir, <span class="hljs-string">&#x27;train_valid&#x27;</span>, img_label])<br>    shutil.copy(os.path.join(data_dir, train_dir, file),<br>          os.path.join(new_data_dir, <span class="hljs-string">&#x27;train_valid&#x27;</span>, img_label))<br><br>  <span class="hljs-comment"># 测试集</span><br>  mkdir_if_not_exist([new_data_dir, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;unknown&#x27;</span>])<br>  <span class="hljs-keyword">for</span> test_file <span class="hljs-keyword">in</span> os.listdir(os.path.join(data_dir, test_dir)):<br>    shutil.copy(os.path.join(data_dir, test_dir, test_file),<br>          os.path.join(new_data_dir, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;unknown&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reorg_dog_data(data_dir, label_file, train_dir, test_dir, new_data_dir, valid_ratio)<br></code></pre></td></tr></table></figure><h1 id="图像增广"><a href="#图像增广" class="headerlink" title="图像增广"></a>图像增广</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">transform_train = transforms.Compose([<br>  <span class="hljs-comment"># 随机对图像裁剪出面积为原图像面积0.08~1倍、且高和宽之比在3/4~4/3的图像，再放缩为高和宽均为224像素的新图像</span><br>  transforms.RandomResizedCrop(<span class="hljs-number">224</span>, scale=(<span class="hljs-number">0.08</span>, <span class="hljs-number">1.0</span>), ratio=(<span class="hljs-number">3.0</span>/<span class="hljs-number">4.0</span>, <span class="hljs-number">4.0</span>/<span class="hljs-number">3.0</span>)),<br>  <span class="hljs-comment"># 以0.5的概率随机水平翻转</span><br>  transforms.RandomHorizontalFlip(),<br>  <span class="hljs-comment"># 随机更改亮度、对比度和饱和度</span><br>  transforms.ColorJitter(brightness=<span class="hljs-number">0.4</span>, contrast=<span class="hljs-number">0.4</span>, saturation=<span class="hljs-number">0.4</span>),<br>  transforms.ToTensor(),<br>  <span class="hljs-comment"># 对各个通道做标准化，(0.485, 0.456, 0.406)和(0.229, 0.224, 0.225)是在ImageNet上计算得的各通道均值与方差</span><br>  transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])  <span class="hljs-comment"># ImageNet上的均值和方差</span><br>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在测试集上的图像增强只做确定性的操作</span><br>transform_test = transforms.Compose([<br>  transforms.Resize(<span class="hljs-number">256</span>),<br>  <span class="hljs-comment"># 将图像中央的高和宽均为224的正方形区域裁剪出来</span><br>  transforms.CenterCrop(<span class="hljs-number">224</span>),<br>  transforms.ToTensor(),<br>  transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br></code></pre></td></tr></table></figure><h1 id="数据集导入"><a href="#数据集导入" class="headerlink" title="数据集导入"></a>数据集导入</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">train_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, <span class="hljs-string">&#x27;train&#x27;</span>),<br>                       transform=transform_train)<br>valid_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, <span class="hljs-string">&#x27;valid&#x27;</span>),<br>                       transform=transform_test)<br>train_valid_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, <span class="hljs-string">&#x27;train_valid&#x27;</span>),<br>                       transform=transform_train)<br>test_ds = torchvision.datasets.ImageFolder(root=os.path.join(new_data_dir, <span class="hljs-string">&#x27;test&#x27;</span>),<br>                       transform=transform_test)<br><br>batch_size = <span class="hljs-number">128</span><br>train_iter = torch.utils.data.DataLoader(train_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>train_valid_iter = torch.utils.data.DataLoader(train_valid_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>test_iter = torch.utils.data.DataLoader(test_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h1 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h1><p>由于此竞赛使用了ImageNet数据集的子集，我们可以使用迁移学习的方法，使用在ImageNet完整数据集上预训练的模型来抽取图像特征。</p><p>此处我们使用预训练的ResNet-34模型，直接复用预训练模型在输出层的输入，即抽取的特征，然后我们重新定义输出层，本次我们仅对重定义的输出层的参数进行训练，而对于用于抽取特征的部分，我们保留预训练模型的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_net</span>(<span class="hljs-params">device</span>):<br>  finetune_net = models.resnet34(pretrained=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 预训练的resnet34网络</span><br>  finetune_net.load_state_dict(torch.load(<span class="hljs-string">&#x27;./dog-breed-identification/resnet34-333f7ec4.pth&#x27;</span>))<br>  <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> finetune_net.parameters():  <span class="hljs-comment"># 冻结参数</span><br>      param.requires_grad = <span class="hljs-literal">False</span><br>  <span class="hljs-comment"># 原finetune_net.fc是一个输入单元数为512，输出单元数为1000的全连接层</span><br>  <span class="hljs-comment"># 替换掉原finetune_net.fc，新finetuen_net.fc中的模型参数会记录梯度</span><br>  finetune_net.fc = nn.Sequential(<br>      nn.Linear(in_features=<span class="hljs-number">512</span>, out_features=<span class="hljs-number">256</span>),<br>      nn.ReLU(),<br>      nn.Linear(in_features=<span class="hljs-number">256</span>, out_features=<span class="hljs-number">120</span>)  <span class="hljs-comment"># 120是输出类别数</span><br>  )<br>  <span class="hljs-keyword">return</span> finetune_net<br></code></pre></td></tr></table></figure><blockquote><p>若将pretrained设为true，会自动下载预训练好的resnet34网络，但是速度较慢，且容易断，还没断点续传功能<br> resnet34-333f7ec4.pth可在网络中搜素下载</p></blockquote><h1 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_loss_acc</span>(<span class="hljs-params">data_iter, net, device</span>):<br>  loss = nn.CrossEntropyLoss()<br>  is_training = net.training<br>  net.<span class="hljs-built_in">eval</span>()<br>  l_sum, acc_sum, n = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  <span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>      X, y = X.to(device), y.to(device)<br>      y_hat = net(X)<br>      l = loss(y_hat, y)<br>      l_sum += l.item() * y.shape[<span class="hljs-number">0</span>]<br>      acc_sum += (y_hat.argmax(dim=<span class="hljs-number">1</span>) == y).<span class="hljs-built_in">sum</span>().item()<br>      n += y.shape[<span class="hljs-number">0</span>]<br>  net.train(is_training)<br>  <span class="hljs-keyword">return</span> l_sum / n, acc_sum / n<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">net, train_iter, valid_iter, num_epochs, lr, wd, device, lr_period,</span><br><span class="hljs-params">      lr_decay</span>):<br>  loss = nn.CrossEntropyLoss()<br>  optimizer = optim.SGD(net.fc.parameters(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=wd)<br>  net = net.to(device)<br>  <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    train_l_sum, n, start = <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>, time.time()<br>    <span class="hljs-keyword">if</span> epoch &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> epoch % lr_period == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 每lr_period个epoch，学习率衰减一次</span><br>      lr = lr * lr_decay<br>      <span class="hljs-keyword">for</span> param_group <span class="hljs-keyword">in</span> optimizer.param_groups:<br>        param_group[<span class="hljs-string">&#x27;lr&#x27;</span>] = lr<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>      X, y = X.to(device), y.to(device)<br>      optimizer.zero_grad()<br>      y_hat = net(X)<br>      l = loss(y_hat, y)<br>      l.backward()<br>      optimizer.step()<br>      train_l_sum += l.item() * y.shape[<span class="hljs-number">0</span>]<br>      n += y.shape[<span class="hljs-number">0</span>]<br>    time_s = <span class="hljs-string">&quot;time %.2f sec&quot;</span> % (time.time() - start)<br>    <span class="hljs-keyword">if</span> valid_iter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      valid_loss, valid_acc = evaluate_loss_acc(valid_iter, net, device)<br>      epoch_s = (<span class="hljs-string">&quot;epoch %d, train loss %f, valid loss %f, valid acc %f, &quot;</span><br>             % (epoch + <span class="hljs-number">1</span>, train_l_sum / n, valid_loss, valid_acc))<br>    <span class="hljs-keyword">else</span>:<br>      epoch_s = (<span class="hljs-string">&quot;epoch %d, train loss %f, &quot;</span><br>             % (epoch + <span class="hljs-number">1</span>, train_l_sum / n))<br>    <span class="hljs-built_in">print</span>(epoch_s + time_s + <span class="hljs-string">&#x27;, lr &#x27;</span> + <span class="hljs-built_in">str</span>(lr))<br></code></pre></td></tr></table></figure><h1 id="最终超参数选择"><a href="#最终超参数选择" class="headerlink" title="最终超参数选择"></a>最终超参数选择</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs, lr_period, lr_decay = <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.1</span><br>lr, wd = <span class="hljs-number">0.03</span>, <span class="hljs-number">1e-4</span><br>device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>net = get_net(device)<br>train(net, train_iter, valid_iter, num_epochs, lr, wd, device, lr_period, lr_decay)<br></code></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = get_net(device)<br>train(net, train_valid_iter, <span class="hljs-literal">None</span>, num_epochs, lr, wd, device, lr_period, lr_decay)<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用训练好的模型队测试数据进行预测，并写入<strong>submission.csv</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文将使用pytorch框架解决kaggle竞赛中犬种识别挑战的问题，该比赛的数据集为ImageNet数据集的子集，在本次挑战中，我们将尝试
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
      <category term="迁移学习" scheme="http://yoursite.com/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>彻底解决git clone太慢的头疼问题</title>
    <link href="http://yoursite.com/2020/03/15/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3git%20clone%E5%A4%AA%E6%85%A2%E7%9A%84%E5%A4%B4%E7%96%BC%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/15/彻底解决git clone太慢的头疼问题/</id>
    <published>2020-03-15T08:14:03.000Z</published>
    <updated>2022-06-06T03:22:14.525Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间我电脑<code>git clone</code>的速度一直比较慢，在网上搜了许多比较坑的经验贴，都没有解决。</p><p>最近由于经常需要用到<code>git clone</code>，我就又静下心在网上开始找解决方案，最后终于解决了</p><p>我解决的方法如下：</p><p>首先查找域名对应的ip地址，并修改hosts文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nslookup github.global.ssl.fastly.Net<br>nslookup github.com <br></code></pre></td></tr></table></figure><p>将下列内容加入 /etc/hosts文件中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">31.13.97.245 github.global-ssl.fastly.net<br>13.229.188.59 github.com<br></code></pre></td></tr></table></figure><blockquote><p>我不太懂计算机网络，但是我发现网络上许多类似教程中给的ip地址和我在终端获取到的是不一样的，这也是跟着许多教程走无效的原因，所以得自行获取</p></blockquote><p>刷新DNS缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/networking restart // linux<br>ipconfig /flushdns                 // windows<br>sudo dscacheutil -flushcache       // macos<br></code></pre></td></tr></table></figure><p>经过以上步骤，我的git clone速度从可怜的几kb到了十余MB</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这段时间我电脑&lt;code&gt;git clone&lt;/code&gt;的速度一直比较慢，在网上搜了许多比较坑的经验贴，都没有解决。&lt;/p&gt;
&lt;p&gt;最近由于经常需要用到&lt;code&gt;git clone&lt;/code&gt;，我就又静下心在网上开始找解决方案，最后终于解决了&lt;/p&gt;
&lt;p&gt;我解决的方
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>快速幂算法详解</title>
    <link href="http://yoursite.com/2020/03/03/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/03/快速幂算法详解/</id>
    <published>2020-03-03T13:31:05.000Z</published>
    <updated>2022-06-06T03:22:14.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p>如果有三个整数<code>a，n，k</code>，要让我们求出<code>a^n</code>的后<code>k</code>位，你会怎么求？</p><p>也许有人可能会想到直接将a^n次求出，然后通过取余求出后k位</p><p>但显然，这样是不现实的，因为我们知道当这个数很大时，即使是<code>long long</code>型的变量也存放不下。</p><h2 id="二、前置知识"><a href="#二、前置知识" class="headerlink" title="二、前置知识"></a>二、前置知识</h2><p>当我们解决问题之前，首先来看一下，我们需要了解的一些知识。</p><p><img src="./image/快速幂算法详解/1.png" alt=""></p><p><img src="/image/快速幂算法详解/2.png" alt=""></p><h2 id="三、解决问题"><a href="#三、解决问题" class="headerlink" title="三、解决问题"></a>三、解决问题</h2><p>解决一个问题的最好方法，往往是从实例中应用，所以我们不妨假设<code>a = 3, n = 45</code><br>此外，如果计算机基础较好的读者很容易得到<code>45 = (101101)2</code></p><p>于是，我们可以得到如下推导</p><p><img src="/image/快速幂算法详解/3.png" alt=""></p><blockquote><p>我们可以发现，如果最后一步中每一项去掉*后面的乘数，则每一项的值都为后一项的平方</p></blockquote><h2 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, n, k;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; n &gt;&gt; k) &#123;<br>        <span class="hljs-type">int</span> mod = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, k);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>; <span class="hljs-comment">// 先定义最终结果为1</span><br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 判断n的二进制最后一位是0还是1</span><br>                ans = (ans * a) % mod; <span class="hljs-comment">// 只有当二进制最后1位为1时，这一项底数才为a，否则为1</span><br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 二进制右移一位</span><br>            a = (a * a) % mod; <span class="hljs-comment">// 如之前推导，前一项为后一项平方</span><br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、问题&quot;&gt;&lt;a href=&quot;#一、问题&quot; class=&quot;headerlink&quot; title=&quot;一、问题&quot;&gt;&lt;/a&gt;一、问题&lt;/h2&gt;&lt;p&gt;如果有三个整数&lt;code&gt;a，n，k&lt;/code&gt;，要让我们求出&lt;code&gt;a^n&lt;/code&gt;的后&lt;code&gt;k&lt;/cod
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
</feed>
