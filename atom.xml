<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zh&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-06-06T06:08:30.130Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native中渲染的坑</title>
    <link href="http://yoursite.com/2022/06/06/React%20Native%E4%B8%AD%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2022/06/06/React Native中渲染的坑/</id>
    <published>2022-06-06T03:55:00.000Z</published>
    <updated>2022-06-06T06:08:30.130Z</updated>
    
    <content type="html"><![CDATA[<p>解决方案来自<a href="https://stackoverflow.com/questions/52368342/invariant-violation-text-strings-must-be-rendered-within-a-text-component">StackOverflow</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当<strong>React Native</strong>从 0.54 升级到 0.57，代码报了以下错误</p><p><code>Invariant Violation: Text strings must be rendered within a &lt;Text&gt; component</code></p><p>乍一看好像是文本没有写在<code>&lt;Text&gt;</code>标签里，查了一下代码发现没有这个问题。最后网上搜索后解决</p><p>以下为伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">condition &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>需要修改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">condition ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span> : <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>这是因为<code>condition</code>为<code>undefined</code>时，将不会渲染任何组件，而<code>null</code>或<code>空数组</code>可以安全的显示空白区域</p><blockquote><p>Tips: undefined &amp;&amp; true 与 true &amp;&amp; undefined 的结果都为 undefined</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决方案来自&lt;a href=&quot;https://stackoverflow.com/questions/52368342/invariant-violation-text-strings-must-be-rendered-within-a-text-component&quot;&gt;St
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化规范</title>
    <link href="http://yoursite.com/2022/04/14/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2022/04/14/前端模块化规范/</id>
    <published>2022-04-14T13:32:24.000Z</published>
    <updated>2022-04-18T13:55:31.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>模块化</code>可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>Node.js是<code>commonJS</code>规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用exports），用<code>require</code>加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义模块math.js</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; <span class="hljs-comment">//在这里写上需要向外暴露的函数、变量</span><br>  <span class="hljs-attr">add</span>: add,<br>  <span class="hljs-attr">basicNum</span>: basicNum<br>&#125;<br><br><span class="hljs-comment">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="hljs-keyword">var</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./math&#x27;</span>);<br>math.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 引用核心模块时，不需要带路径</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br>http.<span class="hljs-title function_">createService</span>(...).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>commonJS用<code>同步</code>的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><h2 id="AMD和requireJS"><a href="#AMD和requireJS" class="headerlink" title="AMD和requireJS"></a>AMD和requireJS</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置<code>require.config()</code>并规定项目中用到的基础模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** 网页中引入require.js及main.js **/</span><br>&lt;script src=<span class="hljs-string">&quot;js/require.js&quot;</span> data-main=<span class="hljs-string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;<br><br><span class="hljs-comment">/** main.js 入口文件/主模块 **/</span><br><span class="hljs-comment">// 首先用config()指定各模块路径和引用名</span><br><span class="hljs-built_in">require</span>.<span class="hljs-title function_">config</span>(&#123;<br>  <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">&quot;js/lib&quot;</span>,<br>  <span class="hljs-attr">paths</span>: &#123;<br>    <span class="hljs-string">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;jquery.min&quot;</span>,  <span class="hljs-comment">//实际路径为js/lib/jquery.min.js</span><br>    <span class="hljs-string">&quot;underscore&quot;</span>: <span class="hljs-string">&quot;underscore.min&quot;</span>,<br>  &#125;<br>&#125;);<br><span class="hljs-comment">// 执行基本操作</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;jquery&quot;</span>,<span class="hljs-string">&quot;underscore&quot;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">$,_</span>)&#123;<br>  <span class="hljs-comment">// some code here</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义math.js模块</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">add</span>: add,<br>        basicNum :basicNum<br>    &#125;;<br>&#125;);<br><span class="hljs-comment">// 定义一个依赖underscore.js的模块</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;underscore&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">_</span>)&#123;<br>  <span class="hljs-keyword">var</span> classify = <span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)&#123;<br>    _.<span class="hljs-title function_">countBy</span>(list,<span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)&#123;<br>      <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">30</span> ? <span class="hljs-string">&#x27;old&#x27;</span> : <span class="hljs-string">&#x27;young&#x27;</span>;<br>    &#125;)<br>  &#125;;<br>  <span class="hljs-keyword">return</span> &#123;<br>    classify :classify<br>  &#125;;<br>&#125;)<br><br><span class="hljs-comment">// 引用模块，将模块放在[]内</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;math&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">$, math</span>)&#123;<br>  <span class="hljs-keyword">var</span> sum = math.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>  $(<span class="hljs-string">&quot;#sum&quot;</span>).<span class="hljs-title function_">html</span>(sum);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">define</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) &#123; <br>    <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>      b.<span class="hljs-title function_">foo</span>()<br>    &#125; <br>&#125;);<br><br></code></pre></td></tr></table></figure></p><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** AMD写法 **/</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) &#123; <br>     <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span><br>    a.<span class="hljs-title function_">doSomething</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>        b.<span class="hljs-title function_">doSomething</span>()<br>    &#125; <br>&#125;);<br><br><span class="hljs-comment">/** CMD写法 **/</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>); <span class="hljs-comment">//在需要时申明</span><br>    a.<span class="hljs-title function_">doSomething</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>);<br>        b.<span class="hljs-title function_">doSomething</span>();<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">/** sea.js **/</span><br><span class="hljs-comment">// 定义模块 math.js</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery.js&#x27;</span>);<br>    <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-built_in">exports</span>.<span class="hljs-property">add</span> = add;<br>&#125;);<br><span class="hljs-comment">// 加载模块</span><br>seajs.<span class="hljs-title function_">use</span>([<span class="hljs-string">&#x27;math.js&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">math</span>)&#123;<br>    <span class="hljs-keyword">var</span> sum = math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** 定义模块 math.js **/</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-keyword">export</span> &#123; basicNum, add &#125;;<br><br><span class="hljs-comment">/** 引用模块 **/</span><br><span class="hljs-keyword">import</span> &#123; basicNum, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">ele</span>) &#123;<br>    ele.<span class="hljs-property">textContent</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">99</span> + basicNum);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/** export default **/</span><br><span class="hljs-comment">//定义输出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; basicNum, add &#125;;<br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">ele</span>) &#123;<br>    ele.<span class="hljs-property">textContent</span> = math.<span class="hljs-title function_">add</span>(<span class="hljs-number">99</span> + math.<span class="hljs-property">basicNum</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><h2 id="ES6-Module和CommonJS的差异"><a href="#ES6-Module和CommonJS的差异" class="headerlink" title="ES6 Module和CommonJS的差异"></a>ES6 Module和CommonJS的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li><p>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</p></li><li><p>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</p></li></ul><p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;模块化&lt;/code&gt;可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中继承的方式</title>
    <link href="http://yoursite.com/2022/04/14/Javascript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2022/04/14/Javascript中继承的方式/</id>
    <published>2022-04-14T10:37:24.000Z</published>
    <updated>2022-04-18T13:56:02.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇的学习建立在对原型链的理解之上，如果对原型链还不够了解，可以先自行学习相关知识</p><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-string">&#x27;eat shit&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// animal</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog.<span class="hljs-property">eat</span>) <span class="hljs-comment">// eat shit</span><br></code></pre></td></tr></table></figure><p>原型链继承的本质就是将需要继承的构造函数（Dog）的原型<code>prototype</code>指向被继承的构造函数（Animal）的<code>实例</code>，这样就获得Animal上的所有属性与方法了。</p><p><strong>缺点</strong>：</p><ul><li>原型中包含的引用类型属性将被所有实例共享；</li><li>子类在实例化的时候不能给父类构造函数传参；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-string">&#x27;eat shit&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()<br><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><span class="hljs-keyword">const</span> dog2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><br>dog1.<span class="hljs-property">type</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog2.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br></code></pre></td></tr></table></figure><h2 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2.借用构造函数继承"></a>2.借用构造函数继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-string">&#x27;eat shit&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()<br><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><span class="hljs-keyword">const</span> dog2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><br>dog1.<span class="hljs-property">type</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog2.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br><br></code></pre></td></tr></table></figure><p>核心代码是<code>Animal.call(this)</code>，在创建子类<code>Dog</code>的实例时调用父类<code>Animal</code>的构造函数，这样就会把父类的每个属性都给子类复制一份</p><p><strong>缺点：</strong></p><ul><li>只能继承父类的<code>实例</code>属性和方法，不能继承原型属性/方法(因为它只执行了父类构造函数里的内容)</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = <span class="hljs-string">&#x27;eat shit&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Dog</span><br><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;王一琳&#x27;</span>)<br><span class="hljs-keyword">const</span> dog2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;刘贝利&#x27;</span>)<br><br>dog1.<span class="hljs-property">type</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog2.<span class="hljs-property">type</span>) <span class="hljs-comment">// [0, 1, 2]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-property">eat</span>) <span class="hljs-comment">// eat shit</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog2.<span class="hljs-property">eat</span>) <span class="hljs-comment">// eat shit</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog1.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 王一琳</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog2.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 刘贝利</span><br><br></code></pre></td></tr></table></figure><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220414162016.png" alt=""></p><p><strong>缺点：</strong>可以清楚的看到，其实我们的代码里调用了两次<code>Animal()</code>，所以其<code>实例</code>中会存在<code>原型对象</code>中的所有属性，造成冗余。</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">obj</span>)&#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj)<br><br></code></pre></td></tr></table></figure><p>利用一个<code>空构造函数</code>作为媒介，完成对一个对象的浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dog = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;王一琳&#x27;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;王二琳&#x27;</span>, <span class="hljs-string">&#x27;王三琳&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> newDog1 = <span class="hljs-title function_">clone</span>(dog)<br>newDog1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;鸡公&#x27;</span><br>newDog1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;王四琳&#x27;</span>)<br><br><span class="hljs-keyword">const</span> newDog2 = <span class="hljs-title function_">clone</span>(dog)<br>newDog2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;鸡夫&#x27;</span><br>newDog1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;王五琳&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog1.<span class="hljs-property">name</span>) <span class="hljs-comment">// 鸡公</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog2.<span class="hljs-property">name</span>) <span class="hljs-comment">// 鸡夫</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog1.<span class="hljs-property">friends</span>) <span class="hljs-comment">// [ &#x27;王二琳&#x27;, &#x27;王三琳&#x27;, &#x27;王四琳&#x27;, &#x27;王五琳&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog2.<span class="hljs-property">friends</span>) <span class="hljs-comment">// [ &#x27;王二琳&#x27;, &#x27;王三琳&#x27;, &#x27;王四琳&#x27;, &#x27;王五琳&#x27; ]</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><p>核心：在原型式继承的基础上，增强对象（新增属性方法），返回返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createNew</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">const</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj)<br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone<br>&#125;<br><br><span class="hljs-keyword">const</span> dog = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;王一琳&#x27;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;王二琳&#x27;</span>, <span class="hljs-string">&#x27;王三琳&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> newDog = <span class="hljs-title function_">createNew</span>(dog)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog.<span class="hljs-property">name</span>) <span class="hljs-comment">//王一琳</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDog.<span class="hljs-property">friends</span>) <span class="hljs-comment">// [ &#x27;王二琳&#x27;, &#x27;王三琳&#x27; ]</span><br>newDog.<span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// 你好</span><br></code></pre></td></tr></table></figure><p><strong>缺点（同原型式继承）:</strong></p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h2 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h2><p>结合借用构造函数传递参数和寄生模式实现继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">Son, Father</span>) &#123;<br>    <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>    prototype.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Son</span><br>    <span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, eat</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eat</span> = eat<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">Dog</span>, <span class="hljs-title class_">Animal</span>)<br><br><span class="hljs-keyword">const</span> dog1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;鸡公&#x27;</span>, <span class="hljs-string">&#x27;eat shit&#x27;</span>)<br><span class="hljs-keyword">const</span> dog2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&#x27;王一琳&#x27;</span>, <span class="hljs-string">&#x27;eat more shit&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220414171142.png" alt=""></p><p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><p>与<code>组合</code>继承相比，<code>寄生组合继承</code>只调用了一次父类<code>Animal</code>,因此避免了在<code>Animal.protoype</code>上创建多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf()</p><h2 id="7-class继承"><a href="#7-class继承" class="headerlink" title="7.class继承"></a>7.class继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125; <br>    <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇的学习建立在对原型链的理解之上，如果对原型链还不够了解，可以先自行学习相关知识&lt;/p&gt;
&lt;h2 id=&quot;1-原型链继承&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>对cookie、session、JWT的一些理解</title>
    <link href="http://yoursite.com/2022/04/13/%E5%AF%B9cookie%E3%80%81session%E3%80%81JWT%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/04/13/对cookie、session、JWT的一些理解/</id>
    <published>2022-04-13T13:59:24.000Z</published>
    <updated>2022-04-18T13:54:58.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>HTTP 协议是一种<code>无状态协议</code>，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p><h2 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>客户端请求服务端，服务端会为这次请求开辟一块<code>内存空间</code>，这个对象便是 Session 对象，存储结构为<code>ConcurrentHashMap</code>。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p><h3 id="如何判断是否为同一会话"><a href="#如何判断是否为同一会话" class="headerlink" title="如何判断是否为同一会话"></a>如何判断是否为同一会话</h3><p>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 <strong>Set-Cookie：JSESSIONID=XXXXXXX</strong>命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID=XXXXXXX</strong>的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220413183818.png" alt=""></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><h2 id="三、Cookie"><a href="#三、Cookie" class="headerlink" title="三、Cookie"></a>三、Cookie</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p><blockquote><p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p></blockquote><p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。</p><h3 id="如何创建？"><a href="#如何创建？" class="headerlink" title="如何创建？"></a>如何创建？</h3><p>当接收到客户端发出的 HTTP 请求时，服务器在响应头加入<code>Set-Cookie</code>字段返回，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220413185349.png" alt=""></p><p>此后，浏览器对服务器发起的每个http请求，浏览器都将<code>Cookie</code>字段加在请求头中，将以前存储的所有Cookie发送回服务器</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220413185434.png" alt=""></p><p><code>Cookies</code>包含两种类型，一种是 <code>Session Cookies</code>，一种是 <code>Persistent Cookies</code>，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含有效期 ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p><h4 id="会话-Cookies"><a href="#会话-Cookies" class="headerlink" title="会话 Cookies"></a>会话 Cookies</h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定<code>Expires</code>或<code>Max-Age</code>指令。<br>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样。</p><h4 id="永久性-Cookies"><a href="#永久性-Cookies" class="headerlink" title="永久性 Cookies"></a>永久性 Cookies</h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在特定日期（Expires）或特定时间长度（Max-Age）外过期。例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT;<br></code></pre></td></tr></table></figure><h4 id="Cookie-的-Secure-和-HttpOnly-标记"><a href="#Cookie-的-Secure-和-HttpOnly-标记" class="headerlink" title="Cookie 的 Secure 和 HttpOnly 标记"></a>Cookie 的 Secure 和 HttpOnly 标记</h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p><p><strong>HttpOnly 的作用</strong></p><ul><li>会话 Cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 Cookie  信息，造成用户 Cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</li></ul><ul><li>HttpOnly 是微软对 Cookie 做的扩展，该值指定 Cookie 是否可通过客户端脚本访问。</li></ul><ul><li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li></ul><h4 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a>Cookie 的作用域</h4><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。<br><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(不包含子域名）。如果指定了<code>Domain</code>，则一般包含子域名。<br>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。<br>例如，设置<code>Path=/docs</code>，则以下地址都会匹配：</p><ul><li><code>/docs</code></li><li><code>/docs/Web/</code></li><li><code>/docs/Web/HTTP</code></li></ul><h2 id="四、JWT"><a href="#四、JWT" class="headerlink" title="四、JWT"></a>四、JWT</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><p><code>JSON Web Token</code> ，简称<code>JWT</code>，它和 Session都可以为网站提供用户的身份认证，但是它们不是一回事。它是<code>RFC 7519</code>中定义的用于<code>安全的</code>将信息作为<code>Json对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p><p><strong>主要作用：</strong></p><ul><li><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小。</li><li><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code> 计算的，因此你还可以验证内容是否遭到篡改。</li></ul><h3 id="JWT格式"><a href="#JWT格式" class="headerlink" title="JWT格式"></a>JWT格式</h3><p>JWT 主要由三部分组成，每个部分用 . 进行分割，各个部分分别是</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>因此，一个非常简单的 JWT 组成会是下面这样</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/20220413215128.png" alt=""></p><h3 id="JWT和Session-Cookies的相同之处"><a href="#JWT和Session-Cookies的相同之处" class="headerlink" title="JWT和Session Cookies的相同之处"></a>JWT和Session Cookies的相同之处</h3><p>它们既可以对用户进行身份验证，也可以用来在用户单击进入不同页面时以及登陆网站或应用程序后进行身份验证。</p><p>如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的<code>内存中</code>将不会记住你之前的操作。</p><h3 id="JWT和Session-Cookies的不同之处"><a href="#JWT和Session-Cookies的不同之处" class="headerlink" title="JWT和Session Cookies的不同之处"></a>JWT和Session Cookies的不同之处</h3><p>JWT 和 Session Cookies 都提供安全的用户身份验证，但是它们有以下几点不同</p><h4 id="密码签名"><a href="#密码签名" class="headerlink" title="密码签名"></a>密码签名</h4><p>JWT 具有加密签名，而 Session Cookies 则没有。</p><h4 id="JSON-是无状态的"><a href="#JSON-是无状态的" class="headerlink" title="JSON 是无状态的"></a>JSON 是无状态的</h4><p>JWT 是<code>无状态</code>的，因为声明被存储在<code>客户端</code>，而不是服务端内存中。<br>身份验证可以在<code>本地</code>进行，而不是在请求必须通过服务器数据库或类似位置中进行。 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。</p><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的<code>可扩展性</code>。</p><h4 id="JWT-支持跨域认证"><a href="#JWT-支持跨域认证" class="headerlink" title="JWT 支持跨域认证"></a>JWT 支持跨域认证</h4><p>Session Cookies 只能用在<code>单个节点的域</code>或者它的<code>子域</code>中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。<br>使用 JWT 可以解决这个问题，使用 JWT 能够通过<code>多个节点</code>进行用户认证，也就是我们常说的<code>跨域认证</code>。</p><h4 id="JWT-和-Session-Cookies-的选型"><a href="#JWT-和-Session-Cookies-的选型" class="headerlink" title="JWT 和 Session Cookies 的选型"></a>JWT 和 Session Cookies 的选型</h4><p>我们上面探讨了 JWT 和 Cookies 的不同点，相信你也会对选型有了更深的认识，大致来说</p><p>对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies 通常就能满足。</p><p>如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则 JWT 显然更适合。</p><p><strong>参考文献</strong>：</p><p><a href="https://juejin.cn/post/6844904115080790023#heading-17">看完这篇 Session、Cookie、Token，和面试官扯皮就没问题了</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;HTTP 协议是一种&lt;code&gt;无状态协议&lt;/code&gt;，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="Cookie" scheme="http://yoursite.com/tags/Cookie/"/>
    
      <category term="Session" scheme="http://yoursite.com/tags/Session/"/>
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>this.setState到底是异步还是同步？</title>
    <link href="http://yoursite.com/2022/04/09/setState%E5%88%B0%E5%BA%95%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2022/04/09/setState到底是异步还是同步/</id>
    <published>2022-04-09T07:55:04.000Z</published>
    <updated>2022-04-18T13:56:19.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先说结论，<code>this.state</code>是<strong>同步</strong>的，它是一个<strong>伪装的异步</strong>，不属于<code>宏任务</code>和<code>微任务</code>，并且会在微任务执行前执行。</p><p>好的，我们先忘记结论，看个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.state.val 初始为0</span><br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 2</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 3</span><br>    &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个令人疑惑的点，为什么前面两次调用<code>setState</code>后打印出的结果还是初始值，而且明明调用了<strong>4</strong>次，最后结果是<strong>3</strong>呢？</p><p>接下来我们来看看<code>setState</code>的特性</p><h2 id="同步更新or异步更新"><a href="#同步更新or异步更新" class="headerlink" title="同步更新or异步更新"></a>同步更新or异步更新</h2><blockquote><p>前面我们说了，setState的异步是伪装的，但为了方便起见，我们以下内容中直接称其为异步</p></blockquote><p><strong>state默认是异步更新的</strong>，所以下面代码中，会打印出两个0，同步代码无法立即获取到新更新的值。</p><p>解决这个问题的方法也很简单，因为<code>setState</code>有第二个参数，是一个回调函数，我们可以在回调函数中打印更新后的state的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span> &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) &#125; <span class="hljs-comment">// 1</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>那么什么情况会同步执行呢?</p><p><strong>当setState不在React上下文中触发时，会同步更新</strong></p><ul><li>setTimeout, setInterval, promise.then</li><li>自定义的DOM事件</li><li>Ajax回调<blockquote><p>注：在最新的React 18中，上述场景能够异步更新,但需将ReactDOM.render替换为ReactDOM.createRoot</p></blockquote></li></ul><p>所以下面的例子可以成功打印出更新后的结果<strong>1</strong>和<strong>2</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.state.val 初始为0</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 1</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 2</span><br>    &#125;, <span class="hljs-number">0</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再看一个自定义事件的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.state.val 初始为0</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;item&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span> &#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 1</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="合并or不合并"><a href="#合并or不合并" class="headerlink" title="合并or不合并"></a>合并or不合并</h2><p><strong>state默认是合并</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>( &#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span> &#125; )<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        &#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">2</span> &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) &#125; <span class="hljs-comment">// 2</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>以上结果不应该是<strong>3</strong>吗，为什么会是<strong>2</strong>？因为默认会对<code>setState</code>进行合并，避免重复渲染，并以最新一次为准，所以不是<strong>3</strong>，也不会是<strong>1</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.state.val 初始为0</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 1</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 2</span><br>    &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那上面这个例子为什么没合并呢，答案很容易猜到，都已经同步执行了，在执行下一个<code>setState</code>之前，已经更新了，当然没办法合并啦。</p><p>以下情况也不会合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        <span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">val</span>: prevState.<span class="hljs-property">val</span> + <span class="hljs-number">1</span> &#125;,<br>        &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) &#125; <span class="hljs-comment">// 1</span><br>    )<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<br>        <span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">val</span>: prevState.<span class="hljs-property">val</span> + <span class="hljs-number">1</span> &#125;,<br>        &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) &#125; <span class="hljs-comment">// 2</span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>因为函数不执行，我们无法确定结果，不能像对象那样使用<code>Object.assign</code>来合并。</p><p>再回到最初那个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.state.val 初始为0</span><br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 2</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">val</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>) <span class="hljs-comment">// 3</span><br>    &#125;, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这个问题对我们来说已经非常简单了，至于为什么，也就不多说了。</p><h2 id="为什么是伪异步？"><a href="#为什么是伪异步？" class="headerlink" title="为什么是伪异步？"></a>为什么是伪异步？</h2><p>我们再来看一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise))</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    this.setState(</span><br><span class="hljs-string">        &#123; val: this.state.val + 1 &#125;,</span><br><span class="hljs-string">        () =&gt; &#123; console.log(&#x27;</span>setState<span class="hljs-string">&#x27;) &#125;</span><br><span class="hljs-string">    )</span><br><span class="hljs-string"></span><br><span class="hljs-string">    console.log(&#x27;</span>end<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>上述打印结果为<code>start</code>、<code>end</code>、<code>setState</code>、<code>promise</code></p><p>前两个结果大家肯定没有异议，因为promise.then是<code>微任务</code>，但是promise.then不是在setState前面吗，为什么反而是<code>setState</code>先打印呢？</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>setState本质上是同步，只不过让React做成了异步的样子,它既不是微任务也不是宏任务，在微任务开始之前，state就已经计算完了</li><li>因为要考虑性能问题，多次state修改，只进行一次DOM渲染</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先说结论，&lt;code&gt;this.state&lt;/code&gt;是&lt;strong&gt;同步&lt;/strong&gt;的，它是一个&lt;strong&gt;伪装的异步&lt;/s
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>arr.map(parseInt)的问题</title>
    <link href="http://yoursite.com/2022/04/08/map(parseInt)%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/04/08/map(parseInt)的问题/</id>
    <published>2022-04-08T13:41:04.000Z</published>
    <updated>2022-04-18T13:56:10.299Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题还挺坑的，我在写算法时，还真这么写过，当时不知道有问题，可能有些题AC不了就是这个导致的</p><p>首先我们来看看<code>parseInt</code>这个方法</p><ul><li>string(参数1)：必需。要被解析的字符串。</li><li>raidx(参数2)：可选，默认为10。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</li></ul><p>从定义中我们可以看出，<code>parseInt</code>会将<code>string</code>按照<code>raidx进制</code>解析，我们来看几个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN 因为超出了2-36的范围</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;asd&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN 因为不是数字</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN 因为2进制没有3</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>需要注意的是，如果<code>radix</code>不在2-36范围内，输出结果为<code>NaN</code>，但也有特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 当radix为0时，按10进制处理</span><br></code></pre></td></tr></table></figure><p>了解了以上内容，我们有请今天的主角</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>)<br></code></pre></td></tr></table></figure><p>我们知道，当map自定义回调函数时，写法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>所以前面的代码等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(value, index)<br>&#125;)<br></code></pre></td></tr></table></figure><p>返回的结果为<code>[1, NaN, NaN]</code></p><p>至于原因，显而易见，知道你平时这样用为什么这么多<code>NaN</code>了吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个问题还挺坑的，我在写算法时，还真这么写过，当时不知道有问题，可能有些题AC不了就是这个导致的&lt;/p&gt;
&lt;p&gt;首先我们来看看&lt;code&gt;parseInt&lt;/code&gt;这个方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string(参数1)：必需。要被解析的字符串。&lt;/li&gt;
&lt;li&gt;r
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks理解</title>
    <link href="http://yoursite.com/2022/04/08/React%20Hooks%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/04/08/React Hooks理解/</id>
    <published>2022-04-08T07:17:04.000Z</published>
    <updated>2022-04-18T13:56:14.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>React Hooks</code>是React16.8的强大特性，本文主要记录个人学习过程中的一些理解，由于<a href="https://react.docschina.org/docs/hooks-intro.html">React官方文档</a>对其基本概念的描述已经十分直观,本文也不会啰嗦的再<del>复制</del>描述一遍它的概念。因此，本文可能不适用于未学习过Hooks的人群。本文的理解基于官方给的例子，后续可能会增添一些新的补充</p><h2 id="React-Hooks做了什么事？"><a href="#React-Hooks做了什么事？" class="headerlink" title="React Hooks做了什么事？"></a>React Hooks做了什么事？</h2><h3 id="告别class"><a href="#告别class" class="headerlink" title="告别class"></a>告别class</h3><p>Hook 在 class 内部是不起作用的。但你可以使用它们来取代 class。</p><p>因为我本身就在<code>React Hooks</code>发布之前使用过React，能明显感觉到其带来的好处。</p><p>首先我们都知道，在<code>Hooks</code>诞生之前，函数组件被称为<code>无状态组件</code>，我们无法在函数组件中定义组件的状态，并使用<code>this.setState</code>这样的方法。</p><p>而class也是学习React的一大障碍，即使我们能够很好的理解Javascript中<code>this</code>的定义，但复杂的场景有时也会为我们理解<code>this</code>的指向带来困扰。而且我们还不能忘记绑定事件处理器。</p><p><code>Hooks</code>解决了这一问题，消除了<code>this</code>，让我们的代码更好理解，让函数组件能够使用更多的React特性，也不需要再区分class组件与函数组件的使用场景了。</p><blockquote><p>值得注意的是，React并没有弃用class的打算，Hook 和现有代码可以同时工作，我们可以渐进式地使用他们。React团队也将继续为class组件提供支持。</p></blockquote><h3 id="消除生命周期中的冗余和分离无关逻辑"><a href="#消除生命周期中的冗余和分离无关逻辑" class="headerlink" title="消除生命周期中的冗余和分离无关逻辑"></a>消除生命周期中的冗余和分离无关逻辑</h3><p>首先我们来了解一下<code>副作用</code>，引用官方原话：数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。不管你知不知道这些操作，或是“副作用”这个名字，应该都在组件中使用过它们。</p><p><code>副作用</code>这个概念其实并不是来自React，讲到副作用，我们不得不提另一个概念：<code>纯函数</code>。简单来说，纯函数就是，通过确定的输入，产生确定的输出，像我们中学时期数学中用的函数，就是纯函数。<strong>数据获取，设置订阅以及手动更改 React 组件中的 DOM</strong>，这些副作用可能会产生不同的结果，改变上下文环境，有了这些，函数就不是纯函数了。</p><p>曾经，我们经常在生命周期函数中使用副作用，比如在<code>componentDidMount</code>中发起请求获取数据</p><p>以下例子为组件每次渲染后更新页面title：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="language-xml">          Click me</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们需要在两个生命周期函数中编写重复的代码，因为有些场景下，我们希望组件每次渲染后都执行某个操作，但React并没有提供这样的生命周期函数。</p><p>我们可以使用<code>useEffect</code>处理这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="language-xml">        Click me</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以把useEffect Hook看做componentDidMount，componentDidUpdate和componentWillUnmount这三个函数的组合。</p><p>对，你发现问题了，上述例子中我们<code>useEffect</code>的内容，只是在渲染后执行的,那么怎么实现<code>componentWillUnmount</code>呢？</p><p>有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露。</p><p>看以下例子,假设我们有一个ChatAPI模块，它允许我们订阅好友的在线状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">isOnline</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span><br>    );<br>  &#125;<br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span><br>    );<br>  &#125;<br>  <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">isOnline</span>: status.<span class="hljs-property">isOnline</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isOnline</span> === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isOnline</span> ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会注意到 componentDidMount 和 componentWillUnmount 之间相互对应。使用生命周期函数迫使我们拆分这些逻辑代码，即使这两部分代码都作用于相同的副作用。</p><p>我们使用<code>useEffect</code>来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>      <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>    &#125;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-comment">// Specify how to clean up after this effect:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>useEffect</code>能够返回一个清除函数，这是可选的机制。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><blockquote><p>与componentWillUnmount不同的是，useEffect返回的清楚函数在每次重新渲染时都会执行</p></blockquote><p>以前在class中使用生命周期函数时还会遇到一个问题，以以上的例子举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendStatusWithCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">isOnline</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleStatusChange</span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">isOnline</span>: status.<span class="hljs-property">isOnline</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>看，当我们如果又需要设置页面的title，也需要订阅好友的在线状态时，我们只能像以上那样写，这样除了将相关逻辑分割到不同的生命周期函数以外，<code>componentDidMount</code>中同时包含了两个不同功能的代码。</p><p>那么Hook如何解决这个问题呢？就像你可以使用多个state的Hook一样，你也可以使用多个effect。这会将不相关逻辑分离到不同的 effect中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatusWithCounter</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>      <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>    &#125;<br><br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>, handleStatusChange);<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Hook允许我们按照代码的用途分离他们，而不是像生命周期函数那样。React将按照effect声明的顺序依次调用组件中的每一个effect。</p><h3 id="复用状态逻辑"><a href="#复用状态逻辑" class="headerlink" title="复用状态逻辑"></a>复用状态逻辑</h3><p>如下所示，我们封装了一个好友在线状态的Hook,它将 friendID 作为参数，并返回该好友是否在线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useFriendStatus</span>(<span class="hljs-params">friendID</span>) &#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleStatusChange</span>(<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-title function_">setIsOnline</span>(status.<span class="hljs-property">isOnline</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">subscribeToFriendStatus</span>(friendID, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title class_">ChatAPI</span>.<span class="hljs-title function_">unsubscribeFromFriendStatus</span>(friendID, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> isOnline;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在两个组件中使用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendStatus</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> isOnline = <span class="hljs-title function_">useFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendListItem</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> isOnline = <span class="hljs-title function_">useFriendStatus</span>(props.<span class="hljs-property">friend</span>.<span class="hljs-property">id</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">isOnline</span> ? &#x27;<span class="hljs-attr">green</span>&#x27; <span class="hljs-attr">:</span> &#x27;<span class="hljs-attr">black</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="language-xml">      &#123;props.friend.name&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>首先要注意的是，这两个两个组件的<code>state</code>是完全独立的，<code>Hook</code><strong>只复用state的逻辑，不复用state本身</strong></p><p>也是这个例子，让我更好的理解了<code>Hook</code>名字的由来，正如它的中文翻译<code>钩子</code>,它能够将一些公用的逻辑抽离出组件（或者说一些特性，比如<code>useState</code>），与组件本身解耦，在需要使用它的组件里钩入它。</p><h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><p>以下摘自官方文档原话</p><h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3><p>不要在循环，条件或嵌套函数中调用<code>Hook，</code>，确保总是在你的React函数的最顶层调用他们。遵守这条规则，你就能确保<code>Hook</code>在每一次渲染中都按照同样的顺序被调用。这让React能够在多次的<code>useState</code>和<code>useEffect</code>调用之间保持<code>Hook</code>状态的正确。</p><p>至于为什么要这样做，React文档中也给了相关的原因:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 1. Use the name state variable</span><br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Mary&#x27;</span>);<br><br>  <span class="hljs-comment">// 2. Use an effect for persisting the form</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">persistForm</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, name);<br>  &#125;);<br><br>  <span class="hljs-comment">// 3. Use the surname state variable</span><br>  <span class="hljs-keyword">const</span> [surname, setSurname] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Poppins&#x27;</span>);<br><br>  <span class="hljs-comment">// 4. Use an effect for updating the title</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTitle</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = name + <span class="hljs-string">&#x27; &#x27;</span> + surname;<br>  &#125;);<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ------------</span><br><span class="hljs-comment">// 首次渲染</span><br><span class="hljs-comment">// ------------</span><br><span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Mary&#x27;</span>)           <span class="hljs-comment">// 1. 使用 &#x27;Mary&#x27; 初始化变量名为 name 的 state</span><br><span class="hljs-title function_">useEffect</span>(persistForm)     <span class="hljs-comment">// 2. 添加 effect 以保存 form 操作</span><br><span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Poppins&#x27;</span>)        <span class="hljs-comment">// 3. 使用 &#x27;Poppins&#x27; 初始化变量名为 surname 的 state</span><br><span class="hljs-title function_">useEffect</span>(updateTitle)     <span class="hljs-comment">// 4. 添加 effect 以更新标题</span><br><br><span class="hljs-comment">// -------------</span><br><span class="hljs-comment">// 二次渲染</span><br><span class="hljs-comment">// -------------</span><br><span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Mary&#x27;</span>)           <span class="hljs-comment">// 1. 读取变量名为 name 的 state（参数被忽略）</span><br><span class="hljs-title function_">useEffect</span>(persistForm)     <span class="hljs-comment">// 2. 替换保存 form 的 effect</span><br><span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;Poppins&#x27;</span>)        <span class="hljs-comment">// 3. 读取变量名为 surname 的 state（参数被忽略）</span><br><span class="hljs-title function_">useEffect</span>(updateTitle)     <span class="hljs-comment">// 4. 替换更新标题的 effect</span><br><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><br>比如我们在组件中定义了四个<code>Hook</code>，如果在顶层调用的话，效果如上所示。</p><p>我们注意到，二次渲染的时候，<code>useState</code>读取的是改变后的状态（如果未改变，就是之前的状态），这是怎么实现的呢？</p><p><strong>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联。</strong></p><p>如果我们将一个<code>Hook</code>的调用放到一个条件语句中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在条件语句中使用 Hook 违反第一条规则</span><br><span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">persistForm</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, name);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useState</span><span class="hljs-params">(<span class="hljs-string">&#x27;Mary&#x27;</span>)</span></span>           <span class="hljs-comment">// 1. 读取变量名为 name 的 state（参数被忽略）</span><br><span class="hljs-comment">// useEffect(persistForm)  // 此 Hook 被忽略！</span><br><span class="hljs-function"><span class="hljs-title">useState</span><span class="hljs-params">(<span class="hljs-string">&#x27;Poppins&#x27;</span>)</span></span>        <span class="hljs-comment">// 2 （之前为 3）。读取变量名为 surname 的 state 失败, 它和上一次的useEffect(persistForm) 对应了</span><br><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(updateTitle)</span></span>     <span class="hljs-comment">// 3 （之前为 4）。替换更新标题的 effect 失败</span><br></code></pre></td></tr></table></figure><p><strong>这就是为什么Hook需要在我们组件的最顶层调用。如果我们想要有条件地执行一个effect，可以将判断放到Hook的内部：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">persistForm</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 👍 将条件判断放置在 effect 中</span><br>  <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, name);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h3><p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p><ul><li>在React的函数组件中调用<code>Hook</code></li><li>在<code>自定义Hook</code>中调用其他<code>Hook</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;React Hooks&lt;/code&gt;是React16.8的强大特性，本文主要记录个人学习过程中的一些理解，由于&lt;a href=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Hooks" scheme="http://yoursite.com/tags/React-Hooks/"/>
    
  </entry>
  
  <entry>
    <title>什么是事件委托（代理）？</title>
    <link href="http://yoursite.com/2022/04/04/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BB%A3%E7%90%86%EF%BC%89%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/04/04/什么是事件委托（代理）？/</id>
    <published>2022-04-04T11:35:24.000Z</published>
    <updated>2022-06-06T03:22:14.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="事件冒泡-amp-amp-事件捕获"><a href="#事件冒泡-amp-amp-事件捕获" class="headerlink" title="事件冒泡 &amp;&amp; 事件捕获"></a>事件冒泡 &amp;&amp; 事件捕获</h3><p>当我们触发一个元素事件时，如果事件从最内层元素传递到最外层元素，此过程为<code>事件冒泡</code>，如果从最外层元素传递到最内层元素，此过程为<code>事件捕获</code></p><p>如以下代码所示：</p><ul><li>若触发<code>事件冒泡</code>，则事件执行顺序为<code>c</code>、<code>b</code>、<code>a</code></li><li>若触发<code>事件捕获</code>，则事件执行顺序为<code>a</code>、<code>b</code>、<code>c</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Javascript中<code>addEventListener</code>为元素绑定事件的方法，它接收三个参数</p><ol><li><strong>event</strong>：绑定的事件名</li><li><strong>function</strong>：执行的回调函数</li><li><strong>useCapture</strong><ul><li>false: 默认，代表冒泡时绑定</li><li>true: 代表捕获时绑定</li></ul></li></ol><h2 id="e-target和e-currentTarget"><a href="#e-target和e-currentTarget" class="headerlink" title="e.target和e.currentTarget"></a>e.target和e.currentTarget</h2><p>在以上的例子中新增js代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> a =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.a&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> b =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.b&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> c =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.c&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    a.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    b.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    c.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target: <span class="hljs-subst">$&#123;e.target.className&#125;</span>, currentTarget：<span class="hljs-subst">$&#123;e.currentTarget.className&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击c元素，控制台打印结果为：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：<span class="hljs-keyword">c</span><br><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：b<br><span class="hljs-symbol">target:</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> currentTarget：a<br></code></pre></td></tr></table></figure><p>由此我们可以得出结论<code>e.target</code>为我们点击的元素（可以理解为c在a、b的上层，所以我们点击的是c），e.currentTarget为绑定事件的元素（这里是冒泡，所以从c-&gt;a）</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="　事件委托"></a>　事件委托</h2><p>考虑一个需求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上所示，<code>ul</code>中有4个<code>li</code>，如果我们想在点击<code>li</code>后输出对应<code>li</code>的内容怎么办？</p><p>没错，我们可以给每个<code>li</code>都绑定一个事件，但你有没有想过，这里只有4个<code>li</code>，实际应用场景可能不止这么多，那难道我们给每个<code>li</code>都绑定事件吗？</p><p>利用我们之前所学的知识，我们可以进行如下操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.ul&#x27;</span>)</span><br><span class="language-javascript">  ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">innerHTML</span>)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就是<strong>事件委托</strong>啦，就是把子元素的事件，其原理就是利用<code>事件冒泡</code>和<code>e.target</code>，把处理子元素的操作，委托在父元素的事件中处理。，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;事件冒泡-amp-amp-事件捕获&quot;&gt;&lt;a href=&quot;#事件冒泡-amp-amp-事件捕获&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript常见手写题</title>
    <link href="http://yoursite.com/2022/03/20/Javascript%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98/"/>
    <id>http://yoursite.com/2022/03/20/Javascript常见手写题/</id>
    <published>2022-03-20T11:17:24.000Z</published>
    <updated>2022-06-06T03:22:14.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, timeout</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, timeout)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-keyword">return</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, timeout)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数柯里化（Currying）"><a href="#函数柯里化（Currying）" class="headerlink" title="函数柯里化（Currying）"></a>函数柯里化（Currying）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">const</span> args = [];<br><br>    <span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        args.<span class="hljs-title function_">push</span>(...<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br><br>    add.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args)<br>    &#125;<br>    <span class="hljs-keyword">return</span> add;<br>&#125;<br><br><span class="hljs-keyword">const</span> add = <span class="hljs-title function_">curry</span>(dynamicAdd);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">typeOf</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(x).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">toLowerCase</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-string">&#x27;1&#x27;</span>)) <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;1&#x27;</span>))) <span class="hljs-comment">// symbol</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1</span>))) <span class="hljs-comment">// bigint</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>([]))) <span class="hljs-comment">// array</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())) <span class="hljs-comment">// date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeOf</span>(&#123;&#125;)) <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>ES5实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index<br>  &#125;)<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ES6实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">unique</span> = arr =&gt; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)])<br></code></pre></td></tr></table></figure></p><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>ES5实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> res = []<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i])) &#123;<br>      res = res.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flatten</span>(arr[i]))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i])<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ES6实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;<br>    arr = [].<span class="hljs-title function_">concat</span>(...arr)<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">all</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">const</span> result = []<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">index, value</span>) =&gt; &#123;<br>          result[index] = value<br>          count++<br>          <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) <span class="hljs-title function_">resolve</span>(result)<br>      &#125;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(index, res)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title function_">reject</span>(err))<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">addData</span>(index, promise)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">race</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">resolve</span>(res)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">reject</span>(err)<br>              &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">resolve</span>(promise)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">allSettled</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> res = []<br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>          res[i] = &#123;<br>              status,<br>              value<br>          &#125;<br>          count++<br>          <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) &#123;<br>              <span class="hljs-title function_">resolve</span>(res)<br>          &#125;<br>      &#125;<br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, i</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>              promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i)<br>              &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                  <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i)<br>              &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, promise, i)<br>          &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">any</span> = promiseList =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>      promiseList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (promise <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>            promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>              <span class="hljs-title function_">resolve</span>(val)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                &#125;<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(promise)<br>        &#125;<br>      &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防抖（debounce）&quot;&gt;&lt;a href=&quot;#防抖（debounce）&quot; class=&quot;headerlink&quot; title=&quot;防抖（debounce）&quot;&gt;&lt;/a&gt;防抖（debounce）&lt;/h2&gt;&lt;figure class=&quot;highlight javascri
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器到底是怎么渲染页面的?</title>
    <link href="http://yoursite.com/2022/03/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/03/20/浏览器到底是怎么渲染页面的？/</id>
    <published>2022-03-20T02:21:23.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>当<strong>url</strong>输入到地址栏，到页面渲染完成，总共会有<strong>三个阶段</strong></p><ol><li>HTTP请求阶段</li><li>HTTP响应阶段</li><li>浏览器渲染阶段</li></ol><p>让我们来看看每个阶段到底发生了什么</p><h2 id="HTTP请求阶段"><a href="#HTTP请求阶段" class="headerlink" title="HTTP请求阶段"></a>HTTP请求阶段</h2><ol><li>在浏览器地址栏输入<strong>URL</strong>后，点击回车跳转</li><li>浏览器向服务器发起HTTP请求</li><li>DNS解析</li><li>TCP三次握手建立连接</li><li>建立连接后发起请求</li></ol><h2 id="HTTP响应阶段"><a href="#HTTP响应阶段" class="headerlink" title="HTTP响应阶段"></a>HTTP响应阶段</h2><ol><li>服务端准备资源</li><li>服务端将资源返回给浏览器</li><li>TCP四次挥手断开连接</li></ol><h2 id="浏览器渲染阶段"><a href="#浏览器渲染阶段" class="headerlink" title="浏览器渲染阶段"></a>浏览器渲染阶段</h2><ol><li>接受返回的资源</li><li>在内存中开辟出一块栈内存</li><li>解析代码（当遇到link、img、script等需要加载外部资源的文件后，开辟新的线程去加载资源文件）</li><li>解析DOM，形成DOM树，加载CSS，形成CSSOM树（DOM和CSSOM通常并行构建）</li><li>浏览器将DOM树和CSS树合并生成Render Tree（渲染树）</li><li>页面进行回流，完成基本的布局</li><li>页面进行重绘，进行样式的展示</li><li>GPU渲染整个页面</li></ol><blockquote><p>HTML与CSS的解析主要由GUI渲染线程负责，js由Javascript引擎线程负责，由于js可以操作dom元素和样式，所以如果GUI线程和Javascript引擎线程一起并行会造成冲突。因此GUI渲染线程与Javascript引擎线程是<strong>互斥</strong>的。</p><p>若解析dom时遇到script需要执行js，则会阻塞js的执行，直到css样式表加载完成</p><p>若解析dom时css已加载完毕，遇到script需要执行js，则会停止解析dom，先执行js。因此，我们最好把script放在body的最后面。</p></blockquote><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220320111120678.png" alt="image-20220320111120678"></p><h2 id="DOMContentLoaded-与-load-的区别"><a href="#DOMContentLoaded-与-load-的区别" class="headerlink" title="DOMContentLoaded 与 load 的区别?"></a>DOMContentLoaded 与 load 的区别?</h2><ul><li>当<code>DOMContentLoaded</code>事件触发时,仅当 <code>DOM 解析</code>完成后,不包括样式表,图片。我们前面提到<code>CSS 加载</code>会阻塞 <code>Dom 的渲染</code>和后面 <code>js 的执行</code>,<code>js</code>会阻塞 <code>Dom 解析</code>,所以我们可以得到结论:当文档中没有脚本时,浏览器解析完文档便能触发 <code>DOMContentLoaded</code> 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等<code>CSSOM 构建完成</code>才能执行。在任何情况下,<code>DOMContentLoaded</code> 的触发不需要等待图片等其他资源加载完成。</li><li>当 <code>onload</code> 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。</li><li><code>DOMContentLoaded</code> -&gt; <code>load</code>。</li></ul><h2 id="link标签为什么放在head标签里？"><a href="#link标签为什么放在head标签里？" class="headerlink" title="link标签为什么放在head标签里？"></a>link标签为什么放在head标签里？</h2><p>我们平时编写代码时，一般都把加载css的<code>&lt;link&gt;</code>标签都放在<code>&lt;head&gt;</code>标签中，而不是像加载js文件的<code>script</code>标签那样放在<code>body</code>中最后，这是为什么呢？</p><ol><li><strong>放在body中</strong>：DOM Tree构建完成之后便开始构建Render Tree, 并计算布局渲染网页, 等加载解析完css之后, 开始构建CSSOM Tree, 并和DOM Tree重新构建Render Tree, 重新计算布局渲染网页。</li><li><strong>放在head中</strong>：先加载css, 之后解析css构建CSSOM Tree, 于此同时构建DOMTree, CSSOM Tree和DOM Tree都构建完毕之后开始构建Render Tree, 计算布局渲染网页。</li></ol><p>对比两者, css放在<code>&lt;head&gt;</code>标签中比css放在body标签尾部少了一次构建Render Tree, 一次计算布局和一次渲染网页, 因此性能会更好; 并且css放在body标签尾部时会在网页中短暂出现”裸奔”的HTML, 这不利于用户体验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三个阶段&quot;&gt;&lt;a href=&quot;#三个阶段&quot; class=&quot;headerlink&quot; title=&quot;三个阶段&quot;&gt;&lt;/a&gt;三个阶段&lt;/h2&gt;&lt;p&gt;当&lt;strong&gt;url&lt;/strong&gt;输入到地址栏，到页面渲染完成，总共会有&lt;strong&gt;三个阶段&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Javascript伪数组与arguments</title>
    <link href="http://yoursite.com/2022/03/19/Javascript%E4%BC%AA%E6%95%B0%E7%BB%84%E4%B8%8Earguments/"/>
    <id>http://yoursite.com/2022/03/19/Javascript伪数组与arguments/</id>
    <published>2022-03-19T13:59:01.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是伪数组？"><a href="#什么是伪数组？" class="headerlink" title="什么是伪数组？"></a>什么是伪数组？</h2><p>所谓伪数组，也称为类数组对象，指的是<code>可以通过索引属性访问元素</code>并且<code>拥有 length 属性</code>的<code>对象</code>。</p><p>以下为一个简单的伪数组的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arrFake = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;job&#x27;</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它所对应的数组如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>];<br></code></pre></td></tr></table></figure><p>它们的<strong>相同点</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// name</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrFake[<span class="hljs-number">0</span>]) <span class="hljs-comment">// name</span><br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span><br>arrFake[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new name&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrFake.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>它们的<strong>不同点</strong>在于，伪数组不能调用数组原型链上的方法，且伪数组调用<code>Array.isArray</code>方法输出<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrFake.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>)  <span class="hljs-comment">// Uncaught TypeError: arrFake.push is not a function</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>); <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;]</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arrFake) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们可以用<strong>Array.from</strong>将伪数组转化为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrFake) <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;]</span><br>newArr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;hobby&#x27;</span>) <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;hobby&#x27;]</span><br></code></pre></td></tr></table></figure><blockquote><p>也可以使用<br>1.Array.prototype.slice等返回新数组的方法<br>2.扩展运算符[…arguments]</p></blockquote><p>js中的伪数组对象：</p><ul><li><code>document.getElementsByTagName</code>获取的元素标签集合</li><li>函数中的<code>arguments</code></li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>定义如下函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><br><span class="hljs-title function_">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意！箭头函数没有 arguments</p></blockquote><p>在控制台显示打印结果：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220319225005184.png" alt="image-20220319225005184"></p><p>显然，<code>arguments</code>就是一个伪数组，<code>callee</code>属性如上图所示，为函数本身，我们可以使用<code>arguments.callee()</code>的方式调用函数。</p><p>再思考一下以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">length</span>) <span class="hljs-comment">// 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) <span class="hljs-comment">// 4</span><br>&#125;<br><br><span class="hljs-title function_">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>其中<code>function</code>本身的<code>length</code>代表行参的长度，而<code>arguments</code>的<code>length</code>代表实参的长度。</p><blockquote><p>注意！function本身的length不包括有默认值的形参和剩余参数…args</p></blockquote><h2 id="arguments的应用"><a href="#arguments的应用" class="headerlink" title="arguments的应用"></a>arguments的应用</h2><p>实现函数的重载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">5</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">doAdd</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 6</span><br><span class="hljs-title function_">doAdd</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是伪数组？&quot;&gt;&lt;a href=&quot;#什么是伪数组？&quot; class=&quot;headerlink&quot; title=&quot;什么是伪数组？&quot;&gt;&lt;/a&gt;什么是伪数组？&lt;/h2&gt;&lt;p&gt;所谓伪数组，也称为类数组对象，指的是&lt;code&gt;可以通过索引属性访问元素&lt;/code&gt;并且&lt;code
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>V8引擎的垃圾回收机制</title>
    <link href="http://yoursite.com/2022/03/10/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2022/03/10/V8引擎的垃圾回收机制/</id>
    <published>2022-03-10T13:17:51.000Z</published>
    <updated>2022-06-06T03:22:14.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Javascript内存管理"><a href="#一、Javascript内存管理" class="headerlink" title="一、Javascript内存管理"></a>一、Javascript内存管理</h2><p>JavaScript内存的流程很简单，分为3步：</p><ol><li>分配给<strong>使用者</strong>所需的内存</li><li><strong>使用者</strong>拿到这些内存，并使用内存</li><li><strong>使用者</strong>不需要这些内存了，释放并归还给系统</li></ol><p>那么这些使用者是谁呢？举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;Zh&#x27;</span><br><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Zh&#x27;</span> &#125;<br>obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Zh&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><br>上面这些num，str，obj就是就是使用者，我们都知道，JavaScript数据类型分为基础数据类型和引用数据类型:</p><ul><li>基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问</li><li>引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问</li></ul><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310195900386.png" alt="image-20220310195900386"></p><ul><li>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的</li><li>由于堆内存所存大小不固定，系统无法自动释放回收，所以需要JS引擎来手动释放这些内存<h2 id="二、V8引擎的垃圾回收机制"><a href="#二、V8引擎的垃圾回收机制" class="headerlink" title="二、V8引擎的垃圾回收机制"></a>二、V8引擎的垃圾回收机制</h2><h3 id="为何需要垃圾回收"><a href="#为何需要垃圾回收" class="headerlink" title="为何需要垃圾回收"></a>为何需要垃圾回收</h3>在Chrome中，V8被限制了内存的使用（<strong>64位约1.4G/1464MB</strong> ，<strong> 32位约0.7G/732MB</strong>），为什么要限制呢？</li><li>表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景</li><li>深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）</li></ul><h2 id="三、V8引擎的垃圾回收算法"><a href="#三、V8引擎的垃圾回收算法" class="headerlink" title="三、V8引擎的垃圾回收算法"></a>三、V8引擎的垃圾回收算法</h2><h3 id="1-分代回收"><a href="#1-分代回收" class="headerlink" title="1.分代回收"></a>1.分代回收</h3><p>在JavaScript中，对象存活周期分为两种情况。</p><ul><li>存活周期很短：经过一次垃圾回收后，就被释放回收掉</li><li>存活周期很长：经过多次垃圾回收后，他还存在，赖着不走</li></ul><p>那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？</p><p>对于这个问题，V8做了<strong>分代回收</strong>的优化方法，通俗点说就是：<strong>V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方</strong></p><p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p><p><code>副垃圾回收器 + Scavenge算法</code>：主要负责新生代的垃圾回收<br><code>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法</code>：主要负责老生代的垃圾回收</p><h3 id="1-1-新生代"><a href="#1-1-新生代" class="headerlink" title="1.1 新生代"></a>1.1 新生代</h3><p>在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。<br><code>Scavange</code>算法将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310205820365.png" alt="image-20220310205820365"></p><p>具体步骤为以下4步：</p><ol><li>标记活动对象和非活动对象</li><li>复制<code>from-space</code>的活动对象到<code>to-space</code>中并进行排序</li><li>清除<code>from-space</code>中的非活动对象</li><li>将<code>from-space</code>和<code>to-space</code>进行角色互换，以便下一次的<code>Scavenge</code>算法垃圾回收</li></ol><p>那么，垃圾回收器是怎么知道哪些对象是活动对象，哪些是非活动对象呢？</p><p>这就要不得不提一个东西了——<code>可达性</code>。什么是可达性呢？就是从初始的<code>根对象（window或者global）</code>的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。</p><p>新生代中的对象什么时候变成老生代的对象？</p><p>在新生代中，还进一步进行了细分。分为<code>nursery子代</code>和<code>intermediate</code>子代两个区域，一个对象第一次分配内存时会被分配到新生代中的<code>nursery子代</code>，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到<code>intermediate子代</code>，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为<code>晋升</code></p><h3 id="1-2老生代"><a href="#1-2老生代" class="headerlink" title="1.2老生代"></a>1.2老生代</h3><p>新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用<code>Scavenge</code>算法，为啥呢，有以下原因：</p><ul><li>cavenge`算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低</li><li>cavenge<code>算法是以空间换时间的算法，老生代是内存很大的空间，如果使用</code>Scavenge`法，空间资源非常浪费，得不偿失啊。。</li></ul><p>所以老生代里使用了Mark-Sweep算法(标记清理)和Mark-Compact算法(标记整理)</p><h3 id="Mark-Sweep-标记清理"><a href="#Mark-Sweep-标记清理" class="headerlink" title="Mark-Sweep(标记清理)"></a>Mark-Sweep(标记清理)</h3><p><code>Mark-Sweep</code>两个阶段，标记和清理阶段，之前的<code>Scavenge算法</code>标记和清理，但是<code>Mark-Sweep算法</code>跟Scavenge算法的区别是，后者需要复制后再清理，前者不需要，<code>Mark-Sweep</code>直接标记活动对象和非活动对象之后，就直接执行清理了。</p><ul><li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li><li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/e8767d07d348429d8205e33c77637c0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></li></ul><p>由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多零零散散的空位。</p><h3 id="Mark-Compact-标记整理"><a href="#Mark-Compact-标记整理" class="headerlink" title="Mark-Compact(标记整理)"></a>Mark-Compact(标记整理)</h3><p><code>Mark-Sweep算法</code>执行垃圾回收之后，留下了很多<code>零零散散的空位</code>，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从<code>零零散散的空位</code>中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是<code>Mark-Sweep算法</code>的一个缺点<br>这个时候<code>Mark-Compact算法</code>出现了，他是<code>Mark-Sweep算法</code>的加强版，在Mark-Sweep算法的基础上，加上了<code>整理阶段</code>，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/f7da553309a04432ba93840a1c06ca36~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="2-全停顿-Stop-The-World"><a href="#2-全停顿-Stop-The-World" class="headerlink" title="2. 全停顿(Stop-The-World)"></a>2. 全停顿(Stop-The-World)</h3><p>说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，<code>垃圾回收优先于代码执行</code>，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为<code>全停顿</code></p><p>由于新生代空间小，并且存活对象少，再配合<code>Scavenge算法</code>顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了<code>卡顿现象</code></p><h3 id="3-Orinoco优化"><a href="#3-Orinoco优化" class="headerlink" title="3. Orinoco优化"></a>3. Orinoco优化</h3><p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决<code>全停顿问题</code>,它提出了<code>增量标记、懒性清理、并发、并行</code>的优化方法。</p><h3 id="3-1-增量标记-Incremental-marking"><a href="#3-1-增量标记-Incremental-marking" class="headerlink" title="3.1 增量标记(Incremental marking)"></a>3.1 增量标记(Incremental marking)</h3><p>咱们前面不断强调了<code>先标记，后清除</code>，而增量标记就是在<code>标记</code>这个阶段进行了优化。我举个生动的例子：路上有很多<code>垃圾</code>，害得<code>路人</code>都走不了路，需要<code>清洁工</code>打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。</p><p>大家把上面例子里，<code>清洁工清理垃圾的过程——标记过程，路人——JS代码</code>，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：<code>标记一点，JS代码运行一段</code>，从而提高效率</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/a5719b8cec604c98b5d55a39df776fb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="3-2-惰性清理-Lazy-sweeping"><a href="#3-2-惰性清理-Lazy-sweeping" class="headerlink" title="3.2 惰性清理(Lazy sweeping)"></a>3.2 惰性清理(Lazy sweeping)</h3><p>上面说了，增量标记只是针对<code>标记</code>阶段，而惰性清理就是针对<code>清除</code>阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就<code>延迟了清理</code>，让JS代码先执行，或者<code>只清理部分垃圾</code>，而不清理全部。这个优化就叫做<code>惰性清理</code><br>整理标记和惰性清理的出现，大大改善了<code>全停顿</code>现象。但是问题也来了：增量标记是<code>标记一点，JS运行一段</code>，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成<code>对象引用改变，标记错误</code>现象。这就需要使用<code>写屏障</code>技术来记录这些引用关系的变化</p><h3 id="3-3-并发-Concurrent"><a href="#3-3-并发-Concurrent" class="headerlink" title="3.3 并发(Concurrent)"></a>3.3 并发(Concurrent)</h3><p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行<code>写屏障</code>操作。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/204846e6d5614529b71bc67114c2b6df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="3-4-并行"><a href="#3-4-并行" class="headerlink" title="3.4 并行"></a>3.4 并行</h3><p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/d55ad43196a34c8b996aa21f2e1dabf7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h2 id="V8当前的垃圾回收机制"><a href="#V8当前的垃圾回收机制" class="headerlink" title="V8当前的垃圾回收机制"></a>V8当前的垃圾回收机制</h2><p>2011年，V8应用了<code>增量标记机制</code>。直至2018年，Chrome64和Node.js V10启动<code>并发标记（Concurrent）</code>，同时在并发的基础上添加<code>并行（Parallel）技术</code>，使得垃圾回收时间大幅度缩短。</p><h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从<code>from-to</code>复制到<code>space-to</code>的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/ca66013ea62f4637bd57744a5e62326f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p><h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，<code>写屏障（write barriers）</code>技术会在辅助线程在进行并发标记的时候进行追踪。</p><p>当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/97a854ba9a464ba8adf143a5612ad91c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Javascript内存管理&quot;&gt;&lt;a href=&quot;#一、Javascript内存管理&quot; class=&quot;headerlink&quot; title=&quot;一、Javascript内存管理&quot;&gt;&lt;/a&gt;一、Javascript内存管理&lt;/h2&gt;&lt;p&gt;JavaScript内存的流
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="V8" scheme="http://yoursite.com/tags/V8/"/>
    
      <category term="垃圾回收机制" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Javascript如何避免内存泄漏</title>
    <link href="http://yoursite.com/2022/03/10/Javascript%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2022/03/10/Javascript如何避免内存泄漏/</id>
    <published>2022-03-10T12:49:51.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、如何监控内存状况"><a href="#一、如何监控内存状况" class="headerlink" title="一、如何监控内存状况"></a>一、如何监控内存状况</h2><p>这里借用一下<a href="https://juejin.cn/user/1292681407377624">林三心</a>大佬的图文。</p><h3 id="浏览器任务管理器"><a href="#浏览器任务管理器" class="headerlink" title="浏览器任务管理器"></a>浏览器任务管理器</h3><p>打开方式：在浏览器顶部右键，打开任务管理器：</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310164329157.png" alt="image-20220310164329157"></p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310164734409.png" alt="image-20220310164734409"></p><p>打开后，可以看到内存和JavaScript内存：</p><ul><li>内存：页面里的原始内存，也就是<strong>DOM节点</strong>的总占用内存</li><li>JavaScript内存(括号里)：是该页面中所有<strong>可达对象</strong>的总占用内存</li></ul><p>那什么是<strong>可达对象</strong>呢？简单说就是：就是从初始的根对象（window或者global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，搜不到，说明该子节点对象不可达。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可达，可以通过window.name访问</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Zh&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> () &#123;<br>    <span class="hljs-comment">// 不可达，访问不了</span><br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Zh&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>回到我们的任务管理，此时我们在页面中编写一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><br>点击前：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165143724.png" alt="image-20220310165143724"><br>点击后，发现内存瞬间上升：<br><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165024376.png" alt="image-20220310165024376"></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>使用Chrome浏览器的<strong>无痕模式</strong>，是为了避免很多其他因素，影响咱们查看内存：</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165336577.png" alt="image-20220310165336577"></p><p>按F12打开调试窗口，选择<strong>Performance</strong></p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165416413.png" alt="image-20220310165416413"></p><p>咱们就以掘金首页为例吧！<strong>点击录制 -&gt; 刷新掘金 -&gt; 点击stop</strong>，可以看到以下指标随着时间的<code>上下波动</code>：</p><ul><li><p><code>JS Heap</code>：JS堆</p></li><li><p><code>Documents</code>: 文档</p></li><li><p><code>Nodes</code>: DOM节点</p></li><li><p><code>Listeners</code>: 监听器</p></li><li><p><code>GPU Memory</code>: GPU内存</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/1c8bc35ae2c64dc692fe94a925c0ed5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="juejinperf.gif"></p></li></ul><h3 id="堆快照"><a href="#堆快照" class="headerlink" title="堆快照"></a>堆快照</h3><p><strong>堆快照</strong>，顾名思义，就是将当前某一个页面的堆内存拍下照片存起来，同一个页面，执行某个操作前，录制堆快照是一个样，有可能执行完后，录制的堆快照又是另外一个样。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220310165725251.png" alt="image-20220310165725251"></p><p>还是以<strong>掘金首页</strong>为例，可以看到当前页面内存为<strong>13.3M</strong>，咱们可以选择<strong>Statistics</strong>，查看<strong>数组，对象，字符串</strong>等所占内存。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/f3159441afe843c4b36993f9db54d19b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="掘金堆快照.gif"></p><h2 id="二、内存泄漏的场景"><a href="#二、内存泄漏的场景" class="headerlink" title="二、内存泄漏的场景"></a>二、内存泄漏的场景</h2><p>下面列举了可能会造成<strong>内存泄漏</strong>的情况：</p><ol><li>闭包使用不当引起内存泄漏</li><li>全局变量</li><li>分离的DOM节</li><li>控制台的打印</li><li>未清除的定时器<br>接下来我们一一来介绍这些情况。</li></ol><h3 id="1-闭包使用不当"><a href="#1-闭包使用不当" class="headerlink" title="1.闭包使用不当"></a>1.闭包使用不当</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br><br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">let</span> a = []<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    a.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn1</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中<strong>f1</strong>被调用后，从<strong>可达性</strong>的角度来说，<strong>arr</strong>应该被回收，但实际上并不是这样的。<strong>f1</strong>将<strong>arr</strong>return之后，<strong>arr</strong>被<strong>push</strong>进了数组<strong>a</strong>，而数组<strong>a</strong>是一个全局变量，并不会被回收，这就导致了<strong>arr</strong>不会被回收。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量一般不会被垃圾回收机制回收。当然，这并不意味着完全禁止我们定义全局变量，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 此处变量arr未被声明</span><br>    arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br>&#125;<br><span class="hljs-title function_">fn1</span>()<br></code></pre></td></tr></table></figure><p>上述代码会自动在全局创建一个变量<strong>arr</strong>，并将数组赋值给<strong>arr</strong>，由于是全局变量，所以<strong>arr</strong>的内存一直不会释放。</p><p>因此，我们平时需多加注意，不要在变量未声明前赋值，或者也可以开启严格模式，这样就会在不知情犯错时，收到报错警告，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>    name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)<br>&#125;<br><br><span class="hljs-title function_">fn1</span>()<br></code></pre></td></tr></table></figure><h3 id="3-分离的dom节点"><a href="#3-分离的dom节点" class="headerlink" title="3.分离的dom节点"></a>3.分离的dom节点</h3><p>让我们用代码来解释一下什么为<strong>分离的dom节点</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(btn)<br></code></pre></td></tr></table></figure></p><p>如上所示，虽然最后把<strong>button</strong>给删除了，但是因为全局变量<strong>btn</strong>对此<strong>DOM对象</strong>引用着，导致此<strong>DOM对象</strong>一直没有被回收，这个<strong>DOM对象</strong>就称为<strong>分离DOM</strong></p><p>这个问题很好解决，删除button后，顺便把btn设置成null就行了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;点击&lt;/button&gt;<br><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(btn)<br>btn = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></p><h3 id="4-控制台的打印"><a href="#4-控制台的打印" class="headerlink" title="4.控制台的打印"></a>4.控制台的打印</h3><p>控制台的打印也会造成内存泄漏吗？？？是的呀，如果浏览器不一直保存着我们打印对象的信息，我们为何能在每次打开控制的Console时看到具体的数据呢？先来看一段测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;按钮&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">100000</span>)</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.log(obj);</span></span></span><br><span class="hljs-params"><span class="language-javascript"><span class="language-xml">    &#125;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>当我们点击按钮时，这个<strong>arr</strong>会被控制台打印下来，浏览器一直保存着这个<strong>arr</strong>的信息，并不会被垃圾回收机制回收。</p><p>虽然<strong>console.log</strong>便于调试，但是我们在<strong>生产环境</strong>，我们尽可能不要在控制台打印数据，所以我们经常会在代码中看到类似如下的操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果在开发环境下，打印变量obj</span><br><span class="hljs-keyword">if</span>(isDev) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)<br>&#125;<br></code></pre></td></tr></table></figure><br>这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了<strong>console.log</strong>之外，<strong>console.error</strong>、<strong>console.info</strong>、<strong>console.dir</strong>等等都不要在生产环境下使用</p><h3 id="5-未清除的定时器"><a href="#5-未清除的定时器" class="headerlink" title="5.未清除的定时器"></a>5.未清除的定时器</h3><p>下面这段代码中，执行完<strong>fn1</strong>函数，按理说<strong>arr</strong>数组会被回收，但是他却回收不了。为什么呢？因为定时器里的<strong>a</strong>引用着<strong>arr</strong>，并且定时器不清除的话，<strong>a</strong>就不会被回收，<strong>a</strong>不回收就会一直引用着<strong>arr</strong>，那么<strong>arr</strong>肯定也回收不了了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;Sunshine_Lin&#x27;</span>)<br>      <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> a = arr<br>     &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>处理的方法也很简单，只要我们清除定时器就行了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;Sunshine_Lin&#x27;</span>)<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>)  <span class="hljs-built_in">clearInterval</span>(timer)<br>    <span class="hljs-keyword">let</span> a = arr<br>    i++<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">fn</span>()<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在项目过程中，如果遇到了某些性能问题可能跟内存泄漏有关时，就可以参照以上列举的5种情况去排查。</p><p>虽然JavaScript的垃圾回收是自动的，但我们有时也是需要考虑要不要手动清除某些变量的内存占用的，例如你明确某个变量在一定条件下再也不需要，但是还会被外部变量引用导致内存无法得到释放时，你可以用null对该变量重新赋值就可以在后续垃圾回收阶段释放该变量的内存了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6995706341041897486">赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！</a><br><a href="https://juejin.cn/post/6996828267068014600">哪是大神？只是用他人七夕约会时间，整理「JS避免内存泄漏」罢了</a><br><a href="https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、如何监控内存状况&quot;&gt;&lt;a href=&quot;#一、如何监控内存状况&quot; class=&quot;headerlink&quot; title=&quot;一、如何监控内存状况&quot;&gt;&lt;/a&gt;一、如何监控内存状况&lt;/h2&gt;&lt;p&gt;这里借用一下&lt;a href=&quot;https://juejin.cn/user/
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中isNaN和Numer.isNaN的区别</title>
    <link href="http://yoursite.com/2022/03/09/Javascript%E4%B8%ADisNaN%E5%92%8CNumer.isNaN%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2022/03/09/Javascript中isNaN和Numer.isNaN的区别/</id>
    <published>2022-03-09T02:32:01.000Z</published>
    <updated>2022-06-06T03:22:14.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p>当我们将参数传入<strong>isNaN</strong>时，它的内部实现调用了<strong>Number()</strong>方法将参数转换为Number类型，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>若能成功转换为Number类型，<strong>isNaN</strong>返回false，否则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p><blockquote><p>Javascript中0 / 0返回的是NaN，而非0数值除以0返回的是Infinity</p></blockquote><h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h3><p><strong>判断传入的参数是否严格等于NaN（也就是===）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>使用场景：判断某个运算的结果是否为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">value</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>();<br>&#125;<br><span class="hljs-title function_">check</span>(<span class="hljs-number">1</span> / <span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;isNaN&quot;&gt;&lt;a href=&quot;#isNaN&quot; class=&quot;headerlink&quot; title=&quot;isNaN()&quot;&gt;&lt;/a&gt;isNaN()&lt;/h3&gt;&lt;p&gt;当我们将参数传入&lt;strong&gt;isNaN&lt;/strong&gt;时，它的内部实现调用了&lt;strong&gt;Numbe
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>词法作用域？动态作用域？闭包是如何产生的？</title>
    <link href="http://yoursite.com/2022/03/08/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E9%97%AD%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2022/03/08/词法作用域？动态作用域？闭包是如何产生的？/</id>
    <published>2022-03-08T11:50:03.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域，就是说跟我们写代码时将变量定义在哪个函数作用域或者块作用域中有关系，大多数情况是不变的（evel/with会修改）<img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220308203325592.png" alt="image-20220308203325592"></p><blockquote><p>图片来自《你不知道的Javascript》</p></blockquote><ol><li>包含着全局作用域，包括标识符foo</li><li>包含着foo所创建的作用域，包括标识符：a,bar和b</li><li>包含着bar所创建的作用域, 包括标识符c<br>无论函数在哪里被调用，它的词法作用域都只有函数被声明时所处的位置决定。</li></ol><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>首先我们先了解一下什么是动态作用域，再看闭包与它的区别。</p><p><strong>动态作用域</strong>就是说当查询标识符的时候不是按照词法作用域嵌套来查找，而是按照调用顺序来查找的， 也就是说 动态作用域不关注你在什么地方声明，它只关心是在何处调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span> <br>  <span class="hljs-title function_">foo</span>()<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> <br><br><span class="hljs-title function_">bar</span>() <span class="hljs-comment">// 3 不是2</span><br></code></pre></td></tr></table></figure><blockquote><p>事实上输出的是2，JavaScript并不具有动态作用域,它只有词法作用域,简单明了,但是this机制某种程度上很像动态作用域</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当函数<strong>可以记住并访问所在的词法作用域</strong>时，就产生了<strong>闭包</strong>，即使函数是在当前词法作用域之外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar<br>&#125;<br><br><span class="hljs-keyword">let</span> baz = <span class="hljs-title function_">foo</span>()<br><span class="hljs-title function_">baz</span>() <span class="hljs-comment">// 2 </span><br></code></pre></td></tr></table></figure><p>上述代码中<strong>foo()</strong>执行之后返回一个内部函数<strong>bar</strong>，然后被赋值给了<strong>baz</strong>，当<strong>baz</strong>被调用时实际上就是调用了<strong>bar</strong>，输出了函数<strong>foo</strong>作用域中的变量<strong>a</strong>。</p><p><strong>无论使用何种方式对函数类型的值传递，当函数在其他作用域被调用时都可以理解为闭包。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;词法作用域&quot;&gt;&lt;a href=&quot;#词法作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h2&gt;&lt;p&gt;词法作用域就是定义在词法阶段的作用域，就是说跟我们写代码时将变量定义在哪个函数作用域或者块作用域中有关系，大多数情况
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Javascript的事件循环机制(event loop)</title>
    <link href="http://yoursite.com/2022/03/04/Javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6(event%20loop)/"/>
    <id>http://yoursite.com/2022/03/04/Javascript的事件循环机制(event loop)/</id>
    <published>2022-03-04T13:47:33.000Z</published>
    <updated>2022-06-06T03:22:14.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Javascript引擎的特点：单线程与非阻塞"><a href="#一、Javascript引擎的特点：单线程与非阻塞" class="headerlink" title="一、Javascript引擎的特点：单线程与非阻塞"></a>一、Javascript引擎的特点：单线程与非阻塞</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><blockquote><p>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p></blockquote><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。非阻塞是通过事件循环机制实现的。JS通常是非阻塞的，除了某些特殊情况，JS会停止代码执行。</p><h2 id="二、事件循环（Event-Loop）"><a href="#二、事件循环（Event-Loop）" class="headerlink" title="二、事件循环（Event Loop）"></a>二、事件循环（Event Loop）</h2><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>单线程意味着所有任务需要排队，如果前一个任务耗时很长，就会对后续任务造成阻塞。</p><p>如果造成阻塞的任务是因为计算量大，那么情有可原，毕竟CPU的利用率高，但如果是等待IO设备的响应，那么这种情况下CPU利用率很低，那显然是不合理的。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><blockquote><p>（1） 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><p>下图就是主线程和任务队列的示意图。</p><p><img src="https://image-1253774868.cos.ap-nanjing.myqcloud.com/img/image-20220304213510129.png" alt=""></p><h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p><p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><p>以一道经典的面试题为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);   <br>  &#125;,<span class="hljs-number">0</span>); <br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题的结果为：3，3，3</p><blockquote><p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p></blockquote><p>然而，即使第二个参数真实值也为0ms，答案依然为3，3，3。如前面所述，setTimeout()将事件插入了”任务队列“，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>以下事件属于宏任务：</p><ul><li>setInterval()</li><li>setTimeout()</li><li>setImmediate(Node.js 环境)</li></ul><p>以下事件属于微任务：</p><ul><li>Promise.then</li><li>Object.observe</li><li>MutationObserver</li><li><p>process.nextTick(Node.js 环境)</p><p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的事件加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><blockquote><p>微任务在本轮“事件循环”结束时执行，宏任务在下一轮“事件循环”开始时执行。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Javascript引擎的特点：单线程与非阻塞&quot;&gt;&lt;a href=&quot;#一、Javascript引擎的特点：单线程与非阻塞&quot; class=&quot;headerlink&quot; title=&quot;一、Javascript引擎的特点：单线程与非阻塞&quot;&gt;&lt;/a&gt;一、Javascrip
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：TwoStreamVAN</title>
    <link href="http://yoursite.com/2020/12/25/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9ATwoStreamVAN/"/>
    <id>http://yoursite.com/2020/12/25/论文速读：TwoStreamVAN/</id>
    <published>2020-12-25T03:13:07.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_WACV_2020/papers/Sun_TwoStreamVAN_Improving_Motion_Modeling_in_Video_Generation_WACV_2020_paper.pdf">TwoStreamVAN: Improving Motion Modeling in Video Generation</a></p></blockquote><p><img src="https://i.loli.net/2020/12/24/QuJrB95NZzkI42s.png" alt=""></p><p>像素级视频预测[27，36，40]和生成方法的一个主要问题是，它们试图在单个纠缠生成器中对静态内容和动态运动进行建模，而不管它们是否在潜在空间中解开运动和内容\</p><p>本文认为在解码阶段分离运动和内容建模是至关重要的。一方面，它消除了内容生成过程中的运动干扰，并产生了更好的内容结构。另一方面，单独的运动建模有助于在整个序列中一致地产生与动作相关的运动。</p><p>本文提出了一个新的<strong>TwoStreamVAN</strong>，它从一个动作标签和一个分离的噪声向量生成一个视频，如上x`图所示。通过两个并行的生成器，分别处理内容和运动，并将它们融合在一起以预测下一帧，而不是高估单个生成器的能力（如MoCoGAN的做法）。</p><p>直观地说，运动通常以其局部上下文窗口内的空间信息为条件，例如，在做跳跃动作时，手臂和腿部附近的不同运动。因此，我们将运动和内容的融合定义为对每个位置唯一的像素值的学习细化。为了精确地生成多尺度运动，我们在具有几个不同分辨率的中间内容层上进行这种细化。此外，我们还引入了运动蒙版，使运动聚焦于它所在的区域。</p><p>本文将引入<strong>图像级监控（image-levelsupervision）</strong>，虽然<strong>MoCoGAN</strong>尝试了图像级监控缺效果甚微，因为内容生成仍然受到单个共享生成器中运动建模的影响。本文使用的双流生成器的关键优势是能分别学习每个流，从而更准确。我们通过图像级监控完全了解其自身生成器中的图像结构，这显著提高了内容生成性能。训练有素的内容生成进一步有利于视频级监控中的动作学习。</p><p>本文贡献如下：</p><ul><li>我们提出了一个视频生成模型TwoStreamVAN和一个更有效的学习方案，解决了生成阶段的运动和内容问题。</li><li>我们设计了一种多尺度运动融合机制，并通过对空间环境的调节进一步改进了运动建模</li><li>我们创建了一个大规模的合成视频生成数据集，供研究团体使用</li><li>我们在四个视频数据集上通过定量和定性分析评估了我们的模型（通过用户研究），并证明了强于几个强基线的结果。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>本文结合了<strong>VAE</strong>和<strong>GAN</strong>，提出了一个<strong>变分对抗网络(VAN)</strong>来学习一个可解释的潜在空间以及生成现实的图像。鉴于<strong>VAN</strong>在图像生成方面的成功，我们在此将其用于视频生成。</p><p>MoCoGAN试图通过从单独的潜在空间中采样来解开内容和运动，但是使用单个生成器来一起解码这两个潜在代码。为了克服统一生成过程中无效的运动建模和随之而来的内容恶化，我们进一步引入了分离的内容和运动生成器来分别对空间结构和时间动态进行建模。</p><h2 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3. Approach"></a>3. Approach</h2><p>我们引入了一个双流变分对抗网络(图2)，它生成一个给定输入动作标签和随机噪声向量的视频。我们定义动作条件视频生成如下。假设我们有<strong>K</strong>个不同的动作类。在每个类别<strong>k ∈ 1: K</strong> 的情况下，<script type="math/tex">C_{k}</script>为该类别训练视频的数量。使<script type="math/tex">V_{k}</script> = {<script type="math/tex">V_{i,k}, \forall i \in 1:C_{k}</script>}为类别<strong>k</strong>视频的集合，<script type="math/tex">v_{i,k}</script>={<script type="math/tex">x_{1},x_{2},...,x_{T}</script>}为一个T帧的短视频。任务是定义一个函数<strong>G</strong>，该函数根据来自潜在向量<script type="math/tex">\epsilon</script> ∈ <script type="math/tex">ℝ^{N}</script>，给定类别标签k，生成可信的视频<script type="math/tex">\hat{v}</script>，即<script type="math/tex">\hat{v} = G(k,\epsilon)</script></p><p>我们将潜在空间<script type="math/tex">\epsilon</script>分解成两个独立的代码:内容代码<script type="math/tex">\epsilon_{c}</script>∈ <script type="math/tex">ℝ^{C}</script>和动作代码<script type="math/tex">\epsilon_{m}</script>∈<script type="math/tex">ℝ^{M}</script>，N = C + M.我们还将视频生成函数<strong>G</strong>分解为两个独立的内容和运动函数($ G<em>{c} $和$ G</em>{m} $)，与以前使用单个生成器的工作形成对比，我们设计了一种新的多尺度融合机制。</p><p><img src="https://i.loli.net/2020/12/24/XulgzWHeoixMRTb.png" alt=""></p><h3 id="3-1-Two-Stream-Generation"><a href="#3-1-Two-Stream-Generation" class="headerlink" title="3.1 Two-Stream Generation"></a>3.1 Two-Stream Generation</h3><p>为了学习内容和运动建模的生成函数$ G<em>{c} $和$ G</em>{m} $，我们引入了两个独立的、在几个阶段具有交互作用的以动作为条件的VAN streams。每个steam包含一个<strong>Encoder</strong>，一个<strong>Generator</strong>和一个<strong>Discriminator</strong>，其中<strong>Encoder</strong>和<strong>Generator</strong>作为<strong>VAE</strong>的自动编码器，<strong>Generator</strong>和<strong>Discriminator</strong>组成了<strong>GAN</strong></p><p><strong>Content VAN Stream</strong>由内容编码器$ E<em>{c} $、内容生成器$ G</em>{c} $和图像鉴别器$ D<em>{I} $组成，在观察了<strong>x</strong>之后，生成了后验内容潜在分布$ q(z</em>{c}|x,k) $，这接近于它的真实先验分布$ p(z<em>{c}|k) $.$ G</em>{c} $将采样自内容分布的的内容向量$ \epsilon<em>{c} $解码成帧。$ D</em>{I} $鉴别帧的真假以鼓励$ G_{c} $生成更真实的图像。</p><p>类似地，<strong>Motion VAN Stream</strong>由运动编码器$ E<em>{m} $、运动生成器$ G</em>{m} $和视频鉴别器$ D<em>{V} $组成，在我们的方法中，$ E{m} $不是对空间内容进行编码，而是对相邻帧之间的差异图$ \triangle x $的时间动态进行编码。它产生的后验运动潜在分布$ q(z</em>{m}|\triangle x,k) $接近其真实的先验分布$ p(z<em>{m}|k) $.<strong>convLSTM</strong>对运动历史进行累积，并生成当前运动，嵌入$ e</em>{m} $，从所有先前时间步长的运动分布中接收$ \epsilon<em>{m} $序列。$ G</em>{m} $通过$ \epsilon<em>{c} $和$ e</em>{m} $在不同的尺度上产生运动。我们通过将生成的运动与<strong>T</strong>时间步长的相应内容融合来生成每个视频$ \hat{v} $。$ D<em>{V} $对真实/生成的视频进行了分类，并对他们的行为进行了分类，以鼓励$ G</em>{m} $生成逼真的动作</p><h3 id="Multi-scale-Motion-Generation-and-Fusion"><a href="#Multi-scale-Motion-Generation-and-Fusion" class="headerlink" title="Multi-scale Motion Generation and Fusion"></a>Multi-scale Motion Generation and Fusion</h3><p>在像素(a, b)处，运动通常发生在相邻帧之间的局部窗口内。受帧插值空间卷积的启发，我们将运动表示为当前像素值基础局部上下文的细化，并通过空间自适应卷积将这种运动与内容融合。此外，我们提出了一种新的多尺度融合机制来克服其方法的缺点，即:1)由于在全分辨率图像上执行单个融合步骤而导致的多尺度运动的无效建模，以及2)由于用于表示最大可能运动的大卷积核而导致的对存储器的高需求。</p><p><img src="https://i.loli.net/2020/12/24/4NQFA9ECBtfpxza.png" alt=""></p><p>为了生成精确的运动，$ G<em>{m} $将解开的内容和运动嵌入($ \epsilon</em>{c} $和$ e<em>{m} $)作为输入。在$ G</em>{m} $中，不同尺度的运动将相应的隐藏层分开:大的运动来自低分辨率层，小的运动来自高分辨率层。在每一层，$ G_{m} $将当前特征映射为:1)以具有尺寸n的像素方式的2D核的形式计算运动(像素细化);2)识别运动遮罩中包含实际运动的区域；3)生成下一层的运动图。为了将运动与内容融合，仅当像素位于运动被激活的区域中时，我们才分别将生成的2D核与以相应像素为中心的面片进行卷积(即，执行空间自适应卷积)(参见上图)。</p><p>具体来说，假设我们把运动分成<strong>S</strong>个尺度。对于每个尺度的<strong>s</strong>，让$ l<em>{s} $为相对应的分辨率隐藏层，$ w^{s} ∈ ℝ^{l</em>{s}×l<em>{s}×n^{2}} $为$ G</em>{m} $产生的卷积核，$ h<em>{c}^{s} ∈ ℝ^{l</em>{s} × l<em>{s} × d</em>{s}} $为相对应的内容层，其中$ d<em>{s} $是内容特征维度。我们在以下步骤中执行空间自适应卷积。首先，对于每个位置(a,b)，我们从展开形式$ w^{s}(a,b) $恢复一个2D卷积核$ K^{s}(a,b) $.然后，我们将$ K^{s}(a,b) $与在$ h</em>{c}^{s} $的补丁$ P^{s}(a,b) ∈ ℝ^{n×n×d<em>{s}} $做卷积运算来生成一个位置(a,b)中间内容表示 $ \tilde{h}</em>{c}^{s}(a,b) $:</p><p><img src="https://i.loli.net/2020/12/25/F4I7zgub9ahVnft.png" alt="image-20201225105952830"></p><p>我们通过向较小的层添加自适应卷积来处理较大的运动，而[29]则通过增加核大小来处理较大的运动。由于要存储和建模的参数数量在核大小中是平方的，因此在我们的多尺度融合框架中，我们通过对所有层利用小核(푛=3或5)来显著降低内存使用量和模型复杂度</p><p>为了$ G<em>{m} $的注意力集中学习尺度<strong>s</strong>在实际发生的区域的运动上，我们预测了一个带有$ w^{s} $的运动遮罩$ M^{s} ∈ ℝ^{l</em>{s}×l<em>{s}} $，以识别这样的区域。每个$ M^{s} $的的值都在[0，1]中。我们在$ M^{s}(a,b) $:的指导下通过融合运动从$ h</em>{c}^{s}(a,b) $和 $ \tilde{h}<em>{c}^{s}(a,b) $生成了新的内容$ \hat{h}</em>{c}^{s} $：</p><p><img src="https://i.loli.net/2020/12/25/NLE6c9F4XHe2CaY.png" alt="image-20201225110922089"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：G3AN</title>
    <link href="http://yoursite.com/2020/12/24/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AG3AN/"/>
    <id>http://yoursite.com/2020/12/24/论文速读：G3AN/</id>
    <published>2020-12-24T03:53:37.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Wang_G3AN_Disentangling_Appearance_and_Motion_for_Video_Generation_CVPR_2020_paper.pdf">G3AN: Disentangling Appearance and Motion for Video Generation</a></p></blockquote><p>在推断和建模人类视频的分布时，生成模型面临三个主要挑战:(a)生成不确定运动，(b)在整个生成的视频中保持人类外观，以及(c)建模时空一致性。</p><p>本文提出了一个新的被简化的生成模型<script type="math/tex">G^{3}AN</script>，以学习视频生成因子外观和运动的解纠结表示，允许对两者进行操作。解纠缠表示被定义为单个潜在单位对单个生成因素的变化敏感，而对其他因素的变化相对不变[4]。在这种情况下，我们的G3AN被赋予了一个<strong> three-stream</strong>生成器架构，其中主流编码时空视频表示，由两个辅助流增强，表示独立的生成因子外观和运动。针对高级功能图的<strong>self-attention</strong>机制可确保令人满意的视频质量。</p><p><script type="math/tex">G^{3}AN</script>因此能够通过遵循训练分布而不需要额外的输入来生成逼真的视频(应对挑战(a)和(c))，并且能够分离地操纵外观和运动，同时强调保持外观(挑战(b))。</p><p>本文的技术贡献包括以下内容：</p><ul><li><p>一种新的生成模型G3AN，它试图从人类视频数据中学习生成外观和运动因素的解纠缠表示。这些表示允许对这两个因素进行单独操作。</p></li><li><p>一种新颖的<strong>three-stream</strong>生成器，它同时考虑了个体外观特征(空间流)、运动特征(时间流)和平滑生成的视频(主流)的学习</p></li><li><p>一种新的<strong>factorized spatio-temporal self-attention(F-SA)</strong>被认为是第一个应用于视频生成的<strong>self-attention</strong>模块，用于对全局时空表示进行建模，提高生成视频的质量。</p></li><li><p>广泛的定性和定量评估，证明了G3AN在一系列数据集上系统地、显著地优于最先进的基线。</p></li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>虽然视频生成任务旨在生成真实的时间动态，但这些任务会随着条件作用的水平而变化。我们有基于与运动或外观相关的附加先验的视频生成，相反，视频生成仅遵循训练分布。我们注意到，从建模的角度来看，后者更具挑战性，因为缺少关于例如生成的视频的结构的附加输入。因此，迄今为止的大多数方法都包含某种<strong>条件作用</strong>。</p><p><strong>Video generation from noise</strong>。从噪声中直接生成视频需要捕获数据集分布并对其建模。最接近本文工作的是<strong>MoCoGAN</strong>，它将每一帧的潜在表现分解为运动和内容，旨在控制这两个因素。然而，<strong>MoCoGAN</strong>和<script type="math/tex">G^{3}AN</script>之间有两个关键的区别。首先，<strong>MoCoGAN</strong>不是对每个视频只采样两个噪声矢量，而是采样一系列噪声矢量作为运动，一个固定的噪声作为内容。然而，为每一帧引入随机噪声来表示运动增加了学习难度，因为模型必须将这些噪声向量映射到生成的视频中的连续人体运动。因此，MoCoGAN逐渐忽略输入噪声，并倾向于产生类似的运动。</p><h2 id="3-Approach"><a href="#3-Approach" class="headerlink" title="3.Approach"></a>3.Approach</h2><p>在这项工作中，我们提出了<script type="math/tex">G^{3}AN</script>，一种新颖的GAN架构，旨在从两个噪声矢量<script type="math/tex">z_{a}</script> ∈ <script type="math/tex">Z_{A}</script>和<script type="math/tex">z_{m}</script>∈ <script type="math/tex">Z_{M}</script>(分别代表外观和运动)中以分离的方式生成视频。<script type="math/tex">G^{3}AN</script>由一个三流发生器<strong>G</strong>和一个双流鉴别器<strong>D</strong>组成，如下图所示。<strong>G</strong>的目标是生成能够同时调节外观和运动的视频，而<strong>D</strong>则分别在视频和帧中区分生成的样本和真实数据。</p><p><img src="https://i.loli.net/2020/12/24/DqKO3zug159r7da.png" alt=""></p><p><img src="https://i.loli.net/2020/12/24/SHYvbkaCuUIN7rw.png" alt=""></p><h3 id="3-1-Generator"><a href="#3-1-Generator" class="headerlink" title="3.1 Generator"></a>3.1 Generator</h3><p>我们在<script type="math/tex">G^{3}</script>模块的层次结构中设计<strong>G</strong>。具体来说，我们有<code>N</code>个层次，表示为<script type="math/tex">G_{n=0...N-1}^{3}</script>。第一个<script type="math/tex">G^{3}</script>模块<script type="math/tex">G_{0}^{3}</script>接受两个噪声矢量<script type="math/tex">z_{a}</script>和<script type="math/tex">z_{m}</script>作为输入。其余模块<script type="math/tex">G_{n=1...N-1}^{3}</script>，继承三个特征映射<script type="math/tex">F_{S_{n-1}}</script>、<script type="math/tex">F_{V_{n-1}}</script>和<script type="math/tex">F_{T_{n-1}}</script>，作为它们来自每个先前<script type="math/tex">G_{n-1}^{3}</script>模块的输入，如上图所示。</p><p>每个<script type="math/tex">G^{3}</script>模块由三个并行流组成:空间流<script type="math/tex">G_{S_{n}}</script>、时间流<script type="math/tex">G_{T_{n}}</script>以及视频流<script type="math/tex">G_{V_{n}}</script>。它们被设计成产生三种不同类型的特征。在上图中用蓝线表示的空间流将n  = 0时的<script type="math/tex">z_{a}</script>和n &gt;  1时的<script type="math/tex">F_{S_{n-1}}</script>作为输入，并通过使用转置的2D卷积层对输入特征进行上采样来生成2D外观特征<script type="math/tex">F_{S_{n}}</script>。这些特征在空间维度上发展，并在所有时间实例中共享。用橙色线表示的时间流<script type="math/tex">G_{T_{n}}</script>接受n  = 0的<script type="math/tex">z_{m}</script>和n &gt;  1的<script type="math/tex">F_{T_{n-1}}</script>作为输入，并试图通过用转置的1D卷积层对输入特征进行上采样来生成1D运动特征<script type="math/tex">F_{T_{n}}</script>。这些特征在时间维度上演化，并包含每个时间步长的全局信息。然后，用黑线表示的视频流<script type="math/tex">G_{V_{n}}</script>将n  = 0的<script type="math/tex">z_{a}</script>、<script type="math/tex">z_{m}</script>和n &gt; 1的<script type="math/tex">F_{V_{n-1}}</script>的连接作为输入。它对时空一致性进行建模，并通过对输入要素进行上采样和因子化转置时空卷积来产生3D联合嵌入<script type="math/tex">F_{V_{n}^{'}}</script>。然后将<script type="math/tex">F_{S_{n}}</script>和<script type="math/tex">F_{T_{n}}</script>弹射到时空融合块，在此与<script type="math/tex">F_{V_{n}^{'}}</script>融合，产生<script type="math/tex">F_{V_{n}}</script>。最后，<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{V_{n}}</script>作为下一个分层<script type="math/tex">G_{n+1}^{3}</script>的输入。</p><p>王等人在[40]中提出了<strong>Factorized transposed spatio-temporal convolution</strong>。它明确地将转置的3D卷积分解成两个独立且连续的运算，M个转置的1D时间卷积之后是2D独立的空间卷积，其被称为转置的(1+2)D卷积。这种分解在这两个操作之间带来了额外的非线性激活，并有助于优化。至关重要的是，分解转置的3D卷积产生了视频质量的显著提高</p><p><strong>Spatio-temporal fusion</strong>是学习好解纠缠特征的关键，其输入是来自每个<script type="math/tex">G^{3}</script>模块卷积层的输出特征映射<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>以及<script type="math/tex">F_{V_{n}^{'}}</script>。融合包含三个步骤(见下图)。首先，分别对<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{S_{n}}</script>进行空间和时间复制，以获得两个新的特征图<script type="math/tex">F_{T_{n}}^{R}</script>和<script type="math/tex">F_{S_{n}}^{R}</script>。两个新的特征图都具有与<script type="math/tex">F_{V_{n}^{'}}</script>相同的时空大小。接下来，通过位置相加将<script type="math/tex">F_{T_{n}}^{R}</script>和<script type="math/tex">F_{V_{n}^{'}}</script>合并，创建新的时空嵌入<script type="math/tex">F_{V_{n}^{''}}</script>。最后，将<script type="math/tex">F_{S_{n}}^{R}</script>与<script type="math/tex">F_{V_{n}^{''}}</script>通道相连接，获得最终的融合特征图<script type="math/tex">F_{V_{n}}</script>。该功能将<script type="math/tex">F_{S_{n}}</script>、<script type="math/tex">F_{T_{n}}</script>和<script type="math/tex">F_{V_{n}}</script>映射为以下<script type="math/tex">G_{n+1}^{3}</script>模块的输入。</p><p><img src="https://i.loli.net/2020/12/24/5H1inxpkBuYWTyE.png" alt="image-20201224114926234"></p><p><strong>Factorized spatio-temporal Self-Attention (F-SA)：</strong>在这里，我们结合了一个时空模拟模块，使<strong>G</strong>能够利用来自所有时空特征位置的线索，并对广泛分离的区域之间的关系进行建模。然而，计算3D时空特征地图中每个位置与所有其他位置之间的相关性在计算上非常昂贵，特别是如果它应用于G中的更高特征地图。因此，我们提出了一种新的因子化时空自我注意，即<strong>F-SA</strong>，如下图所示。它由一个时间上的模拟退火算法和一个空间上的模拟退火算法组成。这种因子分解减少了计算的复杂性，允许在更大的特征地图上应用因子分析</p><p><img src="https://i.loli.net/2020/12/24/Wk6O7SocAsxRIum.png" alt="image-20201224115132598"></p><h3 id="3-2-Discriminator"><a href="#3-2-Discriminator" class="headerlink" title="3.2 Discriminator"></a>3.2 Discriminator</h3><p>为了提高视频和帧质量，类似于MoCoGAN，我们使用了一个双流鉴别器架构，包含一个视频流DV和一个图像流DI。在训练期间，数字视频接受完整的视频作为输入，而双标签从视频中随机抽取帧</p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：ImaGINator</title>
    <link href="http://yoursite.com/2020/12/23/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AImaGINator/"/>
    <id>http://yoursite.com/2020/12/23/论文速读：ImaGINator/</id>
    <published>2020-12-23T13:56:29.000Z</published>
    <updated>2022-06-06T03:22:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>本文提出了一个新的<strong>conditional</strong> GAN模型，即<strong>ImaGINator</strong>，在给定单个图像<script type="math/tex">c_{a}</script>、运动类<script type="math/tex">c_{m}</script>以及噪声<strong>z</strong>的条件下，生成视频序列，如下图所示。</p><blockquote><p>原文地址：<a href="https://openaccess.thecvf.com/content_WACV_2020/papers/WANG_ImaGINator_Conditional_Spatio-Temporal_GAN_for_Video_Generation_WACV_2020_paper.pdf">ImaGINator: Conditional Spatio-Temporal GAN for Video Generation</a></p></blockquote><p><img src="https://i.loli.net/2020/12/23/ktXIgMHDd1f5cL8.png" alt="1"></p><p><strong>ImaGINator</strong>的特性如下：</p><ul><li>采用了一种新的时空融合机制，旨在通过增强<strong>G</strong>在低和高特征级别中使用空间信息来保持外观。通过向<strong>Decoder</strong>注入<script type="math/tex">c_{a}</script>，我们使<strong>G</strong>能够将重点放在生成单独的运动上。这是基于这样的假设，即视频可以在潜在空间以及多级时空特征空间中分解成外观和运动。虽然在每一层外观被保留，只有运动被改变。</li><li>一种新颖的转置<strong>(1+2)</strong>D卷积，将转置的三维卷积滤波器分解成独立的时间和空间分量。这带来了几个好处:(1)额外的非线性校正允许模型表示更复杂的函数，(2)它便于优化，因为转置(1+2)D卷积块比完全转置的3D卷积滤波器更容易优化，以及(3)它在视频质量和速度方面产生显著的增益</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>与之前文章中的MoCoGAN进行比较，MoCoGAN基于seq2seq架构，旨在将时空生成分为两步(将每个视频帧分解为不同潜在空间中的运动和外观)。然而，这种两步生成省略了在更高空间级别的时间一致性的建模，这通常不能保持原始外观。</p><p>与此不同，我们提出了一种单步架构，它在多级特征空间中分解运动和外观，用于图像到视频的生成。</p><h2 id="3-NetWork-Architecture"><a href="#3-NetWork-Architecture" class="headerlink" title="3. NetWork Architecture"></a>3. NetWork Architecture</h2><p>我们的目标是生成给定外观信息(作为单个图像帧)和运动类别(例如，确定面部表情)的视频序列。我们在这里假设一个视频y可以分解为外观<script type="math/tex">c_{a}</script>(源自输入图像)和运动<script type="math/tex">c_{m}</script>(源自类别标签)，在此基础上我们继续生成视频。因此，我们将我们的任务表述为学习一个条件映射G: {z，<script type="math/tex">c_{a}</script>，<script type="math/tex">c_{m}</script>} → y，其中z ~ N(0，1)表示随机噪声。</p><p><img src="https://i.loli.net/2020/12/23/iQ3yBHj9XNCYGmr.png" alt="2"></p><h3 id="3-1-Generator"><a href="#3-1-Generator" class="headerlink" title="3.1 Generator"></a>3.1 Generator</h3><p>我们的<strong>Generator</strong>由一个图像编码器和一个视频解码器组成，见上图。<strong>Encoder</strong>提取各种层中的外观信息，从浅的精细层到深的粗糙层。它将输入图像<script type="math/tex">c_{a}</script>编码为一个潜在矢量<strong>p</strong>，然后通过连接<strong>p</strong>、<script type="math/tex">c_{m}</script>以及随机噪声z ~ N(0，1)，<strong>Decoder</strong>生成一个视频序列。</p><p>在我们的生成器<strong>B</strong>中，我们将使用从2个跳跃连接的FCN-8的想法扩展到4个跳跃连接，但不同之处在于，最初的跳跃连接用于融合预测，而我们的跳跃连接用于融合外观和运动时空特征。我们的跳过连接允许<strong>Decoder</strong>直接从<strong>Encoder</strong>访问低级特征，使<strong>Decoder</strong>能够在每个时间片重用外观特征，并专注于生成运动。</p><h4 id="3-1-1-Spatio-temporal-fusion"><a href="#3-1-1-Spatio-temporal-fusion" class="headerlink" title="3.1.1 Spatio-temporal fusion."></a>3.1.1 Spatio-temporal fusion.</h4><p>假设<strong>G</strong>有<code>n</code>个图层，且<script type="math/tex">F_{i}^{H×W×C_{1}×T}</script>是<strong>G</strong>第<code>i</code>层中有<script type="math/tex">C_{1}</script>个通道的的特征图，<script type="math/tex">f_{i,t}^{H×W×C_{1}}</script>，t ∈ {1, …, T}是<script type="math/tex">F_{i}</script>中第<code>t</code>帧的特征图，<script type="math/tex">F_{n-i}^{H×W×C_{2}}</script>是第<code>n-i</code>层的特征图。</p><p>如下图所示，我们设计<strong>Decoder</strong>和<strong>Encoder</strong>的每一层的输出具有相同的空间维度。我们提出了一种融合机制，在通道方向的维度上连接每个<script type="math/tex">f_{i,t}</script>和<script type="math/tex">F_{n-i}</script>串联成同一个通道尺寸，得到一个新的特征映射<script type="math/tex">F_{i}^{'  H×W×(C_{1}+C_{2})×T}</script>，称为<strong>时空融合(Spatio-temporal fusion)</strong>。这里我们注意到，每个初始特征映射<script type="math/tex">F_{i}</script>呈现生成的视频中几个连续帧的时空特征。通过在不同的特征层次上直接时空融合<script type="math/tex">F_{i}</script>和 <script type="math/tex">F_{n-i}</script>，可以在生成的视频中很好地保留输入信息。</p><p>此外，我们将类别标签(构成一个one-hot向量)直接融合到解码器中，以便为每个层提供对标签的访问。为此，我们首先将热点向量投影到热点特征图上。然后，我们在解码器中将类别标签信息时空融合到不同的层中。我们最终的特征地图是大小为H  × W × (C1+ C2+<script type="math/tex">C_{category}</script>)× T</p><p><img src="https://i.loli.net/2020/12/23/7cL2kewg64tDmsy.png" alt="image-20201223214650481"></p><h4 id="3-1-2-Transposed-1-2-D-Convolution"><a href="#3-1-2-Transposed-1-2-D-Convolution" class="headerlink" title="3.1.2 Transposed (1+2)D Convolution"></a>3.1.2 Transposed (1+2)D Convolution</h4><p>我们注意到，由于难以优化，在一步方法中使用的3D卷积通常会导致产生模糊的视频。然而，得益于空间和时间分解，帧可以在两步方法中单独生成。因此，为了将这种分解结合到一步方法中，我们设计了一个新的卷积层，集成了转置的(1+2)维卷积</p><p>我们建议明确地将转置的3D卷积滤波器分解为两个独立且连续的运算，M个转置的1D时间卷积滤波器之后是一个2D独立的空间分量，我们称之为转置的(1+2)D卷积，如下图所示。这种分解带来了几个好处。第一个好处与这两个操作之间的额外非线性校正有关，因此允许模型表示更复杂的函数。第二个潜在的好处是，分解有助于优化，因为具有分解的时间和空间分量的转置(1+2)D卷积块是比完全转置3D卷积滤波器更容易优化。此外，我们表明，分解转置的3D卷积滤波器在视频质量和速度方面都产生了显著的增益。</p><p><img src="https://i.loli.net/2020/12/23/eUCXnR7S6LHmDVI.png" alt="image-20201223214950367"></p><h3 id="3-2-Two-stream-Discriminator"><a href="#3-2-Two-stream-Discriminator" class="headerlink" title="3.2 Two-stream Discriminator"></a>3.2 Two-stream Discriminator</h3><p>为了提高视频生成中的图像质量，我们设计了一个包含<script type="math/tex">D_{V}</script>和<script type="math/tex">D_{I}</script>的<strong>Two-stream Discriminator</strong>架构。虽然数字视频有五个3D卷积层，但数字视频只包含具有相同数字视频层数的2D卷积。<script type="math/tex">D_{V}</script>接受完整生成的视频作为输入，使用建议的时空融合来融合类别标签的“热点特征图”和第一层的输出，类似于<strong>G</strong>. <script type="math/tex">D_{V}</script>试图测量联合分布p(<script type="math/tex">x_{real}</script>, <script type="math/tex">c_{m}</script>)和p(<script type="math/tex">x_{fake}</script>, <script type="math/tex">c_{m}</script>)间的<strong>KL散度</strong>。我们分别从真实和生成的视频中随机抽取N帧作为输入。</p><h2 id="4-Conclunsion"><a href="#4-Conclunsion" class="headerlink" title="4. Conclunsion"></a>4. Conclunsion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;本文提出了一个新的&lt;strong&gt;con
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>论文速读：MoCoGAN Decomposing Motion and Content for Video</title>
    <link href="http://yoursite.com/2020/12/21/%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB%EF%BC%9AMoCoGAN%20Decomposing%20Motion%20and%20Content%20for%20Video/"/>
    <id>http://yoursite.com/2020/12/21/论文速读：MoCoGAN Decomposing Motion and Content for Video/</id>
    <published>2020-12-21T13:26:14.000Z</published>
    <updated>2022-06-06T03:22:14.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>视频中的视觉信号可以分为内容和运动。内容指定视频中的对象，运动描述它们的动态。在此基础上，本文提出了基于运动和内容分解的生成性对抗网络(MoCoGAN)的视频生成框架。</p><blockquote><p>代码地址：<a href="https://github.com/sergeytulyakov/mocogan">https://github.com/sergeytulyakov/mocogan</a>.</p></blockquote><h3 id="1-1-Related-Work"><a href="#1-1-Related-Work" class="headerlink" title="1.1 Related Work"></a>1.1 Related Work</h3><ul><li>使用循环机制来生成视频片段中帧的运动嵌入（motion）。</li><li>使用卷积神经网络生成图像（content）。</li></ul><h3 id="1-2-Contribution"><a href="#1-2-Contribution" class="headerlink" title="1.2 Contribution"></a>1.2 Contribution</h3><ol><li>我们提出了一种新的用于无条件视频生成的GAN框架，将<strong>噪声向量（noise）</strong>映射到视频中。</li><li>我们展示了所提出的框架提供了一种在视频生成中控制<strong>内容</strong>和<strong>运动</strong>的方法，这是现有视频生成框架所缺乏的。</li><li>为了验证算法的有效性，我们在基准数据集上进行了大量的实验验证，并与目前最先进的视频生成算法<strong>VGAN</strong>和<strong>TGAN</strong>进行了定量和主观比较</li></ol><h2 id="2-MoCoGAN-Framework"><a href="#2-MoCoGAN-Framework" class="headerlink" title="2. MoCoGAN Framework"></a>2. MoCoGAN Framework</h2><p><strong>MoCoGAN</strong>由四个子网络组成，即循环神经网络<script type="math/tex">R_{M}</script>、图像生成器<script type="math/tex">G_{I}</script>、图像鉴别器<script type="math/tex">D_{I}</script>和视频鉴别器<script type="math/tex">D_{V}</script></p><p><img src="https://i.loli.net/2020/12/21/m5Va9dhrUixQyI6.png" alt="1"></p><ol><li>使用高斯分布初始化<script type="math/tex">Z_{C}</script>对内容子空间建模，由于在剪辑的短视频中内容基本保持不变，所以我们使用相同的<script type="math/tex">Z_{C}</script>来生成不同帧。</li><li>视频中的运动由动作子空间<script type="math/tex">Z_{M}</script>建模。用于作为<script type="math/tex">G_{I}</script>输入的向量序列<strong>Z</strong>表示</li></ol><p><img src="https://i.loli.net/2020/12/21/8rB9gz1fp6UKXLq.png" alt="2"></p><blockquote><p>其中<script type="math/tex">z_{C}</script> ∈  <script type="math/tex">Z_{C}</script>以及<script type="math/tex">z_{M}^{(k)}</script> ∈ <script type="math/tex">Z_{M}</script>都各有k个，因为<script type="math/tex">Z_{M}</script>中并不是所有的路径都对应于路径上合理的运动，我们需要学会生成有效的路径，通过循环神经网络对路径生成过程进行建模。</p></blockquote><ol><li><script type="math/tex">R_{M}</script>即为一个循环神经网络，在每一个时间步<strong>k</strong>，都会输入一个服从高斯分布的<script type="math/tex">\epsilon^{(k)}</script>,以及输出一个<script type="math/tex">z_{M}^{(k)}</script>。假设<script type="math/tex">R_{M}</script>(k)为时刻k的输出，则<script type="math/tex">z_{M}^{(k)}</script> = <script type="math/tex">R_{M}</script>(k)。本论文中，使用<strong>GRU</strong>作为<script type="math/tex">R_{M}</script>的实现。</li><li><script type="math/tex">G_{I}</script>将向量序列<strong>Z</strong>映射为向量序列<script type="math/tex">\tilde{v}</script>，其中<script type="math/tex">\tilde{v}</script> = [<script type="math/tex">\tilde{x}^(1)</script>, …, <script type="math/tex">\tilde{x}^(k)</script>]</li><li><script type="math/tex">D_{I}</script>和<script type="math/tex">D_{V}</script>分别用于鉴别单个图像和视频序列。<script type="math/tex">D_{V}</script>获取固定长度的视频片段，例如<strong>T</strong>帧，<strong>T</strong>为一个超参数，论文中设为<strong>16</strong>。<strong>T</strong>可以小于所生成的视频长度<strong>K</strong>。长度为K的视频可以以滑动窗口的方式被分成<strong>K-T+1</strong>个片段，并且每个片段都可以被馈送到<script type="math/tex">D_{V}</script>中。</li><li><script type="math/tex">D_{V}</script>也用来评估所生成的动作。因为<script type="math/tex">G_{I}</script>没有运动的概念，因此对于运动的损失将会直接指向循环神经网络<script type="math/tex">R_{M}</script>。为了骗过<script type="math/tex">D_{V}</script>，生成具有较为真实动作的视频，<script type="math/tex">R_{M}</script>必须学会将输入<script type="math/tex">\epsilon^{(k)}</script>映射为动作系列<strong>Z</strong></li></ol><h2 id="3-Categorical-Dynamics"><a href="#3-Categorical-Dynamics" class="headerlink" title="3. Categorical Dynamics"></a>3. Categorical Dynamics</h2><p>视频中的动态通常是绝对的(例如，离散的动作类别：行走、跑步、跳跃等)。为了对这个分类信号建模，我们用一个分类随机变量<script type="math/tex">Z_{A}</script>来增加RM的输入，其中每个实现都是一个<strong>one-hot</strong>向量。我们保持其不变，因为短视频中动作类别保持不变，因此<script type="math/tex">R_{M}</script>的输入如下图所示。</p><p><img src="https://i.loli.net/2020/12/21/8Tklze5RjWM2JqL.png" alt="3"></p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;p&gt;视频中的视觉信号可以分为内容和运动。内容
      
    
    </summary>
    
      <category term="计算机视觉" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="视频生成" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90/"/>
    
      <category term="GAN" scheme="http://yoursite.com/tags/GAN/"/>
    
  </entry>
  
</feed>
